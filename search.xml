<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kafka如何解决消息积压问题？</title>
      <link href="/2023/09/06/kafka/kafka-ru-he-jie-jue-xiao-xi-ji-ya-wen-ti/"/>
      <url>/2023/09/06/kafka/kafka-ru-he-jie-jue-xiao-xi-ji-ya-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Kafka如何解决消息积压问题？"><a href="#一、Kafka如何解决消息积压问题？" class="headerlink" title="一、Kafka如何解决消息积压问题？"></a>一、Kafka如何解决消息积压问题？</h2><p>首先分析一下消息积压问题的原因，如果不是系统BUG导致的，那就需要优化消费端的逻辑，来提高消费速率。</p><p>如果是系统BUG导致的，那么需要先修复系统BUG，然后再做临时扩容来消费大量的积压消息，具体步骤如下：</p><ol><li>修复消费端的BUG，保证消费端有消费能力（即正常处理）</li><li>新建一个临时Topic，并且扩容机器到n台</li><li>写一个分发程序，将原积压Topic的消息重新消费后重新写入临时Topic里</li><li>等临时Topic把积压消息消费完后，将临时Topic和临时申请的机器释放掉</li></ol><h2 id="二、Kafka如何避免消息积压问题？"><a href="#二、Kafka如何避免消息积压问题？" class="headerlink" title="二、Kafka如何避免消息积压问题？"></a>二、Kafka如何避免消息积压问题？</h2><p><strong>生产端</strong>：可以使用轮询策略，避免partition之间数据差距太大<br><strong>消费端</strong>：</p><ul><li>增加partition并行消费，尽量一个consumer敌营一个partition</li><li>解决消费端代码可能存在的BUG</li><li>调整消费超时时间，避免消费过慢导致出现重平衡</li><li>批量拉取多条消息消费，减少IO交互次数</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时数据区域是怎样的？</title>
      <link href="/2023/09/06/jvm/jvm-yun-xing-shi-shu-ju-qu-yu-shi-zen-yang-de/"/>
      <url>/2023/09/06/jvm/jvm-yun-xing-shi-shu-ju-qu-yu-shi-zen-yang-de/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JVM运行时数据区域是怎样的？"><a href="#一、JVM运行时数据区域是怎样的？" class="headerlink" title="一、JVM运行时数据区域是怎样的？"></a>一、JVM运行时数据区域是怎样的？</h2><p>JVM运行时数据区域组成有以下几项：</p><ul><li><strong>堆</strong>：线程共享，用于存放对象实例，同时还用于垃圾回收</li><li><strong>虚拟机栈</strong>：线程私有，用于存放局部变量（每次方法调用都会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、返回地址等，方法执行完就会弹出栈帧）</li><li><strong>本地方法栈</strong>：线程私有，跟<strong>虚拟机栈</strong>类似，不同的是它支持的是Native方法</li><li><strong>方法区（元空间）</strong>：也叫<strong>永久区</strong>（JDK8之后叫<strong>元空间</strong>），用于存放已经被JVM加载的类信息、常量、静态变量</li><li><strong>程序计数器</strong>：线程私有，用于存放JVM正在执行的字节码指令的地址，用于指示每个线程下一条即将被执行的字节码指令的位置<br><img src="/images/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png" alt="运行时数据区"></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/2023/09/06/spring/spring-shi-wu/"/>
      <url>/2023/09/06/spring/spring-shi-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是事务？"><a href="#一、什么是事务？" class="headerlink" title="一、什么是事务？"></a>一、什么是事务？</h2><p>参考<a href="https://garyleeeee.github.io/2023/07/03/mysql/mysql-shi-wu/">《MySQL事务》</a></p><h2 id="二、Spring支持哪些事务管理类型？"><a href="#二、Spring支持哪些事务管理类型？" class="headerlink" title="二、Spring支持哪些事务管理类型？"></a>二、Spring支持哪些事务管理类型？</h2><p>Spring支持两种类型的事务管理：</p><ul><li><strong>编程式事务管理</strong>：用户需要通过编程的方式手动管理事务的开启、提交、回滚等操作（比较灵活，但是比较难维护）</li><li><strong>声明式事务管理</strong>：用户可以通过注解或XML配置来管理事务（方便，解耦，能将业务代码和事务管理分离）</li></ul><h2 id="三、Spring有哪几种事务实现方式？"><a href="#三、Spring有哪几种事务实现方式？" class="headerlink" title="三、Spring有哪几种事务实现方式？"></a>三、Spring有哪几种事务实现方式？</h2><h3 id="1、基于transactionTemplate、PlatformTransactionManager编程式"><a href="#1、基于transactionTemplate、PlatformTransactionManager编程式" class="headerlink" title="1、基于transactionTemplate、PlatformTransactionManager编程式"></a>1、基于transactionTemplate、PlatformTransactionManager编程式</h3><p>//TODO：编程式实现方式</p><h3 id="2、基于Aspectj-AOP声明式（即基于和命名空间）"><a href="#2、基于Aspectj-AOP声明式（即基于和命名空间）" class="headerlink" title="2、基于Aspectj AOP声明式（即基于和命名空间）"></a>2、基于Aspectj AOP声明式（即基于<tx>和<aop>命名空间）</aop></tx></h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 配置事务 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>advice</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>method</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>*<span class="token punctuation">"</span></span> <span class="token attr-name">propagation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REQUIRED<span class="token punctuation">"</span></span> <span class="token attr-name">rollback-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Exception<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>attributes</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>advice</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 配置织入 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 扫描com.yy.service路径下所有的方法，并加入事务处理 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>pointcut</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tx<span class="token punctuation">"</span></span> <span class="token attr-name">expression</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>exection(* com.yy.service.*.*(..))<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">aop:</span>advisor</span> <span class="token attr-name">advice-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>txAdvice<span class="token punctuation">"</span></span> <span class="token attr-name">pointcut-ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tx<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">aop:</span>config</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、基于注解-Transactional声明式"><a href="#3、基于注解-Transactional声明式" class="headerlink" title="3、基于注解@Transactional声明式"></a>3、基于注解@Transactional声明式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> userDao<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- 开启事务注解 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">tx:</span>annotation-driven</span> <span class="token attr-name">transaction-manager</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transactionManager<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">tx:</span>annotation-driven</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="四、Spring的事务传播行为"><a href="#四、Spring的事务传播行为" class="headerlink" title="四、Spring的事务传播行为"></a>四、Spring的事务传播行为</h2><h3 id="1、什么是Spring的事务传播行为？"><a href="#1、什么是Spring的事务传播行为？" class="headerlink" title="1、什么是Spring的事务传播行为？"></a>1、什么是Spring的事务传播行为？</h3><p>Spring的事务传播行为是用于控制在多个事务方法相互调用时事务的行为，它解决的核心问题是，多个声明了事务的方法相互调用的时候存在事务嵌套问题，那么这个事务的行为应该如何进行传递？<br><strong>举个例子</strong>：如下，如果methodA()调用methodB()，两个方法都开启了事务，那么methodB()是开启一个新事物，还是继续在methodA()事务中执行？这就取决于<strong>事务传播行为</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transaction</span><span class="token punctuation">(</span><span class="token class-name">Propagation</span> <span class="token operator">=</span> REQUIRED<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//doSth</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Transaction</span><span class="token punctuation">(</span><span class="token class-name">Propagation</span> <span class="token operator">=</span> REQUIRED_NEW<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//doSth</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、Spring中事务的传播行为有哪些？"><a href="#2、Spring中事务的传播行为有哪些？" class="headerlink" title="2、Spring中事务的传播行为有哪些？"></a>2、Spring中事务的传播行为有哪些？</h3><p>Spring中事务的传播行为有7种，分别是：</p><ul><li><strong>REQUIRED（默认）</strong>：保证只有一个事务在执行，即如果存在事务则加入之前的事务，不存在事务则开启一个新的事务</li><li><strong>REQUIRED_NEW</strong>：每次执行都开启新的事务</li><li><strong>SUPPORTS</strong>：表示支持该事务，即有事务则加入，没有事务则正常执行</li><li><strong>NOT_SUPPORTED</strong>：表示不支持该事务，即有事务则暂停该事务，没有事务则正常执行</li><li><strong>NEVER</strong>：表示不用事务，如果有事务则抛出异常</li><li><strong>MANDATORY</strong>：表示强制用事务，如果没有事务则抛出异常</li><li><strong>NESTED</strong>：表示嵌套事务，即如果存在事务则嵌套之前的事务中执行，如果不存在事务则新建一个事务（嵌套事务回滚不影响父事务，反之父事务回滚影响嵌套事务）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的持久化机制是怎样的？</title>
      <link href="/2023/09/05/redis/redis-de-chi-jiu-hua-ji-zhi-shi-zen-yang-de/"/>
      <url>/2023/09/05/redis/redis-de-chi-jiu-hua-ji-zhi-shi-zen-yang-de/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis提供了哪些持久化机制？"><a href="#一、Redis提供了哪些持久化机制？" class="headerlink" title="一、Redis提供了哪些持久化机制？"></a>一、Redis提供了哪些持久化机制？</h2><p>Redis提供了两种持久化的机制，分别是RDB和AOF</p><h2 id="二、RDB和AOF有什么区别？"><a href="#二、RDB和AOF有什么区别？" class="headerlink" title="二、RDB和AOF有什么区别？"></a>二、RDB和AOF有什么区别？</h2><h3 id="1、RDB"><a href="#1、RDB" class="headerlink" title="1、RDB"></a>1、RDB</h3><p>RDB是将Redis内存中的数据<strong>定期</strong>保存到磁盘中，防止数据在Redis宕机等异常情况下丢失</p><p><strong>优点</strong>：快照文件比较小，采用了压缩的方式，在数据恢复性能比较好，适合做<font color="red">备份和灾难恢复</font><br><strong>缺点</strong>：实时性低，容易丢数据</p><h3 id="2、AOF"><a href="#2、AOF" class="headerlink" title="2、AOF"></a>2、AOF</h3><p>AOF是将Redis的所有写操作<strong>追加到AOF缓冲区文件（Append Only File）的末尾</strong>，然后再将缓冲区文件的数据写入到磁盘的AOF文件中（什么时候写入是根据刷盘的策略来决定的）</p><p><strong>优点</strong>：实时性高，从而保证了更高的数据可靠性，也支持了更细粒度的数据恢复，适合做<font color="red">数据存档和数据备份</font><br><strong>缺点</strong>：文件比较大，需要经常操作磁盘导致负载较高</p><h3 id="3、RDB和AOF比较"><a href="#3、RDB和AOF比较" class="headerlink" title="3、RDB和AOF比较"></a>3、RDB和AOF比较</h3><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td><strong>数据可靠性</strong></td><td>可能会丢失最后一次快照之后的数据</td><td>保证最后一次写操作之前的数据不会丢失</td></tr><tr><td><strong>读写性能</strong></td><td>读写性能较高，适合做数据恢复</td><td>写性能较高，适合做数据存档</td></tr><tr><td><strong>恢复性能</strong></td><td>从快照文件中恢复数据较快</td><td>从AOF文件中恢复数据较慢</td></tr><tr><td><strong>存储空间占用</strong></td><td>快照文件较小，占用空间较少</td><td>AOF文件较大，占用空间较多</td></tr></tbody></table><h2 id="三、Q-amp-A"><a href="#三、Q-amp-A" class="headerlink" title="三、Q&amp;A"></a>三、Q&amp;A</h2><h3 id="1、Redis能完全保证数据不丢失吗？"><a href="#1、Redis能完全保证数据不丢失吗？" class="headerlink" title="1、Redis能完全保证数据不丢失吗？"></a>1、Redis能完全保证数据不丢失吗？</h3><p>不能，因为Redis是基于内存存储的，当Redis进程异常退出或服务器断电等情况发生时，内存中的数据可能会丢失。</p><p>虽然Redis提供了RDB和AOF两种持久化机制来防止数据丢失，但是在极端情况下也不是完全可靠的，比如<font color="red">通过淘汰策略把某些key移除掉</font></p><p>所以总结来说Redis只是个缓存，我们还是要有自己的持久化方式，比如双写数据到MySQL</p><h3 id="2、AOF有哪些写回策略？"><a href="#2、AOF有哪些写回策略？" class="headerlink" title="2、AOF有哪些写回策略？"></a>2、AOF有哪些写回策略？</h3><p>AOF有三种数据写回策略，分别是：</p><ul><li><strong>Always</strong>：即同步写回，每个写命令执行完，则立马同步地将日志写回磁盘</li><li><strong>Everysec</strong>：即每秒写回，每个写命令执行完，会先缓存到AOF文件的内存缓冲区，每秒执行一次将日志写回磁盘</li><li><strong>No</strong>：即不做控制，每个写命令执行完，会先缓存到AOF文件的内存缓冲区，由操作系统决定什么时候将日志写回磁盘</li></ul><p>Redis默认的写回策略是<strong>Everysec</strong>，因为<strong>Always</strong>虽然数据可靠性最高，但是每次都需要操作磁盘，性能较差，而<strong>No</strong>是不可控的，对于数据来说是不安全的，万一还没持久化就宕机了就会出现数据丢失</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>InnoDB和MyISAM有什么区别？</title>
      <link href="/2023/09/05/mysql/innodb-he-myisam-you-shi-me-qu-bie/"/>
      <url>/2023/09/05/mysql/innodb-he-myisam-you-shi-me-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、InnoDB和MyISAM有什么区别？"><a href="#一、InnoDB和MyISAM有什么区别？" class="headerlink" title="一、InnoDB和MyISAM有什么区别？"></a>一、InnoDB和MyISAM有什么区别？</h2><p>InnoDB和MyISAM都是MySQL的存储引擎，MySQL在5.5之前默认使用MyISAM作为存储引擎，5.5之后默认使用InnoDB作为存储引擎，它们的区别主要是以下几点：</p><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td><strong>事务</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>索引</strong></td><td>聚簇索引</td><td>非聚簇索引</td></tr><tr><td><strong>外键</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>锁支持</strong></td><td>表锁、行锁</td><td>表锁</td></tr><tr><td><strong>全文索引</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>存储方式</strong></td><td>索引和数据一起存储</td><td>索引和数据分开存储</td></tr><tr><td><strong>使用场景</strong></td><td>支持事务、频繁修改</td><td>查询为主</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 存储引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个分布式锁？</title>
      <link href="/2023/09/05/concurrent/ru-he-shi-xian-yi-ge-fen-bu-shi-suo/"/>
      <url>/2023/09/05/concurrent/ru-he-shi-xian-yi-ge-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是分布式锁？"><a href="#一、什么是分布式锁？" class="headerlink" title="一、什么是分布式锁？"></a>一、什么是分布式锁？</h2><p>分布式锁，是一种跨进程、跨机器节点的互斥锁，它可以用来保证多机器节点对于共享资源访问的互斥性。</p><h2 id="二、分布式锁的特点"><a href="#二、分布式锁的特点" class="headerlink" title="二、分布式锁的特点"></a>二、分布式锁的特点</h2><p>想要实现一个分布式锁，主要要有以下几个特点：</p><ul><li><strong>互斥性</strong>：同一时间只能有一个线程获取到锁，然后去访问共享资源</li><li><strong>可重入性</strong>：允许一个已经获取到锁的线程，在没有释放锁之前再次重新获得锁</li><li><strong>避免死锁</strong>：由于分布式网络下容易出现网络延迟、节点故障等原因，死锁概率会比较高，所以需要设置一定的超时机制，让分布式锁在一定时间后自动过期删除</li><li>…</li></ul><h2 id="三、如何实现一个分布式锁？"><a href="#三、如何实现一个分布式锁？" class="headerlink" title="三、如何实现一个分布式锁？"></a>三、如何实现一个分布式锁？</h2><p>想要实现一个分布式锁，就需要依赖一个第三方的分布式组件，比如数据库、Redis等，同时考虑锁的性能问题，所以我们一般使用Redis来实现分布式锁。</p><h3 id="1、Redis实现分布式锁"><a href="#1、Redis实现分布式锁" class="headerlink" title="1、Redis实现分布式锁"></a>1、Redis实现分布式锁</h3><p>在Redis中，可以通过<code>setnx</code>命令实现锁的互斥性，当key不存在就返回1，存在就返回0。另外还可以通过<code>expire</code>命令设置锁的失效时间，从而避免死锁问题。</p><h2 id="四、Q-amp-A"><a href="#四、Q-amp-A" class="headerlink" title="四、Q&amp;A"></a>四、Q&amp;A</h2><h3 id="1、如果锁过期了，而业务逻辑没处理完怎么办？"><a href="#1、如果锁过期了，而业务逻辑没处理完怎么办？" class="headerlink" title="1、如果锁过期了，而业务逻辑没处理完怎么办？"></a>1、如果锁过期了，而业务逻辑没处理完怎么办？</h3><p>可以定时给锁进行续期（比如锁五分钟过期，那么可以每分钟为他续期到五分钟过期），常见的方式有通过Redisson组件来实现一个分布式锁，并且也内置了一个Watch Dog机制来对锁做续期</p><h3 id="2、Redis的分布式锁只有setnx这一方式吗？"><a href="#2、Redis的分布式锁只有setnx这一方式吗？" class="headerlink" title="2、Redis的分布式锁只有setnx这一方式吗？"></a>2、Redis的分布式锁只有setnx这一方式吗？</h3><p>为了保证分布式的可靠性，尽可能减少重复加锁的问题，Redis的分布式锁的演变阶段会由setnx-&gt;Redission-&gt;RedLock</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是倒排索引？</title>
      <link href="/2023/08/26/shi-me-shi-dao-pai-suo-yin/"/>
      <url>/2023/08/26/shi-me-shi-dao-pai-suo-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>在ElasticSearch中，通过关键字/关键词去查找对应文本的过程，是由<strong>全文检索引擎</strong>实现的。</p><p><strong>全文检索引擎</strong>就是对非结构化文本进行解析、搜索的技术，而非结构化文本的处理关键在于<strong>分词</strong>与<strong>倒排索引</strong>。</p><h2 id="二、什么是倒排索引？"><a href="#二、什么是倒排索引？" class="headerlink" title="二、什么是倒排索引？"></a>二、什么是倒排索引？</h2><p>在ElasticSearch中，<strong>倒排索引</strong>是一种常用的数据结构，用于快速检索文档中的某个词汇。</p><p>在传统的索引结构中，是通过哈希表或B+树的数据结构来实现的，存储的是文档ID与对应文档的映射。而在倒排索引中，存储的是关键词与对应文档ID的映射，所以可以快速定位到包含指定关键词的文档列表。</p><p><strong>传统索引结构</strong>：</p><table><thead><tr><th>ID</th><th>文档</th></tr></thead><tbody><tr><td>1</td><td>深入理解Java虚拟机</td></tr><tr><td>2</td><td>Java编程思想</td></tr></tbody></table><p><strong>倒排索引结构</strong>：</p><table><thead><tr><th>关键词</th><th>文档ID</th></tr></thead><tbody><tr><td>深入</td><td>1</td></tr><tr><td>理解</td><td>1</td></tr><tr><td>Java</td><td>1,2</td></tr><tr><td>虚拟机</td><td>1</td></tr><tr><td>编程</td><td>2</td></tr><tr><td>思想</td><td>2</td></tr></tbody></table><h2 id="三、怎么使用倒排索引？"><a href="#三、怎么使用倒排索引？" class="headerlink" title="三、怎么使用倒排索引？"></a>三、怎么使用倒排索引？</h2><h3 id="1、分词"><a href="#1、分词" class="headerlink" title="1、分词"></a>1、分词</h3><p><strong>分词</strong>指的是将文档中的原始文本拆分成一个个词项，在ElasticSearch中默认使用标准分词器（Standard Analyzer）进行分析。如<code>"深入理解Java虚拟机"</code>在经过分词之后就会拆分成<code>["深入","理解","Java","虚拟机"]</code></p><h3 id="2、排序"><a href="#2、排序" class="headerlink" title="2、排序"></a>2、排序</h3><p><strong>排序</strong>指的是搜索结果中会根据每个文档不同得分进行排序，一般会根据相似度算法（TF-IDF和BM25）进行算分。</p><p>得分排序规则：</p><ul><li>优先按得分排序，得分高的排前面</li><li>得分相同的按文档长度排序，文档短的排前面</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科普向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要使用ElasticSearch？</title>
      <link href="/2023/08/26/wei-shi-me-yao-shi-yong-elasticsearch/"/>
      <url>/2023/08/26/wei-shi-me-yao-shi-yong-elasticsearch/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么要使用ElasticSearch？"><a href="#一、为什么要使用ElasticSearch？" class="headerlink" title="一、为什么要使用ElasticSearch？"></a>一、为什么要使用ElasticSearch？</h2><p>因为在我们的业务场景中，可能会有大数据量的查询场景，这时候如果我们用常规的缓存和数据库来提供支持，在极端情况下可能会出现实例负载过高，导致系统不可用。</p><p>所以我们需要选择一款支持大数据量查询的框架或插件支持，ElasticSearch刚好就是这么一个角色。</p><p>ElasticSearch是一个开源的分布式搜索和分析引擎，具有高性能、分布式架构、简单易用以及强大的全文搜索和实时数据分析能力，适用于各种大数据场景下的数据存储、查询和分析需求。</p><h2 id="二、ElasticSearch有哪些特点？"><a href="#二、ElasticSearch有哪些特点？" class="headerlink" title="二、ElasticSearch有哪些特点？"></a>二、ElasticSearch有哪些特点？</h2><p>ElasticSearch有以下几个特点：</p><ul><li><strong>高性能</strong>：具有高性能的搜索和分析能力</li><li><strong>可靠性</strong>：具有可靠性和高可用性，支持数据备份和恢复</li><li><strong>可扩展性</strong>：支持动态扩容节点的</li><li><strong>实时分析</strong>：支持实时分析，可以对数据进行实时查询，有利于快速检索数据</li><li>…</li></ul><h2 id="三、ElasticSearch可以用在哪些场景？"><a href="#三、ElasticSearch可以用在哪些场景？" class="headerlink" title="三、ElasticSearch可以用在哪些场景？"></a>三、ElasticSearch可以用在哪些场景？</h2><ul><li><strong>搜索引擎</strong>：用于快速检索数据，如商品列表、推荐列表等</li><li><strong>日志分析</strong>：通过日志分析，来帮助企业了解其业务的执行情况</li><li><strong>数据分析</strong>：通过数据分析，来帮助企业获取有价值的信息，从而推动产品发展</li><li><strong>实时监控</strong>：通过实时监控，来帮忙业务实时监控数据波动和系统性能，保证系统的正常运行</li><li>…</li></ul><h2 id="四、ElasticSearch为什么这么快？"><a href="#四、ElasticSearch为什么这么快？" class="headerlink" title="四、ElasticSearch为什么这么快？"></a>四、ElasticSearch为什么这么快？</h2><ul><li><strong>倒排索引</strong>：使用了倒排索引，将文档中的每个词和对应所在哪些文档中进行映射，从而实现快速检索速度</li><li><strong>全文索引</strong>：使用了高效的全文索引，将文档转化成可搜索的结构化数据，从而实现快速检索速度</li><li><strong>索引分片</strong>：将每个索引进行分片，使查询的时候可以并行查询，加快数据查询</li><li><strong>索引优化</strong>：支持索引覆盖、索引下推等优化技术，加快数据查询</li><li><strong>分布式存储</strong>：数据存储在多个节点上，从而减少单个节点的压力，提高整体性能</li><li><strong>预处理</strong>：插入数据时会预处理存储到索引中，使得查询时不需要重新进行复杂计算，加快速度查询</li><li><strong>内存存储</strong>：使用了内存存储，减少磁盘IO次数，提高系统查询性能</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是服务降级？</title>
      <link href="/2023/08/25/concurrent/shi-me-shi-fu-wu-jiang-ji/"/>
      <url>/2023/08/25/concurrent/shi-me-shi-fu-wu-jiang-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是服务降级？"><a href="#一、什么是服务降级？" class="headerlink" title="一、什么是服务降级？"></a>一、什么是服务降级？</h2><p>服务降级是一种提高系统稳定性和可用性的策略，简单来说，就是当服务器压力增加时，根据业务需求判断，从而不对外提供部分非核心服务的功能。</p><p>简单举个例子，在秒杀系统中，如果秒杀过程中服务器出现宕机或者部分依赖服务不可用了，做与不做服务降级有什么区别：</p><ul><li><strong>做服务降级</strong>：用户点击抢购后，页面直接返回”系统繁忙，请稍后重试/商品已售空”，用户就能知道是系统崩了/自己没抢到导致的</li><li><strong>不做服务降级</strong>：用户点击抢购后，页面会一直在loading或者显示报错页面，影响用户体验</li></ul><h2 id="二、服务降级有哪些方式？"><a href="#二、服务降级有哪些方式？" class="headerlink" title="二、服务降级有哪些方式？"></a>二、服务降级有哪些方式？</h2><p><strong>服务降级</strong>一般可以分为主动降级和被动降级，具体区别为：</p><ul><li><strong>主动降级</strong>：指通过人工或者定时任务方式来进行降级。一般用在可以预知哪些场景会容易出现问题，比如在秒杀系统中，核心服务是下单支付，那么我们就可以把一些非核心服务（如评论、收藏服务等）关掉，这样就可以减少计算资源，保证核心服务的稳定运行</li><li><strong>被动降级</strong>：指通过限流、超时、故障等策略来进行降级。一般出现在依赖的数据库、第三方服务调用响应慢时，且该服务不是核心服务时会自动降级<ul><li><strong>限流策略降级</strong>：为了避免高并发流量压垮系统导致不可用问题，会通过限流策略会限制一部分用户请求，如在秒杀系统中，设置了10件库存，那就可以在接受了1000次或更多次请求后，就拦截后续用户请求，提示已售空/系统繁忙</li><li><strong>超时策略降级</strong>：为了防止数据库访问、第三方服务调用出现超时导致系统接口时延高的问题，会通过超时策略在超时后做一些降级，如在秒杀系统中，页面除了核心的下单支付功能外，还有推荐banner滚动等，那么我们可以在超时后返回一批默认的数据（而不是报错/阻塞）</li><li><strong>熔断策略降级</strong>：如果依赖的数据库/第三方服务挂了，那么我们就要根据异常返回错误码来触发熔断策略了，从而进行降级，如在秒杀系统中，页面除了核心的下单支付功能外，还有推荐banner滚动等，那么我们可以在内部调用多次失败后，后续的请求就直接返回一批默认的数据（而不会再去调用从而导致失败）</li></ul></li></ul><h2 id="三、服务降级工具"><a href="#三、服务降级工具" class="headerlink" title="三、服务降级工具"></a>三、服务降级工具</h2><p>目前市面上主流的服务降级工具主要有<strong>Alibaba Sentinel</strong>和<strong>Spring Cloud Hystrix</strong></p><h3 id="1、Alibaba-Sentinel"><a href="#1、Alibaba-Sentinel" class="headerlink" title="1、Alibaba Sentinel"></a>1、Alibaba Sentinel</h3><p><strong>Alibaba Sentinel</strong>是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维护来帮助用户保护服务的稳定性。</p><h3 id="2、Spring-Cloud-Hystrix"><a href="#2、Spring-Cloud-Hystrix" class="headerlink" title="2、Spring Cloud Hystrix"></a>2、Spring Cloud Hystrix</h3><p><strong>Spring Cloud Hystrix</strong>是一个库，它提供了服务与服务之间的容错功能，主要体现在延迟容错和容错，从而做到控制分布式系统中的联动故障。<strong>Spring Cloud Hystrix</strong>通过隔离服务的访问点，阻止联动故障，并提供故障的解决方案，从而提高了这个分布式系统的弹性。</p><h3 id="3、Sentinel和Hystrix的区别"><a href="#3、Sentinel和Hystrix的区别" class="headerlink" title="3、Sentinel和Hystrix的区别"></a>3、Sentinel和Hystrix的区别</h3><p><strong>Alibaba Sentinel</strong>侧重于多样化的流量控制、熔断降级、系统负载保护、实时监控和控制台等<br><strong>Spring Cloud Hystrix</strong>侧重于以隔离和熔断为主的容错机制，超时或被熔断的调用将会快速失败，并可以提供fallback机制</p><hr><p>下面是在<strong>Spring Sentinel</strong>官方文档中，关于Sentinel与Hystrix的对比</p><table><thead><tr><th></th><th>Alibaba Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于响应时间或失败比率</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速器模式</td><td>不支持</td></tr><tr><td>系统负载保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 降级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现多级缓存？</title>
      <link href="/2023/08/25/redis/ru-he-shi-xian-duo-ji-huan-cun/"/>
      <url>/2023/08/25/redis/ru-he-shi-xian-duo-ji-huan-cun/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是多级缓存？"><a href="#一、什么是多级缓存？" class="headerlink" title="一、什么是多级缓存？"></a>一、什么是多级缓存？</h2><p>多级缓存指的是在系统的不同环节都添加缓存，以提高系统性能</p><p>我们一般工作中提到的多级缓存一般是本地缓存+分布式缓存：</p><ul><li><strong>本地缓存</strong>：指在当前服务里使用到的缓存，一般使用的是Guava和Caffeine框架，都提供了缓存的过期等机制</li><li><strong>分布式缓存</strong>：指在多个服务里使用到的缓存，一般使用的是Redis和Memcached框架</li></ul><h2 id="二、为什么要用到多级缓存？"><a href="#二、为什么要用到多级缓存？" class="headerlink" title="二、为什么要用到多级缓存？"></a>二、为什么要用到多级缓存？</h2><p>正常情况下，我们不使用本地缓存而直接使用分布式缓存的话，就会涉及网络调用，会出现一定的性能消耗，所以在大型项目中，一般使用多级缓存也就是本地缓存+分布式缓存来实现缓存查询</p><p>使用<strong>本地缓存</strong>的优点：</p><ul><li>减少网络调用，提高性能</li><li>减少分布式缓存的读压力</li></ul><p>使用<strong>本地缓存</strong>的缺点：</p><ul><li>可能会存在与分布式缓存数据不一致的问题</li><li>可能会存在与其他服务集群数据不一致的问题</li><li>重启服务数据会丢失</li><li>进程空间有限，不支持大数据量存储</li></ul><h2 id="三、如何实现多级缓存？"><a href="#三、如何实现多级缓存？" class="headerlink" title="三、如何实现多级缓存？"></a>三、如何实现多级缓存？</h2><p>多级缓存的调用链路一般是：</p><ul><li>先查询本地缓存，如果存在则直接返回</li><li>再查询分布式缓存，如果存在则同步到本地缓存并返回</li></ul><h2 id="四、Q-amp-A"><a href="#四、Q-amp-A" class="headerlink" title="四、Q&amp;A"></a>四、Q&amp;A</h2><h3 id="1、如何解决本地缓存不支持大数据量存储的问题？"><a href="#1、如何解决本地缓存不支持大数据量存储的问题？" class="headerlink" title="1、如何解决本地缓存不支持大数据量存储的问题？"></a>1、如何解决本地缓存不支持大数据量存储的问题？</h3><p>一般在项目中，我们不应该把所有数据都存储到本地缓存里，而是只把热点数据存储到本地缓存里即可，这样可以有效解决本地缓存空间受限问题</p><h3 id="2、如何解决本地缓存和分布式缓存数据不一致问题？"><a href="#2、如何解决本地缓存和分布式缓存数据不一致问题？" class="headerlink" title="2、如何解决本地缓存和分布式缓存数据不一致问题？"></a>2、如何解决本地缓存和分布式缓存数据不一致问题？</h3><p>通常我们使用缓存来分担读压力，就可能会出现数据不一致问题，这种是很难避免的，所以一般情况下我们只需要保证数据的<strong>最终一致性</strong>即可</p><p><strong>最终一致性</strong>方案：如使用Guava框架，使用超时过期、定时更新机制，可以保证数据在一定时间后会进行数据的同步，从而保证数据<strong>最终一致性</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CacheTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">LoadingCache</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token class-name">CacheBuilder</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">refreshAfterWrite</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>  <span class="token comment">//5分钟定时刷新</span>                <span class="token punctuation">.</span><span class="token function">expireAfterAccess</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>  <span class="token comment">//5分钟自动过期</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CacheLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                           <span class="token annotation punctuation">@Override</span>                           <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                               <span class="token keyword">return</span> xxx<span class="token punctuation">;</span>                           <span class="token punctuation">}</span>                       <span class="token punctuation">}</span>                <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本地缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个购物车功能？</title>
      <link href="/2023/08/25/scene/ru-he-she-ji-yi-ge-gou-wu-che-gong-neng/"/>
      <url>/2023/08/25/scene/ru-he-she-ji-yi-ge-gou-wu-che-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是购物车功能？"><a href="#一、什么是购物车功能？" class="headerlink" title="一、什么是购物车功能？"></a>一、什么是购物车功能？</h2><p>购物车指的是用户在选购商品的时候，用来将用户意向购买的商品存放的地方，从而方便用户后续找到这些商品并进行统一支付</p><p>购物车的主要元素有：</p><ul><li>商品ID</li><li>商品数量</li><li>折扣</li><li>添加后的价格变化</li><li>…</li></ul><p>购物车的主要操作有：</p><ul><li>下单</li><li>调整商品数量</li><li>加入/移出购物车</li><li>…</li></ul><h2 id="二、购物车设计"><a href="#二、购物车设计" class="headerlink" title="二、购物车设计"></a>二、购物车设计</h2><p>购物车设计一般要分为未登录和已登录这两种场景</p><h3 id="1、未登录"><a href="#1、未登录" class="headerlink" title="1、未登录"></a>1、未登录</h3><p>对于未登录用户使用购物车功能，他的购物车信息就没必要存储在后端了，只需要在客户端做临时缓存即可，比如Cookie等</p><p>存储的数据也不需要存用户信息，数据如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"cart"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"goods_id"</span><span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>      <span class="token property">"quantity"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"add_time"</span><span class="token operator">:</span> <span class="token number">123456789</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"goods_id"</span><span class="token operator">:</span> <span class="token number">234</span><span class="token punctuation">,</span>      <span class="token property">"quantity"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      <span class="token property">"add_time"</span><span class="token operator">:</span> <span class="token number">234567890</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、已登录"><a href="#2、已登录" class="headerlink" title="2、已登录"></a>2、已登录</h3><p>对于已登录用户使用购物车功能，由于用户数据可以会清理，或者更换设备导致数据丢失，就不能存储在客户端了，所以需要持久化到后端，比如MySQL、Redis等</p><p>存储的数据需要存用户信息，数据如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"uid"</span><span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>  <span class="token property">"cart"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      <span class="token property">"goods_id"</span><span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">,</span>      <span class="token property">"quantity"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>      <span class="token property">"add_time"</span><span class="token operator">:</span> <span class="token number">123456789</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>      <span class="token property">"goods_id"</span><span class="token operator">:</span> <span class="token number">234</span><span class="token punctuation">,</span>      <span class="token property">"quantity"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>      <span class="token property">"add_time"</span><span class="token operator">:</span> <span class="token number">234567890</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>//TODO：后续优化补充</p>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis为什么这么快？</title>
      <link href="/2023/08/23/redis-wei-shi-me-zhe-me-kuai/"/>
      <url>/2023/08/23/redis-wei-shi-me-zhe-me-kuai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis为什么这么快？"><a href="#一、Redis为什么这么快？" class="headerlink" title="一、Redis为什么这么快？"></a>一、Redis为什么这么快？</h2><p>Redis之所以这么快，主要是有以下几个方面的原因：</p><ul><li><strong>基于内存</strong>：由于Redis是内存数据库，即数据存储在内存中，数据的读写速度非常快，同时内存访问速度远比磁盘访问速度快得多</li><li><strong>单线程模型</strong>：由于Redis底层用的是单线程模型，不存在线程之间的切换，所以也就避免了线程切换和上下文切换带来的性能影响</li><li><strong>多线程引入</strong>：Redis 6.0引入了多线程的机制，进一步提升了IO的性能（Redis底层是单线程的，而多线程指的是上层的网络请求，从而提升了读写性能，同时多线程也可以充分利用CPU的多核优势）</li><li><strong>高效的数据结构</strong>：Redis提供了多种高效的数据结构，如list、hash等，能够在O(1)的时间复杂度内完成数据读写操作</li><li><strong>I/O多路复用模型</strong>：Redis在单线程的基础上，采用了I/O多路复用模型，实现了单线程可同时处理多个客户端连接，从而提高了Redis的并发性能</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean的生命周期</title>
      <link href="/2023/08/22/spring/springbean-de-sheng-ming-zhou-qi/"/>
      <url>/2023/08/22/spring/springbean-de-sheng-ming-zhou-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring-Bean的生命周期"><a href="#一、Spring-Bean的生命周期" class="headerlink" title="一、Spring Bean的生命周期"></a>一、Spring Bean的生命周期</h2><p><strong>Spring Bean的生命周期</strong>主要分为五个阶段：</p><ul><li>准备阶段</li><li>实例化（Instantiation）</li><li>属性赋值（Populate）</li><li>初始化（Initialization）</li><li>销毁（Destruction）</li></ul><h3 id="1、准备阶段"><a href="#1、准备阶段" class="headerlink" title="1、准备阶段"></a>1、准备阶段</h3><p>在准备阶段，主要是为了在开始加载Bean之前，从Spring配置中解析并查找Bean有关的配置内容，加载顺序为：</p><ol><li>实例化BeanFactoryPostProcessor（BeanFactory后置处理器）</li><li>实例化BeanPostProcessor（Bean后置处理器）</li><li>实例化BeanPostProcessor实现类</li><li>实例化InstantiationAwareBeanPostProcessorAdapter实现类（实例化感知的Bean后置处理器）</li><li>执行InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()方法（在实例化之前的后置处理）</li></ol><p>以上这些类或者配置是Spring提供给开发者，用来实现Bean加载过程中的扩展机制，在很多和Spring继承的中间件经常使用，如Dubbo</p><p>另外，在准备阶段最重要的是会加载Bean的定义，流程如下：</p><ol><li>扫描xml/注解配置的bean</li><li>生成对应的BeanDefinition</li><li>将BeanDefinition放入beanDefinitionMap</li></ol><h3 id="2、实例化"><a href="#2、实例化" class="headerlink" title="2、实例化"></a>2、实例化</h3><p>在实例化阶段，主要是创建一个普通对象，大概流程为：</p><ol><li>扫描beanDefinitionMap</li><li>遍历拿到BeanDefinition通过反射拿到类的构造方法</li><li>根据构造方法创建一个普通对象（只new没赋值）</li><li>执行InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法</li></ol><h3 id="3、属性赋值（依赖注入）"><a href="#3、属性赋值（依赖注入）" class="headerlink" title="3、属性赋值（依赖注入）"></a>3、属性赋值（依赖注入）</h3><p>在属性赋值阶段，主要是对bean的属性进行依赖注入，大概流程为：</p><ol><li>扫描@Autowired/@Resource等注解的属性</li><li>对扫描出来需要赋值的属性进行依赖注入</li></ol><p>另外，Spring是通过三级缓存来解决循环依赖的问题，具体可看<a href="https://garyleeeee.github.io/2023/08/01/spring/spring-ru-he-jie-jue-xun-huan-yi-lai-de-wen-ti/">《Spring如何解决循环依赖的问题？》</a></p><h3 id="4、初始化"><a href="#4、初始化" class="headerlink" title="4、初始化"></a>4、初始化</h3><p>在初始化阶段，主要是执行一些aware、init等初始化的工作，大概流程为：</p><ol><li>aware：执行实现了BeanNameAware、BeanFactoryAware、ApplicationContextAware等接口的方法，如set</li><li>initMethods：<br> a. 前置处理，如@PostConstuct<br> b. 执行实现了InitializingBean接口的afterPropertiesSet方法<br> c. 执行BeanPostProcessor的自定义initMethod方法<br> d. 后置处理，如@PreDestory<br> e. 实现DisposableBean，用于后面销毁调用</li><li>加入单例池</li></ol><h3 id="5、销毁"><a href="#5、销毁" class="headerlink" title="5、销毁"></a>5、销毁</h3><ol><li>执行postProcessBeforeDestruction（销毁前处理器）：会执行bean中@PreDestory注释的方法</li><li>执行destroyBeans：销毁单例池里的bean</li><li>执行invokeCustomDestroyMethod（执行客户自定义销毁方法）：如实现了DisposableBean的destroyMethod方法</li></ol><hr><p>//TODO待优化</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何防止库存超卖？</title>
      <link href="/2023/08/20/scene/ru-he-fang-zhi-ku-cun-chao-mai/"/>
      <url>/2023/08/20/scene/ru-he-fang-zhi-ku-cun-chao-mai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是库存超卖？"><a href="#一、什么是库存超卖？" class="headerlink" title="一、什么是库存超卖？"></a>一、什么是库存超卖？</h2><p><strong>库存超卖</strong>指的是商品的库存超过我们预计卖出的数量（比如双11可以用9.9抢购iphone手机，但是总共只有10台，如果没处理导致最终被抢购了100台、1000台，超过了预计卖出的数量，就是库存超卖问题）</p><p>一般我们在做商品库存扣减的时候，会先判断库存是否充足，如果充足的话就执行库存扣减操作，如果不充足的话则返回失败</p><p>但在高并发场景下，就可能出现下列问题：<br><img src="/images/scene/%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96.png" alt="库存超卖"><br>多个线程同时查询库存的时候返回充足后，同时对库存进行扣减，导致出现库存超卖的问题</p><h2 id="二、如何防止库存超卖？"><a href="#二、如何防止库存超卖？" class="headerlink" title="二、如何防止库存超卖？"></a>二、如何防止库存超卖？</h2><p>防止库存超卖，本质上就是为了解决并发问题，要保证操作的原子性和有序性：</p><ul><li><strong>原子性</strong>：库存查询、库存扣减等操作，需要作为一个原子操作执行</li><li><strong>有序性</strong>：多个并发线程需要排队执行</li></ul><h3 id="1、MySQL方案"><a href="#1、MySQL方案" class="headerlink" title="1、MySQL方案"></a>1、MySQL方案</h3><p>我们可以使用MySQL的行锁进行update库存操作，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> product<span class="token keyword">set</span> quantity <span class="token operator">=</span> quantity <span class="token operator">-</span> <span class="token comment">#{count}</span><span class="token keyword">where</span> product_id <span class="token operator">=</span> <span class="token number">111</span> <span class="token operator">and</span> quantity <span class="token operator">&gt;=</span> <span class="token comment">#{count}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>缺点</strong>：如果请求全部打到数据库，会出现请求阻塞的情况，最终可能搞垮数据库</p><h3 id="2、Redis-Lua方案"><a href="#2、Redis-Lua方案" class="headerlink" title="2、Redis Lua方案"></a>2、Redis Lua方案</h3><p>Redis作为一个内存数据库，本身的读写操作就很快，所以借助Redis的单线程机制+Lua脚本可以保证操作的原子性，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">if</span> tonumber<span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token keyword">call</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span><span class="token string">'product:111'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span> <span class="token keyword">then</span>  <span class="token comment">-- 库存查询</span>    redis<span class="token punctuation">.</span><span class="token keyword">call</span><span class="token punctuation">(</span><span class="token string">'decr'</span><span class="token punctuation">,</span> <span class="token string">'product:111'</span><span class="token punctuation">)</span>  <span class="token comment">-- 库存扣减</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">-- 成功返回1</span><span class="token keyword">else</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">-- 失败返回0</span><span class="token keyword">return</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Q-amp-A"><a href="#三、Q-amp-A" class="headerlink" title="三、Q&amp;A"></a>三、Q&amp;A</h2><h3 id="1、为什么不使用Redis的setnx指令来防止库存超卖？"><a href="#1、为什么不使用Redis的setnx指令来防止库存超卖？" class="headerlink" title="1、为什么不使用Redis的setnx指令来防止库存超卖？"></a>1、为什么不使用Redis的setnx指令来防止库存超卖？</h3><p><strong>问题1</strong>：当我们用setnx命令时，可以保证只能有一个请求执行成功，但是如果这个请求后续执行异常了呢？那么会导致这个分布式锁不能被释放<br><strong>解决方案</strong>：所以我们一般用set命令代替setnx命令，并设置好过期时间</p><p><strong>问题2</strong>：但是由于这个获取锁的操作和库存扣减操作不是原子的，如果获取锁成功了，由于库存扣减时由于某些原因执行时间超过了锁的过期时间，导致锁被自动释放，所以可能这个锁会被其他线程获取，最终导致超卖<br><strong>解决方案</strong>：//TODO 锁续命</p><p><strong>总结</strong>：Redis的setnx指令在高并发的场景下，锁的竞争会变多，导致性能下降。另外由于获取锁的操作和库存扣减的操作不是原子性，可能会导致超卖</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取锁推荐使用set的方式</span><span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">,</span> <span class="token string">"NX"</span><span class="token punctuation">,</span> <span class="token string">"EX"</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如线程死掉，其他线程无法获取到锁</span><span class="token comment">// 释放锁，非原子操作，可能会释放其他线程刚加上的锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span>requestId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个分数相同则按时间排序的排行榜？</title>
      <link href="/2023/08/20/scene/ru-he-shi-xian-yi-ge-fen-shu-xiang-tong-ze-an-shi-jian-pai-xu-de-pai-xing-bang/"/>
      <url>/2023/08/20/scene/ru-he-shi-xian-yi-ge-fen-shu-xiang-tong-ze-an-shi-jian-pai-xu-de-pai-xing-bang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、如何实现一个排行榜？"><a href="#一、如何实现一个排行榜？" class="headerlink" title="一、如何实现一个排行榜？"></a>一、如何实现一个排行榜？</h2><p>可以使用Redis的zset集合来实现一个排行榜，原因是zset集合可以将分数作为score、用户ID作为value，同时结合zset的排序功能，实现分数从高到低排序，相关的操作命令如下：</p><p><strong>增加分数</strong>：<code>zincrby &lt;key&gt; &lt;score&gt; &lt;uid&gt;</code><br><strong>查询TopN</strong>：<code>zrevrange &lt;key&gt; 0 &lt;N-1&gt; withscores</code><br><strong>查询排行榜人数</strong>：<code>zcard &lt;key&gt;</code><br><strong>查询指定用户排名</strong>：<code>zrank &lt;key&gt; &lt;uid&gt;</code> + 1<br><strong>查询指定用户分数</strong>：<code>zscore &lt;key&gt; &lt;uid&gt;</code><br>…</p><p>查询TopN时，按照的是分数排序，如果分数相同，默认是使用value值做字典排序（如a&gt;b，1&gt;2），而不是按照时间排序。那么，<font color="red"><strong>如果想实现分数相同则按照时间排序应该怎么做呢？</strong></font></p><h2 id="二、如何实现分数相同则按照时间排序？"><a href="#二、如何实现分数相同则按照时间排序？" class="headerlink" title="二、如何实现分数相同则按照时间排序？"></a>二、如何实现分数相同则按照时间排序？</h2><p><strong>分析</strong>：由于查询TopN时是score越大排名越前，而我们想实现分数相同则按照时间排序，就需要结合时间戳来实现，而预期是插入时间越小排名越前（即分数相同时优先显示先插入的），跟score的规则是相反的<br><strong>解决方案</strong>：将分数当做score的整数部分，时间戳当做score的小数部分，查询结果里只取整数部分的分数即可，具体计算为</p><pre class="line-numbers language-none"><code class="language-none">-- 初始score = 分数 + "." + 时间戳-- 改为数学运算score = 分数 + 时间戳 / 1^13-- 倒序处理，使时间戳越小，score越大score = 分数 + (1 - 时间戳 / 1^13)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>limit 1000000,0加载很慢如何优化？</title>
      <link href="/2023/08/20/mysql/limit1000000-0-jia-zai-hen-man-ru-he-you-hua/"/>
      <url>/2023/08/20/mysql/limit1000000-0-jia-zai-hen-man-ru-he-you-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="一、问题分析"><a href="#一、问题分析" class="headerlink" title="一、问题分析"></a>一、问题分析</h2><p>在MySQL中，<code>limit ${offset},${row}</code>表示查询前面offset+row条记录，然后抛弃前offset条记录，读取后row条记录，所以offset越大，偏移量越大，查询性能也就越差</p><h2 id="二、优化方案"><a href="#二、优化方案" class="headerlink" title="二、优化方案"></a>二、优化方案</h2><blockquote><p><strong>优化前</strong>：select * from user limit 1000000,10;</p></blockquote><ul><li><p><strong>ID连续优化</strong>：如果ID连续且不会中断，可以通过<code>&gt;</code>运算符过滤</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 优化后</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">1000000</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>order by优化</strong>：结合order by使用，<font color="red">MySQL会找到指定行数的排序结果后就停止排序，而不是对整个结果进行排序，如果用的是主键ID，效率会更快</font></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 优化后</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>子查询优化</strong>：如果存在主键ID，可以先通过子查询返回的主键ID作为过滤条件，再进行回表查询（<font color="red">这种方式可以减少回表次数</font>）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token keyword">where</span> id <span class="token operator">&gt;=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>上下文优化</strong>：如果业务场景允许，可以记录上一页分页的最后一个主键ID，然后作为查询条件去进行分页</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token keyword">where</span> id <span class="token operator">&gt;=</span> ${max_id_in_last_page}<span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>设计优化</strong>：从业务场景来看，一般是不可能出现深度分页查询的，所以我们可以对分页参数进行校验，返回非法参数提示（如果真的存在这种场景，可以考虑使用es等组件提供大数量查询的支持）</p></li></ul><h2 id="三、Q-amp-A"><a href="#三、Q-amp-A" class="headerlink" title="三、Q&amp;A"></a>三、Q&amp;A</h2><h3 id="1、order-by-limit查询时返回数据结果有时候跟单独使用order-by查询时返回结果不同，是正常的吗？"><a href="#1、order-by-limit查询时返回数据结果有时候跟单独使用order-by查询时返回结果不同，是正常的吗？" class="headerlink" title="1、order by+limit查询时返回数据结果有时候跟单独使用order by查询时返回结果不同，是正常的吗？"></a>1、order by+limit查询时返回数据结果有时候跟单独使用order by查询时返回结果不同，是正常的吗？</h3><p>是正常的，举个例子，比如以下两个查询的结果就可以不一样：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- order by</span>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ratings <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> category<span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token operator">|</span> id <span class="token operator">|</span> category <span class="token operator">|</span> rating <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">4.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">3.2</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.7</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">6</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span>        <span class="token number">3</span> <span class="token operator">|</span>    <span class="token number">5.0</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">7</span> <span class="token operator">|</span>        <span class="token number">3</span> <span class="token operator">|</span>    <span class="token number">2.7</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token comment">-- order by + limit</span>mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ratings <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> category <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token operator">|</span> id <span class="token operator">|</span> category <span class="token operator">|</span> rating <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">4.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">3.2</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.7</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">6</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.5</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析</strong>：原因是MySQL是使用order by查询时，如果如果结果存在重复值，那么它会按照不同的执行计划可能返回不同的数据表现<br><strong>解决方案</strong>：可以考虑使用用几个字段参与order by排序，减少组合数据重复的可能性，如</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> ratings <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> category<span class="token punctuation">,</span>id <span class="token keyword">LIMIT</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token operator">|</span> id <span class="token operator">|</span> category <span class="token operator">|</span> rating <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">4.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span>        <span class="token number">1</span> <span class="token operator">|</span>    <span class="token number">3.2</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.7</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.5</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">6</span> <span class="token operator">|</span>        <span class="token number">2</span> <span class="token operator">|</span>    <span class="token number">3.5</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+--------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个扫码登录功能？</title>
      <link href="/2023/08/20/ru-he-shi-xian-yi-ge-sao-ma-deng-lu-gong-neng/"/>
      <url>/2023/08/20/ru-he-shi-xian-yi-ge-sao-ma-deng-lu-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是扫码登录？"><a href="#一、什么是扫码登录？" class="headerlink" title="一、什么是扫码登录？"></a>一、什么是扫码登录？</h2><p><strong>扫码登录</strong>指的是通过已经登录的APP应用，取扫描未登录的Web端程序中的二维码，通过某种机制触发登录凭证的写入从而实现Web端自动登录的过程</p><h2 id="二、扫描登录的流程"><a href="#二、扫描登录的流程" class="headerlink" title="二、扫描登录的流程"></a>二、扫描登录的流程</h2><p>扫码登录的流程主要有以下几步：</p><ol><li>Web端打开登录页面，请求服务端获取一个二维码（带有一个唯一标识ID），同时Web端会轮询这个二维码的状态</li><li>APP扫描这个二维码，获取到二维码ID，同时将APP的token信息发送给服务端</li><li>服务端拿到扫码请求，会先修改二维码状态为已扫码，并生成一个临时token</li><li>Web端轮询到该二维码已被扫描，会更改二维码显示状态</li><li>APP拿到服务端返回的临时token后，提示是否确认授权</li><li>确认授权后，会携带临时token给服务端，服务端修改二维码状态为已授权，并为Web端生成授权token</li><li>Web端轮询到该二维码已授权，会请求服务端拿到token，并完成扫码登录</li></ol><p><img src="/images/%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95.png" alt="扫码登录"></p>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理Redis的大key问题？</title>
      <link href="/2023/08/19/redis/ru-he-chu-li-redis-de-da-key-wen-ti/"/>
      <url>/2023/08/19/redis/ru-he-chu-li-redis-de-da-key-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是大key？"><a href="#一、什么是大key？" class="headerlink" title="一、什么是大key？"></a>一、什么是大key？</h2><p>Redis的大key指的是存储了大量数据的key，一般是因为元素过多导致的（如set、zset等），也有可能是因为value比较大（如string）</p><h2 id="二、大key会带来什么问题？"><a href="#二、大key会带来什么问题？" class="headerlink" title="二、大key会带来什么问题？"></a>二、大key会带来什么问题？</h2><p>大key可能会存在以下几个问题：</p><ul><li><strong>占用内存大</strong>：大量的大key会占用大量的内存</li><li><strong>影响性能</strong>：大key会影响读写性能（可能也会出现网络传输延迟）</li><li><strong>影响备份</strong>：大key的持久化备份需要更多的磁盘空间和时间</li><li>…</li></ul><h2 id="三、如何处理大key问题？"><a href="#三、如何处理大key问题？" class="headerlink" title="三、如何处理大key问题？"></a>三、如何处理大key问题？</h2><p>处理大key问题，可以有以下几个方案：</p><ul><li><strong>大key拆分小key</strong>：类似分表，可以将一个大key按照某种规则分为多个小key（如通过id做hash分为10个小key），可以有效避免大key问题</li><li><strong>使用Cluster集群</strong>：可以通过不同的大key分配不到不同的hash slot槽中，从而分散到各个节点上，以提高响应速度</li><li><strong>数据压缩</strong>：通过写数据的时候进行压缩，然后读数据的时候进行解压缩，减少内存的占用</li><li><strong>设计优化</strong>：分析大key出现的原因，考虑该场景下是否可以不用设计大key</li><li>…</li></ul><h2 id="四、Q-amp-A"><a href="#四、Q-amp-A" class="headerlink" title="四、Q&amp;A"></a>四、Q&amp;A</h2><h3 id="1、多大的key才算大key？"><a href="#1、多大的key才算大key？" class="headerlink" title="1、多大的key才算大key？"></a>1、多大的key才算大key？</h3><p>Redis中多大的key才算大key并没有固定标准，主要取决于具体场景和应用需求。但是一般来说，大key指的是存储了大量数据的key，一般是因为元素过多导致的（如set、zset等），也有可能是因为value比较大（如string）</p><p>通常情况下，建议一个key的value大小尽量不要超过1MB，set/zset集合的元素数量尽量不要超过1w个，否则可能会出现性能问题，当然具体问题具体分析，具体情况还要参考具体场景和应用需求来做出调整</p><h3 id="2、如何查找大key？"><a href="#2、如何查找大key？" class="headerlink" title="2、如何查找大key？"></a>2、如何查找大key？</h3><p>Redis可以通过<code>redis-cli</code>来查找大key，具体命令是<code>redis-cli -bigkeys</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Scanning the entire keyspace to find biggest keys as well as</span><span class="token comment"># average sizes per key type. You can use -i 0.1 to sleep 0.1 sec</span><span class="token comment"># per 100 SCAN commands (not usually needed).</span>Biggest string found so far <span class="token string">'test_key'</span> <span class="token keyword">with</span> <span class="token number">5000</span> bytesBiggest list found so far <span class="token string">'test_list'</span> <span class="token keyword">with</span> <span class="token number">4000</span> itemsBiggest <span class="token keyword">set</span> found so far <span class="token string">'test_set'</span> <span class="token keyword">with</span> <span class="token number">3000</span> membersBiggest zset found so far <span class="token string">'test_zset'</span> <span class="token keyword">with</span> <span class="token number">2000</span> membersBiggest <span class="token keyword">hash</span> found so far <span class="token string">'test_hash'</span> <span class="token keyword">with</span> <span class="token number">1000</span> <span class="token keyword">fields</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何排查慢SQL问题？</title>
      <link href="/2023/08/19/mysql/ru-he-pai-cha-man-sql-wen-ti/"/>
      <url>/2023/08/19/mysql/ru-he-pai-cha-man-sql-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、如何发现慢SQL问题？"><a href="#一、如何发现慢SQL问题？" class="headerlink" title="一、如何发现慢SQL问题？"></a>一、如何发现慢SQL问题？</h2><p>慢SQL指的是数据库中查询时间超过指定阈值的SQL，比如阈值设置为1s，那么说明如果一条SQL执行时间超过1s，则认为这是一条慢SQL</p><p>通常在实际开发中，如果有成熟的监控体系的话，那么会自动把慢SQL统计出来，并通过告警通知开发人员处理</p><p>如果没有的话，自己也是可以配置慢SQL日志并查询的，步骤如下：</p><ol><li>找到MySQL的配置文件<code>my.cnf</code>/<code>my.ini</code>（通常放在MySQL目录的etc或conf文件夹里）</li><li>在配置文件中配置开启慢查询日志<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">slow_query_log <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">--是否开启慢查询日志</span>slow_query_log_file <span class="token operator">=</span> <span class="token operator">/</span>path<span class="token operator">/</span><span class="token keyword">to</span><span class="token operator">/</span>slow<span class="token operator">-</span>query<span class="token punctuation">.</span>log  <span class="token comment">--慢查询日志地址</span>long_query_time <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment">--慢查询时间阈值（超过该值则为慢查询）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>保存文件并重试MySQL，使配置生效</li><li><em>执行时间超过<code>long_query_time</code>的SQL，会自动打印慢SQL日志</em></li><li>查看慢查询日志：<code>cat /path/to/slow-query.log</code></li><li>分析慢查询日志<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># Time: 2023-08-01T00:00:00.00Z</span><span class="token comment"># User@Host: test[192.168.0.1]:3306</span><span class="token comment"># Query_time: 1.23456  Lock_time: 0.012345 Rows_sent: 10  Rows_examined: 100</span><span class="token keyword">SET</span> <span class="token keyword">timestamp</span><span class="token operator">=</span><span class="token number">1234567890</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span> <span class="token keyword">WHERE</span> age <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">;</span>  <span class="token comment">--慢查询SQL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="二、如何定位并解决慢SQL问题？"><a href="#二、如何定位并解决慢SQL问题？" class="headerlink" title="二、如何定位并解决慢SQL问题？"></a>二、如何定位并解决慢SQL问题？</h2><p>一般来说，慢SQL问题都是由索引造成的，少数情况可能是多表查询、深度分页等造成的，具体可以参考<a href="https://garyleeeee.github.io/2023/08/19/mysql/ru-he-jin-xing-sql-diao-you/">如何进行SQL调优？</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何进行SQL调优？</title>
      <link href="/2023/08/19/mysql/ru-he-jin-xing-sql-diao-you/"/>
      <url>/2023/08/19/mysql/ru-he-jin-xing-sql-diao-you/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么需要进行SQL调优？"><a href="#一、为什么需要进行SQL调优？" class="headerlink" title="一、为什么需要进行SQL调优？"></a>一、为什么需要进行SQL调优？</h2><p>错误的使用SQL，可能会带来慢SQL查询等，影响查询性能</p><h2 id="二、分析原因"><a href="#二、分析原因" class="headerlink" title="二、分析原因"></a>二、分析原因</h2><ul><li><strong>索引失效</strong></li><li><strong>多表join</strong></li><li><strong>数据量太大</strong></li><li><strong>查询数据太多</strong></li><li><strong>表结构不合理</strong></li><li>…</li></ul><h2 id="三、SQL优化方案"><a href="#三、SQL优化方案" class="headerlink" title="三、SQL优化方案"></a>三、SQL优化方案</h2><ul><li><strong>索引失效</strong>：可以通过执行计划分析是否走了索引，以及走的索引是否符合预期，从而对索引进行优化或者调整SQL，具体可以参考<a href="https://garyleeeee.github.io/2023/08/15/mysql/ru-he-pai-cha-mysql-suo-yin-shi-xiao-de-wen-ti/">《如何排查MySQL索引失效的问题？》</a></li><li><strong>多表join</strong>：//TODO</li><li><strong>数据量太大</strong>：一般数据量太大，也会导致查询效率遍地，一般优化方案有<ul><li><strong>分库分表</strong></li><li><strong>数据归档</strong>：如把历史数据打包存储，仅做归档处理，不提供查询等</li><li><strong>使用第三方数据库支持</strong>：如同步数据到搜索引擎上，可支持大量数据查询</li></ul></li><li><strong>查询数据太多</strong>：避免使用<code>select *</code>，尽量显示查询自己需要的字段，可以有效减少回表</li><li><strong>表结构不合理</strong>：如数据没有做好冗余，导致查询时需要多表关联查询等</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL执行计划分析</title>
      <link href="/2023/08/18/mysql/mysql-zhi-xing-ji-hua-fen-xi/"/>
      <url>/2023/08/18/mysql/mysql-zhi-xing-ji-hua-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、执行计划字段介绍"><a href="#一、执行计划字段介绍" class="headerlink" title="一、执行计划字段介绍"></a>一、执行计划字段介绍</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+                                           </span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra                    <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+                                           </span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> t2    <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">index</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> idx_abcd <span class="token operator">|</span> <span class="token number">198</span>     <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span>    <span class="token number">5</span> <span class="token operator">|</span>    <span class="token number">20.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+--------------------------+</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个执行计划中，共有12个字段，分别为：</p><ul><li><strong>id</strong>：代表每个查询的唯一标识符（自增）</li><li><strong>select_type</strong>：表示查询类型，包括SIMPLE、PRIMARY、SUBQUERY、UNION等</li><li><strong>table</strong>：查询哪张表</li><li><strong>partitions</strong>：坐落分区（一般为NULL）</li><li><strong>type</strong>：表示索引类型，包括ALL、index、range、ref、eq_ref、const等</li><li><strong>possible_keys</strong>：表示可能命中的索引</li><li><strong>key</strong>：表示实际命中的索引</li><li><strong>key_len</strong>：表示索引的长度（如id类型为long，占用8字节，所以key_len=8），索引长度越短，查询效率越高</li><li><strong>ref</strong>：表示连接操作所使用的索引（可以是某一列、也可以是常数）</li><li><strong>rows</strong>：表示本次查询扫描行数（即扫描表中多少行才能得到结果，不一定等于最终结果数，扫描行数越少越好）</li><li><strong>filter</strong>：表示本次查询过滤掉的行数占扫描行数的百分比（百分比越大，说明查询结果越准确）</li><li><strong>Extra</strong>：表示其他额外的信息，包括Using index、Using filesort、Using temporary等</li></ul><h3 id="1、type"><a href="#1、type" class="headerlink" title="1、type"></a>1、type</h3><p>type取值包括ALL、index、range、ref、eq_ref、const等，举例说明：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t<span class="token punctuation">`</span> <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>a<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>b<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>c<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>d<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>f<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>f<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>f<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>idx_abcd<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>a<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>b<span class="token punctuation">`</span><span class="token punctuation">,</span><span class="token punctuation">`</span>c<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>d<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>ALL</strong>：表示全表查询，如<code>explain select * from t where d = 'test'';</code></li><li><strong>index</strong>：表示全索引查询（不包括最左前缀匹配的查询，和<code>ALL</code>区别是按照索引顺序查询），如<code>explain select c from t where b= 'test';</code></li><li><strong>range</strong>：表示范围查询，如<code>explain select * from t where a between 'min' and 'max';</code></li><li><strong>ref</strong>：表示非唯一索引查询，如<code>explain select * from t where a = 'test';</code></li><li><strong>eq_ref</strong>：表示唯一索引查询，用来做等值连接查询，如<code>explain select * from t1 join t2 on t1.id = t2.id where t1.f = 'test';</code></li><li><strong>const</strong>：表示常数索引查询（唯一索引），如<code>explain select * from t where f = 'test';</code></li></ul><p><strong>总结</strong>：在效率上，<code>const</code>&gt;<code>eq_ref</code>&gt;<code>ref</code>&gt;<code>range</code>&gt;<code>index</code>&gt;<code>ALL</code></p><h3 id="2、Extra"><a href="#2、Extra" class="headerlink" title="2、Extra"></a>2、Extra</h3><p>Extra表示查询时的一些额外信息，包括Using index、Using filesort、Using temporary等</p><ul><li><strong>Using where</strong>：表示MySQL在索引检索后，再通过条件过滤（where）；或者查询的列未被索引覆盖，用联合索引的非前导列查询，通过条件过滤（where）<ul><li><strong>场景1：非索引字段查询</strong>：<code>explain select * from t where d = 'test';</code></li><li><strong>场景2：未被覆盖索引</strong>：<code>explain select d from t where b = 'test';</code></li></ul></li><li><strong>Using index</strong>：表示MySQL通过索引查询时使用了<font color="red">覆盖索引</font>优化，只需要扫描索引（非聚簇索引），而无需回表到数据表（聚簇索引）中查找<ul><li><strong>覆盖索引</strong>：<code>explain select b,c from t where a = 'test';</code></li></ul></li><li><strong>Using index condition</strong>：表示MySQL通过索引查询时无法使用覆盖索引，需要回表到数据表（聚簇索引）中查找<ul><li><strong>索引下推</strong>：<code>explain select d from t where a = 'test' and b like 't%';</code></li></ul></li><li>…</li></ul><h2 id="二、如何判断sql有没有命中索引？"><a href="#二、如何判断sql有没有命中索引？" class="headerlink" title="二、如何判断sql有没有命中索引？"></a>二、如何判断sql有没有命中索引？</h2><p>判断sql有没有命中索引，通常需要看key有没有值，有的话则说明用到了索引，但是具体怎么用的，还需要看type和extra，举例说明：</p><blockquote><p>例子1：<code>explain select b from t where a in ('a','b');</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> Extra                    <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">index</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> idx_abcd <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">where</span><span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析</strong>：<code>key=idx_abcd</code>说明用到了索引，但是没有遵守最左前缀匹配，或者遵守最左前缀匹配但是使用a进行了范围查询，导致<code>extra=Using where;Using index;</code>。所以这条sql<font color="red">走了索引，但是效率不高</font></p><blockquote><p>例子2：<code>explain select * from t where a = 'test';</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> Extra                    <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> ref   <span class="token operator">|</span> idx_abcd      <span class="token operator">|</span> idx_abcd <span class="token operator">|</span> <span class="token boolean">NULL</span>                     <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析</strong>：<code>type=ref</code>表示用的是非唯一索引，且该非唯一索引是<code>key=idx_abcd</code></p><blockquote><p>例子3：<code>explain select * from t where f = 'f';</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> Extra                    <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> const <span class="token operator">|</span> f             <span class="token operator">|</span> f        <span class="token operator">|</span> <span class="token boolean">NULL</span>                     <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析</strong>：<code>type=const</code>表示用的是唯一索引，且该唯一索引是<code>key=f</code></p><blockquote><p>例子4：<code>explain select b,c from t where a = 'test';</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> Extra                    <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> ref   <span class="token operator">|</span> idx_abcd      <span class="token operator">|</span> idx_abcd <span class="token operator">|</span>  <span class="token keyword">Using</span> <span class="token keyword">index</span>             <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析</strong>：<code>type=ref</code>表示用的是非唯一索引，且该非唯一索引是<code>key=idx_abcd</code>，另外<code>Extra=Using index</code>表示用到了覆盖索引，不需要回表</p><blockquote><p>例子5：<code>explain select b,c from t where d = 'test';</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span>  <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>      <span class="token operator">|</span> Extra                    <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+                                           </span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">ALL</span>   <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span>     <span class="token operator">|</span>  <span class="token keyword">Using</span> <span class="token keyword">where</span>             <span class="token operator">|</span>                                           <span class="token operator">+</span><span class="token comment">----+-------+---------------+----------+--------------------------+ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>解析</strong>：<code>type=ALL,key=NULL</code>表示没有用到索引</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是回表，怎么减少回表的次数？</title>
      <link href="/2023/08/17/mysql/shi-me-shi-hui-biao-zen-me-jian-shao-hui-biao-de-ci-shu/"/>
      <url>/2023/08/17/mysql/shi-me-shi-hui-biao-zen-me-jian-shao-hui-biao-de-ci-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是回表？"><a href="#一、什么是回表？" class="headerlink" title="一、什么是回表？"></a>一、什么是回表？</h2><p>不了解什么是聚簇索引和非聚簇索引的小伙伴可以先看下<a href="https://garyleeeee.github.io/2023/08/17/mysql/shi-me-shi-ju-cu-suo-yin-he-fei-ju-cu-suo-yin/">《什么是聚簇索引和非聚簇索引？》</a></p><p>什么是回表呢？当我们要查询数据的时候，如果是通过主键ID查询，那么直接会在聚簇索引查询，而如果是通过其他索引查询，就会先通过非聚簇索引查询拿到对应的主键ID，那么使用主键ID通过聚簇索引再一次查询才能拿到我们查询的数据。这个过程叫做<strong>回表</strong></p><h2 id="二、怎么减少回表的次数？"><a href="#二、怎么减少回表的次数？" class="headerlink" title="二、怎么减少回表的次数？"></a>二、怎么减少回表的次数？</h2><p>由于回表次数过多会影响性能，所以我们尽量要减少回表的次数</p><h3 id="1、覆盖索引"><a href="#1、覆盖索引" class="headerlink" title="1、覆盖索引"></a>1、覆盖索引</h3><p><strong>覆盖索引</strong>指的执行查询语句时只需要在<strong>非聚簇索引</strong>中查询即可，不需要进行回表查询，主要的做法是通过设置联合索引覆盖需要查询的结果字段</p><blockquote><p>比如要查询用户名称和年龄，sql是select * from user where age = 18;</p></blockquote><ol><li>由于只需要查询用户名称和年龄，所以sql可以优化为<code>select name,age from user where age = 18</code></li><li>由于要同时查询用户名称和年龄，所以要建立一个联合索引作为非聚簇索引<code>key idx_age_name(age,name)</code></li></ol><p>这样子我们就完成了覆盖索引，查询数据时只需要在非聚簇索引中拿到查询结果字段即可，无需回表查询</p><h3 id="2、索引下推（系统优化）"><a href="#2、索引下推（系统优化）" class="headerlink" title="2、索引下推（系统优化）"></a>2、索引下推（系统优化）</h3><p><strong>索引下推</strong>是MySQL5.6引入的一种优化技术，默认开启，可以使用<code>set optimizer_switch = 'index_condition_pushdown=off'</code>将其关闭<br><strong>索引下推</strong>主要的目的是减少数据查询中不必要的数据读取和计算，实现原理是将原本<font color="red">由Server层做的索引条件检查下推给索引层面来做</font>，从而减少回表次数</p><blockquote><p>比如要查询名为Lisi、所在城市名包含Z、且年龄大于25的用户，sql是select * from user where name = ‘Lisi’ and city like ‘%Z%’ and age &gt; 25;同时创建联合索引(name,city)</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 数据</span>mysql<span class="token operator">&gt;</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+----------+-----------+------+</span><span class="token operator">|</span> id <span class="token operator">|</span> name     <span class="token operator">|</span> city      <span class="token operator">|</span> age  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+-----------+------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> ZhaoDa   <span class="token operator">|</span> BeiJing   <span class="token operator">|</span>   <span class="token number">20</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> QianEr   <span class="token operator">|</span> ShangHai  <span class="token operator">|</span>   <span class="token number">21</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> SunSan   <span class="token operator">|</span> GuanZhou  <span class="token operator">|</span>   <span class="token number">22</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> LiSi     <span class="token operator">|</span> ShenZhen  <span class="token operator">|</span>   <span class="token number">24</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> ZhouWu   <span class="token operator">|</span> NingBo    <span class="token operator">|</span>   <span class="token number">25</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">6</span> <span class="token operator">|</span> WuLiu    <span class="token operator">|</span> HangZhou  <span class="token operator">|</span>   <span class="token number">26</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">7</span> <span class="token operator">|</span> ZhengQi  <span class="token operator">|</span> NanNing   <span class="token operator">|</span>   <span class="token number">27</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">8</span> <span class="token operator">|</span> WangBa   <span class="token operator">|</span> YinChuan  <span class="token operator">|</span>   <span class="token number">28</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">9</span> <span class="token operator">|</span> LiSi     <span class="token operator">|</span> TianJin   <span class="token operator">|</span>   <span class="token number">29</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">10</span> <span class="token operator">|</span> ZhangSan <span class="token operator">|</span> NanJing   <span class="token operator">|</span>   <span class="token number">30</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">11</span> <span class="token operator">|</span> CuiShi   <span class="token operator">|</span> ZhengZhou <span class="token operator">|</span>   <span class="token number">65</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">12</span> <span class="token operator">|</span> LiSi     <span class="token operator">|</span> KunMing   <span class="token operator">|</span>   <span class="token number">29</span> <span class="token operator">|</span><span class="token operator">|</span> <span class="token number">13</span> <span class="token operator">|</span> LiSi     <span class="token operator">|</span> ZhengZhou <span class="token operator">|</span>   <span class="token number">30</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+----------+-----------+------+</span><span class="token number">13</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>未使用索引下推</strong>：</p><ol><li>通过联合索引(name,city)，通过非聚簇索引找到name为Lisi的4条记录（<font color="red">由于city用的是模糊查询，不走索引</font>），并拿到主键ID</li><li>根据步骤1拿到的主键ID，去聚簇索引找到对应的数据，返回给Server层（<font color="red">回表4次</font>）</li><li>Server层通过where条件<code>name="LiSi" and city like "%Z%" and age &gt; 25</code>过滤，最终剩下1条记录<br><img src="/images/mysql/%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" alt="未使用索引下推"></li></ol><p><strong>使用索引下推</strong>：</p><ol><li>通过联合索引(name,city)，通过非聚簇索引找到name为Lisi的4条记录（<font color="red">由于city用的是模糊查询，不走索引</font>），并拿到主键ID</li><li><font color="red">使用索引下推</font>，结合联合索引(name,city)，索引直接过滤`city like ‘%Z%’，剩下2条记录</li><li>根据步骤2拿到的主键ID，去聚簇索引找到对应的数据，返回给Server层（<font color="red">回表1次</font>）</li><li>Server层通过剩下的where条件<code>age&gt;25</code>过滤，最终剩下1条记录<br><img src="/images/mysql/%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8.png" alt="使用索引下推"></li></ol><p>最后，我们通过explain语句可以看到确实是使用了索引下推（Extra显示Using index condition）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">"LiSi"</span> <span class="token operator">and</span> city <span class="token operator">like</span> <span class="token string">"%Z%"</span> <span class="token operator">and</span> age <span class="token operator">&gt;</span> <span class="token number">25</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+------------------------------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span> <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>           <span class="token operator">|</span> key_len <span class="token operator">|</span> ref   <span class="token operator">|</span> <span class="token keyword">rows</span> <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra  <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+------------------------------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> <span class="token keyword">user</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> ref  <span class="token operator">|</span> idx_name_city <span class="token operator">|</span> idx_name_city <span class="token operator">|</span> <span class="token number">99</span>      <span class="token operator">|</span> const <span class="token operator">|</span>    <span class="token number">4</span> <span class="token operator">|</span>     <span class="token number">7.69</span> <span class="token operator">|</span> <span class="token keyword">Using</span> <span class="token keyword">index</span> condition<span class="token punctuation">;</span> <span class="token keyword">Using</span> <span class="token keyword">where</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-------+------------+------+---------------+---------------+---------+-------+------+----------+------------------------------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是聚簇索引和非聚簇索引？</title>
      <link href="/2023/08/17/mysql/shi-me-shi-ju-cu-suo-yin-he-fei-ju-cu-suo-yin/"/>
      <url>/2023/08/17/mysql/shi-me-shi-ju-cu-suo-yin-he-fei-ju-cu-suo-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是聚簇索引和非聚簇索引？"><a href="#一、什么是聚簇索引和非聚簇索引？" class="headerlink" title="一、什么是聚簇索引和非聚簇索引？"></a>一、什么是聚簇索引和非聚簇索引？</h2><p><strong>聚簇索引（Clustered Index）</strong>：即主键索引，叶子节点存放了数据节点<br><strong>非聚簇索引（Non-clustered Index）</strong>：即除了主键的其他索引（也叫做二级索引），叶子节点存放了索引节点</p><h2 id="二、聚簇索引和非聚簇索引的区别"><a href="#二、聚簇索引和非聚簇索引的区别" class="headerlink" title="二、聚簇索引和非聚簇索引的区别"></a>二、聚簇索引和非聚簇索引的区别</h2><ul><li><strong>数量</strong>：聚簇索引只能有一个，而非聚簇索引可以有多个</li><li><strong>存储</strong>：聚簇索引存储在物理上连续存在，而非聚簇索引在物理上并不连续，只是逻辑上的连续</li><li><strong>数据</strong>：聚簇索引的叶子节点存的是实际数据，而聚簇索引的叶子节点存的是索引（指向聚簇索引的数据）</li></ul><h2 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h2><h3 id="1、查询一条数据记录的流程是怎样的？"><a href="#1、查询一条数据记录的流程是怎样的？" class="headerlink" title="1、查询一条数据记录的流程是怎样的？"></a>1、查询一条数据记录的流程是怎样的？</h3><p><strong>通过主键索引查询</strong>：</p><ul><li>直接通过主键ID在聚簇索引上查找对应的叶子节点</li></ul><p><strong>通过非主键索引查询</strong>：</p><ul><li>先通过非聚簇索引查找到对应的主键ID</li><li>再通过主键ID在聚簇索引上查找对应的叶子节点</li></ul><h3 id="2、如果没有创建主键怎么办？"><a href="#2、如果没有创建主键怎么办？" class="headerlink" title="2、如果没有创建主键怎么办？"></a>2、如果没有创建主键怎么办？</h3><p><strong>背景</strong>：InnoDB中的聚簇索引是按照每张表的主键创建一个B+树，那么如果没有创建主键怎么办？</p><p>其实，聚簇索引的key不单单是通过主键来创建的，它是有一个选择顺序：</p><ol><li>判断如果有<code>PRIMARY KEY(id)</code>，则作为key，如果没有则判断步骤2</li><li>再判断如果有<code>UNIQUE KEY</code>，则作为key（取第一个），如果没有则判断步骤3</li><li>使用隐藏列<code>DB_ROW_ID</code>作为key（会构造一个<code>GEN_CLUST_INDEX</code>的索引）</li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis内存淘汰策略</title>
      <link href="/2023/08/16/redis/redis-nei-cun-tao-tai-ce-lue/"/>
      <url>/2023/08/16/redis/redis-nei-cun-tao-tai-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>Redis内存淘汰策略，指的是内存的使用率达到<code>maxmemory</code>上限时的一种内存释放行为</p><h2 id="二、Redis有哪些内存淘汰算法？"><a href="#二、Redis有哪些内存淘汰算法？" class="headerlink" title="二、Redis有哪些内存淘汰算法？"></a>二、Redis有哪些内存淘汰算法？</h2><p>Redis内存淘汰算法主要有五种，分别为：</p><ul><li><strong>LRU算法（Least Recently Used）</strong>：移除最近最少使用的key</li><li><strong>LFU算法（Least Frequently Used）</strong>：移除最近最少使用的key（是<strong>LRU算法</strong>的优化增加了数据的访问频次，从而确保淘汰的数据是非热点的）</li><li><strong>Random算法</strong>：随机移除key</li><li><strong>TTL算法</strong>：在设置了过期时间的key中，优先移除即将过期的key</li></ul><h3 id="1、LRU算法"><a href="#1、LRU算法" class="headerlink" title="1、LRU算法"></a>1、LRU算法</h3><p>LRU算法是比较常见的一种内存淘汰算法，它是在Redis中维护了一个大小为16的候选池（双向链表，数据按时间排序），然后每次取出5个key放入候选池里，等候选池满了，候选池里最早的key就会被淘汰掉（新的key插入到头部）</p><p><strong>存在问题</strong>：假如一个key访问频次很低，但是最近一次偶尔被访问到，那么LRU算法会认为它是热点数据，而不会被淘汰<br><strong>解决方案</strong>：使用<strong>LRU算法</strong></p><h3 id="2、LFU算法"><a href="#2、LFU算法" class="headerlink" title="2、LFU算法"></a>2、LFU算法</h3><p>LFU算法是LRU算法的优化，区别是LRU算法注重的是最近是否使用过，LFU算法注重的是频次<br>另外在实现层面上，LRU算法用的是一个双向链表，而LFU算法用的是<font color="red">两个HashMap和多个双向链表，插入数据用尾插法，淘汰数据从链表头淘汰</font></p><blockquote><p>举个例子</p></blockquote><p><strong>前提</strong>：</p><ul><li>HashMap：key=redis key，value=对应节点</li><li>HashMap_Freq：key=频次，value=双向链表(存节点)</li></ul><p><font color="red">注意：为了避免混淆，redis key用字母a、b、c等表示，对应节点用A、B、C等表示。另外链表容量为3</font></p><blockquote><p>步骤1：插入a、b、c</p></blockquote><p>这时候的数据如下：</p><ul><li>HashMap：<code>[a=A,b=B,c=C]</code></li><li>HashMap_Freq：<code>[1={a,b,c}]</code></li><li>移除：</li></ul><p><strong>解析</strong>：</p><ul><li>HashMap存放了数据的key和对应节点，由于是第一次操作，所以在HashMap_Freq中a、b、c都是第一次，存到了key=1的双向链表中</li></ul><blockquote><p>步骤2：插入d</p></blockquote><p>这时候的数据如下：</p><ul><li>HashMap：<code>[d=D,b=B,c=C]</code></li><li>HashMap_Freq：<code>[1={b,c,d}]</code></li><li>移除：<code>a</code></li></ul><p><strong>解析</strong>：</p><ul><li>插入d后HashMap_Freq大小超过容量了，所以要从最小频次（1）拿到最早key（a）移除</li><li>由于插入了d、移除了a，所以在HashMap中d代替了a的位置</li></ul><blockquote><p>步骤3：插入e</p></blockquote><p>这时候的数据如下：</p><ul><li>HashMap：<code>[d=D,e=E,c=C]</code></li><li>HashMap_Freq：<code>[1={c,d,e}]</code></li><li>移除：<code>b</code></li></ul><p><strong>解析</strong>：</p><ul><li>插入e后HashMap_Freq大小超过容量了，所以要从最小频次（1）拿到最早key（b）移除</li><li>由于插入了e、移除了b，所以在HashMap中e代替了b的位置</li></ul><blockquote><p>步骤4：查询d</p></blockquote><p>这时候的数据如下：</p><ul><li>HashMap：<code>[d=D,e=E,c=C]</code></li><li>HashMap_Freq：<code>[1={c,e},2={d}]</code></li></ul><p><strong>解析</strong>：</p><ul><li>由于是查询操作，HashMap不变</li><li>查询d，d在HashMap_Freq对应的频次（1）要加1（2）</li></ul><blockquote><p>步骤5：插入f</p></blockquote><p>这时候的数据如下：</p><ul><li>HashMap：<code>[d=D,e=E,f=F]</code></li><li>HashMap_Freq：<code>[1={e,f},2={d}]</code></li><li>移除：<code>c</code></li></ul><p><strong>解析</strong>：</p><ul><li>插入f后HashMap_Freq大小超过容量了，所以要从最小频次（1）拿到最早key（c）移除</li><li>由于插入了f、移除了c，所以在HashMap中f代替了c的位置</li></ul><hr><p><strong>总结LRU算法的关键逻辑</strong>：</p><ul><li>使用一个HashMap存放key和对应节点，一个HashMap_Freq存放频次和对应key双向列表</li><li>插入数据时如果LFU容量已满，则找到HashMap_Freq频次最低的双向链表，删除链表头部，并插入新数据到链表尾部</li><li>查询数据时如果数据存在双向链表中，则该数据对应的节点需要移动到+1频次的双向链表尾部去（如频次1的数据查询后就放到频次2中）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis过期策略</title>
      <link href="/2023/08/16/redis/redis-guo-qi-ce-lue/"/>
      <url>/2023/08/16/redis/redis-guo-qi-ce-lue/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis过期策略有哪些？"><a href="#一、Redis过期策略有哪些？" class="headerlink" title="一、Redis过期策略有哪些？"></a>一、Redis过期策略有哪些？</h2><p>Redis有三种过期策略，分别为：</p><ul><li><strong>定时过期</strong>：指每个设置过期时间的key都会创建一个定时器，等到过期时间就会清除该key（可以节省内存，但会<font color="red">占用大量cpu资源，影响缓存的响应时间和吞吐量</font>）</li><li><strong>惰性过期</strong>：指每个设置过期时间的key不会自动过期，而是等到被动访问该key时才会判断是否过期来决定是否清除该key（可以节省cpu资源，但是会导致<font color="red">大量没被访问的过期key没被清除，从而占用大量内存</font>）</li><li><strong>定期过期</strong>：指redis会周期性地随机抽取一些设置了过期时间的key，通过判断来决定是否清除该key</li></ul><p>Redis默认同时开启<strong>惰性过期</strong>和<strong>定期过期</strong>这两种过期策略，以求在合理使用cpu和避免内存浪费之间取得平衡</p><h2 id="二、Redis是怎样进行定期删除的？"><a href="#二、Redis是怎样进行定期删除的？" class="headerlink" title="二、Redis是怎样进行定期删除的？"></a>二、Redis是怎样进行定期删除的？</h2><p>默认每个100ms扫描一次，每次随机抽取20个key</p><p>定期删除的过期策略的流程为：</p><ol><li>每100ms随机抽取20个key</li><li>检查这20个key是否过期，删除过期的key</li><li>检查过期数据占比，如果<code>过期数</code>/<code>抽取数</code>大于25%，则重复步骤1，反之则停止删除，等下一轮扫描</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何排查MySQL索引失效的问题？</title>
      <link href="/2023/08/15/mysql/ru-he-pai-cha-mysql-suo-yin-shi-xiao-de-wen-ti/"/>
      <url>/2023/08/15/mysql/ru-he-pai-cha-mysql-suo-yin-shi-xiao-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、索引失效分析"><a href="#一、索引失效分析" class="headerlink" title="一、索引失效分析"></a>一、索引失效分析</h2><p>MySQL索引失效是一个比较常见的问题，这种情况一般会在发生慢SQL时需要考虑是否存在索引失效的问题</p><p>一般MySQL索引失效的原因有：</p><ul><li><strong>索引列参与计算</strong>：如… where a + 1 = 2</li><li><strong>对索引列进行函数操作</strong>：如… where YEAR(a)=2023</li><li><strong>使用or</strong>：如… where a = 1 or b &lt; 2</li><li><strong>使用like</strong>：如… where a like ‘%xxx’</li><li><strong>隐式类型转换</strong>：如… where a = 1 //a是varchar类型</li><li><strong>使用!=或者</strong>&lt;&gt;：如… where a != 1</li><li><strong>使用is not null</strong>：如… where a is not null</li></ul><h2 id="二、索引失效原因"><a href="#二、索引失效原因" class="headerlink" title="二、索引失效原因"></a>二、索引失效原因</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> user_table <span class="token punctuation">(</span>    <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>age<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>age<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>age<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>create_time<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> <span class="token operator">=</span> utf8mb4<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1、索引列参与计算"><a href="#1、索引列参与计算" class="headerlink" title="1、索引列参与计算"></a>1、索引列参与计算</h3><p>可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">18</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> age <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2、对索引列进行函数操作"><a href="#2、对索引列进行函数操作" class="headerlink" title="2、对索引列进行函数操作"></a>2、对索引列进行函数操作</h3><p>可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> create_time <span class="token operator">=</span> <span class="token string">'2023-06-01 00:00:00'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>create_time<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2023</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、使用or"><a href="#3、使用or" class="headerlink" title="3、使用or"></a>3、使用or</h3><p>可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'gary'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span class="token comment">-- OR两边都是=时，索引不会失效</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'gary'</span> <span class="token operator">or</span> age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- OR两边存在&lt;或者&gt;时，索引会失效</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'gary'</span> <span class="token operator">or</span> age <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4、使用like"><a href="#4、使用like" class="headerlink" title="4、使用like"></a>4、使用like</h3><p>可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'gary%'</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'ga%ry'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%gary%'</span><span class="token punctuation">;</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%gary'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5、隐式类型转换"><a href="#5、隐式类型转换" class="headerlink" title="5、隐式类型转换"></a>5、隐式类型转换</h3><p>可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- age是int类型，条件查询用的是字符串，MySQL会将其转化为int类型，不会导致索引失效</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token string">"1"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 由于name是varchar类型，条件查询用的是int类型，会导致索引失效</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6、使用-或者-lt-gt"><a href="#6、使用-或者-lt-gt" class="headerlink" title="6、使用!=或者<>"></a>6、使用!=或者&lt;&gt;</h3><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> age <span class="token operator">!=</span> <span class="token number">18</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7、使用is-not-null"><a href="#7、使用is-not-null" class="headerlink" title="7、使用is not null"></a>7、使用is not null</h3><p>不可以走索引的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> user_table <span class="token keyword">where</span> name <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍一下Spring的AOP</title>
      <link href="/2023/08/13/spring/jie-shao-yi-xia-spring-de-aop/"/>
      <url>/2023/08/13/spring/jie-shao-yi-xia-spring-de-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是AOP？"><a href="#一、什么是AOP？" class="headerlink" title="一、什么是AOP？"></a>一、什么是AOP？</h2><p>AOP（Aspect-Oriented Programming），一般称为面向切面编程，用来将与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装成一个可重用的模块，这个模块就叫做<strong>切面</strong><br><strong>AOP的优点</strong>：</p><ul><li>减少系统中的重复代码</li><li>降低模块间的耦合度</li><li>提高系统的可维护性</li></ul><p><strong>AOP的场景</strong>：</p><ul><li>权限认证</li><li>日志处理</li><li>事务处理</li><li>…</li></ul><h2 id="二、Spring-AOP的一些名词"><a href="#二、Spring-AOP的一些名词" class="headerlink" title="二、Spring AOP的一些名词"></a>二、Spring AOP的一些名词</h2><ul><li><strong>切面（Aspect）</strong>：切面由切点和通知组成，在Spring AOP中切面就是切面类，如日志处理和事务处理就可以理解为两个切面</li><li><strong>连接点（JoinPoint）</strong>：指的是被增强的业务方法</li><li><strong>切点（PointCut）</strong>：决定通知应该作用于哪些方法（充当where角色，即在哪里做）</li><li><strong>通知（Advice）</strong>：指的是切面的具体行为（充当what角色，即做什么）</li><li><strong>目标对象（Target）</strong>：指的是增强的对象（目标对象）</li><li><strong>织入（Weaving）</strong>：指的是将切面和业务逻辑对象连接，并创建通知代理的过程（Spring AOP的织入方式为动态代理）</li></ul><h2 id="三、Spring有哪些通知类型？"><a href="#三、Spring有哪些通知类型？" class="headerlink" title="三、Spring有哪些通知类型？"></a>三、Spring有哪些通知类型？</h2><p>Spring有5种通知类型，分别为：</p><ul><li><strong>前置通知（Before）</strong>：在目标方法调用之前通知</li><li><strong>后置通知（After）</strong>：在目标方法完成之后通知（不关心是否出现异常）</li><li><strong>返回通知（After-returning）</strong>：在目标方法成功执行之后通知（不出现异常）</li><li><strong>异常通知（After-throwing）</strong>：在目标方法抛出异常后通知（出现异常）</li><li><strong>环绕通知（Around）</strong>：在目标方法调用之前和调用之后通知</li></ul><p>执行顺序：</p><ul><li><strong>正常</strong>：@Before -&gt; 方法 -&gt; @AfterReturning -&gt; @After</li><li><strong>异常</strong>：@Before -&gt; 方法 -&gt; @AfterThrowing -&gt; @After</li></ul><h2 id="四、Spring-AOP的流程"><a href="#四、Spring-AOP的流程" class="headerlink" title="四、Spring AOP的流程"></a>四、Spring AOP的流程</h2><p>//TODO</p><h2 id="五、Q-amp-A"><a href="#五、Q-amp-A" class="headerlink" title="五、Q&amp;A"></a>五、Q&amp;A</h2><h3 id="1、AOP和OOP有什么区别？"><a href="#1、AOP和OOP有什么区别？" class="headerlink" title="1、AOP和OOP有什么区别？"></a>1、AOP和OOP有什么区别？</h3><p>AOP和OOP是面向不同领域的两种设计思想，具体为：<br><strong>OOP（面向对象编程）</strong>：针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分<br><strong>AOP（面向切面编程）</strong>：作为OOP的一种补充，针对业务处理过程中的切面进行提取，以达到业务代码和公共代码之间低耦合性的隔离效果</p><h3 id="2、Spring-AOP和AspectJ-AOP有什么区别？"><a href="#2、Spring-AOP和AspectJ-AOP有什么区别？" class="headerlink" title="2、Spring AOP和AspectJ AOP有什么区别？"></a>2、Spring AOP和AspectJ AOP有什么区别？</h3><ul><li>Spring AOP基于动态代理来实现，致力于解决企业级开发中普遍的AOP需求（方法织入）。默认地，如果使用接口，用JDK提供的动态代理实现，如果没有接口，使用CGLib实现，</li><li>AspectJ AOP基于静态代理来实现，是AOP编程的完全解决方案</li></ul><h3 id="3、JDK动态代理和CGLib动态代理有什么区别？"><a href="#3、JDK动态代理和CGLib动态代理有什么区别？" class="headerlink" title="3、JDK动态代理和CGLib动态代理有什么区别？"></a>3、JDK动态代理和CGLib动态代理有什么区别？</h3><p><a href="https://garyleeeee.github.io/2023/08/12/java-dong-tai-dai-li/">Java动态代理</a></p><h3 id="4、什么情况下AOP会生效？"><a href="#4、什么情况下AOP会生效？" class="headerlink" title="4、什么情况下AOP会生效？"></a>4、什么情况下AOP会生效？</h3><ul><li>目标类没有配置为bean</li><li>方法用private修饰（需要改用public）</li><li>切点表达式配置错误</li><li>…<br>//TODO</li></ul><h3 id="5、Spring-AOP是在哪里进行动态代理的？"><a href="#5、Spring-AOP是在哪里进行动态代理的？" class="headerlink" title="5、Spring AOP是在哪里进行动态代理的？"></a>5、Spring AOP是在哪里进行动态代理的？</h3><p>正常的Bean会在Bean生命周期的初始化后，通过<code>BeanPostProcessor.postProcessAfterInitialization</code>创建AOP的动态代理<br>参考：<a href="https://garyleeeee.github.io/2023/08/01/spring/spring-ru-he-jie-jue-xun-huan-yi-lai-de-wen-ti/">Spring如何解决循环依赖的问题？</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理</title>
      <link href="/2023/08/12/java-dong-tai-dai-li/"/>
      <url>/2023/08/12/java-dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是代理？"><a href="#一、什么是代理？" class="headerlink" title="一、什么是代理？"></a>一、什么是代理？</h2><p><strong>代理</strong>是一种设计模式（代理模式），当我们要访问某个目标类的时候，不是直接访问目标类，而是通过访问代理类，然后代理类调用目标类来完成的，也就是<font color="red">直接调用变成间接调用</font></p><h3 id="1、代理的好处"><a href="#1、代理的好处" class="headerlink" title="1、代理的好处"></a>1、代理的好处</h3><ul><li><strong>解耦</strong></li><li><strong>方便扩展</strong>：不修改目标类逻辑的前提下，起到增强逻辑的作用</li></ul><h3 id="2、使用场景"><a href="#2、使用场景" class="headerlink" title="2、使用场景"></a>2、使用场景</h3><p>可以在代理类调用目标类之前和之后去添加一些预处理和后处理的操作，达到扩展一些不属于目标类功能的目的，比如：</p><ul><li>可以在方法开始和结束前打印日志，如<code>Logger.info("method before")</code></li><li>可以在方法执行前进行参数校验，如<code>Assert.notNull(req)</code></li><li>可以在方法执行前进行权限校验，如<code>checkUserAuth()</code></li><li>…</li></ul><h3 id="3、代理的类型"><a href="#3、代理的类型" class="headerlink" title="3、代理的类型"></a>3、代理的类型</h3><p><strong>代理</strong>分为：<br><strong>静态代理</strong>：在程序运行前，就已经给目标类编写了代理类的代码（提前编译了代理类并生成对应的字节码）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"汪"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">StaticProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Animal</span> animal<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">StaticProxy</span><span class="token punctuation">(</span><span class="token class-name">Animal</span> animal<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>animal <span class="token operator">=</span> animal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        animal<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testStaticProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 正常情况下</span>        <span class="token class-name">Animal</span> dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dog<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 静态代理下</span>        <span class="token class-name">StaticProxy</span> staticProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticProxy</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>        staticProxy<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>JDK Proxy动态代理</strong>：不需要提前创建代理类，而是通过反射自动生成代理对象（在Java中只需要实现InvocationHandler接口，然后实现invoke()方法即可）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">DynamicProxy</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> targetObj<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> invoke <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>targetObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// 创建代理对象实例</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token class-name">Object</span> targetObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>targetObj <span class="token operator">=</span> targetObj<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>targetObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment">// 目标类加载器</span>                targetObj<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                           <span class="token comment">// 目标类接口</span>                <span class="token keyword">this</span>                                                            <span class="token comment">// 代理处理类</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> dynamicProxyList <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">DynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dynamicProxyList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dynamicProxyList<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CGLib动态代理</strong>：不需要提前创建代理类，只需要实现MethodInterceptor接口，然后实现intercept()方法即可）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">CglibProxy</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> target<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">CglibProxy</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *      * @param obj       代理类（子类）     * @param method    调用的方法     * @param args      入参     * @param proxy     MethodProxy代理对象     * @return     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method before"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method after"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCglibDynamicProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 实例化增强器</span>        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置需要代理的目标类</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperClass</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 设置拦截对象回调的实现类</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CglibProxy</span><span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 调用create()方法生成代理类</span>        <span class="token class-name">Dog</span> dog <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dog<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、为什么要用动态代理？"><a href="#二、为什么要用动态代理？" class="headerlink" title="二、为什么要用动态代理？"></a>二、为什么要用动态代理？</h2><p><strong>静态代理</strong>的缺点：</p><ul><li>需要提前创建，一个目标类就要对应有一个代理类，造成代码冗余</li><li>同一个代理类下需要实现接口的所有方法，编码效率低下</li></ul><p><strong>动态代理</strong>的优点：</p><ul><li>减少代理对象个数，降低程序复杂度</li><li>方便动态扩展</li></ul><h2 id="三、动态代理的基本实现（JDK-Proxy）"><a href="#三、动态代理的基本实现（JDK-Proxy）" class="headerlink" title="三、动态代理的基本实现（JDK Proxy）"></a>三、动态代理的基本实现（JDK Proxy）</h2><p>动态代理的基本实现为：</p><ol><li>拿到目标类的引用，通过反射获取它所有的接口</li><li>通过JDK Proxy类重新生成一个新的类，实现了目标类所有接口的方法</li><li>动态生成Java代码，把增强逻辑加入到新生成代码中</li><li>动态编译新生成Java代码的class文件</li><li>加载并重新运行新的class，得到全新类</li></ol><h2 id="四、JDK-Proxy和CBLib的区别？"><a href="#四、JDK-Proxy和CBLib的区别？" class="headerlink" title="四、JDK Proxy和CBLib的区别？"></a>四、JDK Proxy和CBLib的区别？</h2><p><strong>实现方式</strong>：JDK Proxy是实现了目标类的接口，CGLib底层是继承了目标类（所以如果目标类被final修饰，那么它是无法使用CBLib做动态代理的）<br><strong>生成字节码</strong>：JDK Proxy和CGLib都是在运行时生成字节码<br><strong>调用方式</strong>：JDK Proxy是通过反射机制调用，CGLib是通过FastClass机制调用（子类调用父类）<br><strong>class文件</strong>：JDK Proxy只会生成一个class文件，CGLib会生成多个class文件（代理类+代理类对应的fastclass文件+目标类对应的fastclass文件）<br><strong>性能</strong>：JDK1.8之前CGLib性能更好，因为JDK1.8之前JDK Proxy要通过JDK内部反射逻辑去找到目标类，而JDK1.8之后对反射性能做了优化（跟CGLib差不多）<br><strong>目标类调用本类方法处理</strong>：JDK Proxy目标类调用本类方法，只会代理一次（<font color="red">所以会导致AOP失效</font>），而CGLib由于是继承了代理类，通过invokeSuper()方法调用父类方法，在目标类中调用本类方法会再一次代理（如果只需要代理一次可以用invoke()方法）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//CGLib动态代理会执行子类method2()方法，因为method1()也是子类触发调用的</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><h3 id="1、如何查看动态代理生成出来的代理类文件？"><a href="#1、如何查看动态代理生成出来的代理类文件？" class="headerlink" title="1、如何查看动态代理生成出来的代理类文件？"></a>1、如何查看动态代理生成出来的代理类文件？</h3><p>如果用的是JDK Proxy，可以通过设置环境变量<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>为<code>true</code>，会自动生成一个<code>$Proxy</code>代理类文件到根目录里</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用的是CGLib，可以通过设置环境变量<code>DebuggingClassWriter.DEBUG_LOCATION_PROPERTY</code>为<code>./</code>，会自动生成多个<code>xx$$EnhancerByCGLIB%%xx</code>代理类文件到根目录里</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token class-name">DebuggingClassWriter</span><span class="token punctuation">.</span>DEBUG_LOCATION_PROPERTY<span class="token punctuation">,</span> <span class="token string">"./"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、如何选择用JDK-Proxy还是CGLib？"><a href="#2、如何选择用JDK-Proxy还是CGLib？" class="headerlink" title="2、如何选择用JDK Proxy还是CGLib？"></a>2、如何选择用JDK Proxy还是CGLib？</h3><p>如果目标类实现了接口，则用JDK Proxy（使用Spring AOP会自动选择更优的，SprintBoot 2.x的AOP默认使用的是CGLib）</p><p>//TODO：代理流程图</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2023/08/08/redis/redis-ji-qun/"/>
      <url>/2023/08/08/redis/redis-ji-qun/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis集群有哪几种实现方式？"><a href="#一、Redis集群有哪几种实现方式？" class="headerlink" title="一、Redis集群有哪几种实现方式？"></a>一、Redis集群有哪几种实现方式？</h2><p><strong>Redis集群</strong>有三种实现方式：</p><ul><li>主从复制</li><li>哨兵模式</li><li>Redis Cluster集群</li></ul><h3 id="1、主从复制"><a href="#1、主从复制" class="headerlink" title="1、主从复制"></a>1、主从复制</h3><p><strong>优点</strong>：</p><ul><li>读写分离：master节点负责读写，slave节点负责读</li><li>slave节点能够分担master节点的读操作压力</li></ul><p><strong>缺点</strong>：</p><ul><li>不具备容错和恢复能力（需要等机器重启或手动切换master节点才能恢复）</li><li>一旦master节点挂了，不会自动切换新的master节点，导致后续的写请求都失败</li><li>存在在线扩容问题</li><li>所有slave节点的复制和同步都由master节点来处理，会增加master节点压力</li></ul><h3 id="2、哨兵模式（Sentinel）"><a href="#2、哨兵模式（Sentinel）" class="headerlink" title="2、哨兵模式（Sentinel）"></a>2、哨兵模式（Sentinel）</h3><p><strong>特点</strong>：</p><ul><li>一主多从</li><li>主从复制：所有节点存的是相同数据</li><li>适合读多于写场景</li></ul><p><strong>优点</strong>：</p><ul><li>读写分离：master节点负责读写，slave节点负责读</li><li>slave节点能够分担master节点的读操作压力</li><li>一旦master节点挂了，会从剩下的slave节点选举出新的master节点</li><li>具备容错和恢复能力</li></ul><p><strong>缺点</strong>：</p><ul><li>存在在线扩容问题</li></ul><h3 id="3、Redis-Cluster"><a href="#3、Redis-Cluster" class="headerlink" title="3、Redis Cluster"></a>3、Redis Cluster</h3><p><strong>特点</strong>：</p><ul><li>实现了redis的分布式存储，每个节点存储不同的数据，实现数据的分片功能（Slot槽）</li><li>多主多从</li></ul><p><strong>优点</strong>：</p><ul><li>一旦master节点挂了，会从剩下的slave节点选举出新的master节点</li><li>解决了在线扩容问题</li><li>具备故障转移能力</li></ul><p><strong>缺点</strong>：</p><ul><li>Slave节点只是实现冷备机制，不能分担redis读操作压力（只有在master宕机之后才会工作）</li><li>客户端实现更复杂</li></ul><h2 id="二、哨兵模式"><a href="#二、哨兵模式" class="headerlink" title="二、哨兵模式"></a>二、哨兵模式</h2><p><strong>哨兵模式</strong>由一个或多个sentinel实例组成sentinel集群，可以监视一个或多个主服务器和多个从服务器。适合读请求多于写请求的业务场景，比如在秒杀系统中缓存活动信息。如果写请求较多，当集群Slave节点多了，Master节点同步数据的压力会非常大</p><p><strong>检测主观下线状态</strong><br>Sentinel每秒一次向所有与它建立了命令连接的实例（主服务器、从服务器和其他Sentinel）发送PING命令，实例在<code>down-after-milliseconds</code>毫秒内返回无效回复，Sentinel就会认为该实例主观下线（SDown）</p><p><strong>检查客观下线状态</strong><br>当一个Sentinel将一个主服务器判断为主观下线后，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令，如果达到Sentinel配置中的数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线（ODown）</p><p><strong>选举Leader Sentinel</strong><br>当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法（raft），选出一个Leader Sentinel去执行failover（故障转移）操作</p><h2 id="三、Redis哨兵模式和Redis-Cluster有什么区别？"><a href="#三、Redis哨兵模式和Redis-Cluster有什么区别？" class="headerlink" title="三、Redis哨兵模式和Redis Cluster有什么区别？"></a>三、Redis哨兵模式和Redis Cluster有什么区别？</h2><p><strong>读写</strong>：</p><ul><li>哨兵模式通过主从复制，实现读写分离，分担redis读操作压力</li><li>Redis Cluster的Slave节点只是实现冷备机制，并不分担redis读操作压力（只有在master宕机之后才会工作）</li></ul><p><strong>在线扩容</strong>：</p><ul><li>哨兵模式无法在线扩容，并发压力受限于单个服务器资源的配置</li><li>Redis Cluster提供了Slot槽的数据分片机制，可以实现在线扩容</li></ul><p><strong>集群架构</strong>：</p><ul><li>哨兵模式是一主多从</li><li>Redis Cluster是多主多从</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制</title>
      <link href="/2023/08/04/java-lei-jia-zai-ji-zhi/"/>
      <url>/2023/08/04/java-lei-jia-zai-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h2 id="二、Java中有哪些类加载器？"><a href="#二、Java中有哪些类加载器？" class="headerlink" title="二、Java中有哪些类加载器？"></a>二、Java中有哪些类加载器？</h2><p>JDK有三个<strong>类加载器</strong>，分别为：</p><ul><li><strong>启动类加载器（BootStrapClassLoader）</strong>：负责加载Java运行时环境核心类库（即<code>%JAVA_HOME%/lib</code>下的jar包和class类），是<code>ExtClassLoader</code>的父类加载器，</li><li><strong>扩展类加载器（ExtClassLoader）</strong>：负责加载Java运行时环境扩展类库（即<code>%JAVA_HOME%/lib/ext</code>下的jar包和class类），是<code>AppClassLoader</code>的父类加载器</li><li><strong>应用类加载器（AppClassLoader）</strong>：负责加载classpath下的类文件，是自定义类加载器的父类加载器</li></ul><h2 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h2><p><strong>类加载过程</strong>其实就是把class文件装载到JVM内存中得到一个Class对象，然后我们就可以通过new关键字来实例化这个对象，主要有加载、验证、准备、解析、初始化这几个阶段<br><img src="/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"><br><strong>加载阶段</strong>：</p><ol><li>根据类的全限定名来查找并读取类的二进制字节流</li><li>将这个字节流转换为内部数据结构（即方法区的运行时数据结构）</li><li>在JVM堆中创建一个Class对象代表这个类（作为方法区这些数据的访问入口）<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">CLass</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.test.TestClass"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>验证阶段</strong>：</p><ol><li>文件格式验证：是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</li><li>元数据验证：是否符合Java语言规范要求</li><li>字节码验证：保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</li><li>符号引用验证：对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行</li></ol><p><strong>准备阶段</strong>：为类变量（静态变量）分配内存空间，并设置默认初始值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> testStaticVariable<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>解析阶段</strong>：</p><ul><li>目的：将符号引用解析为直接引用</li><li>符号引用：用来引用类、字段、方法等</li><li>直接引用：用来直接指向内存中的数据结构的指针或偏移量<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 静态方法的解析</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>初始化阶段</strong>：类加载过程的最后一步，也是类被真正使用之前的最后准备工作。主要是对类的静态变量进行赋值和静态代码块的执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> testStaticVariable <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment">// do sth</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、双亲委派机制"><a href="#四、双亲委派机制" class="headerlink" title="四、双亲委派机制"></a>四、双亲委派机制</h2><p><img src="/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><ul><li>每一个类都有一个对应它的类加载器，系统中的类加载器在协同工作的时候会默认使用<strong>双亲委派模型</strong></li><li>类加载的时候，系统会先判断该类是否被加载过<ul><li>如果被加载过，会直接返回</li><li>如果没被加载过，会尝试加载</li></ul></li><li>加载流程：<ol><li>首先会把请求委派给父类加载器的loadClass()处理，因此所有的请求最终都会委派给最顶层的<code>BootstrapClassLoader</code></li><li>然后如果父类加载器无法处理时，就会交回自己来处理，如果能处理则直接加载完返回</li></ol></li><li>如果父类加载器为<code>null</code>时，会使用<code>BootstrapClassLoader</code>作为父类加载器</li></ul><h3 id="2、使用双亲委派机制的好处"><a href="#2、使用双亲委派机制的好处" class="headerlink" title="2、使用双亲委派机制的好处"></a>2、使用双亲委派机制的好处</h3><p>使用<strong>双亲委派机制</strong>的好处为：</p><ul><li>保证JDK核心类的优先加载</li><li>避免类的重复加载</li><li>保证Java的核心API不被篡改</li></ul><p>如果不用<strong>双亲委派模型</strong>，而是每个类加载器加载的话就会出现一些问题，比如我们编写一个java.lang.Object类时，那么程序运行的时候，系统就会出现多个不同的Object类</p><h3 id="3、破坏双亲委派模型"><a href="#3、破坏双亲委派模型" class="headerlink" title="3、破坏双亲委派模型"></a>3、破坏双亲委派模型</h3><p><strong>破坏双亲委派模型</strong>的方式有：</p><ul><li><strong>自定义类加载器</strong>：继承ClassLoader抽象类，重写loadClass方法（可以自定义要加载的类使用的类加载器）</li><li><strong>使用线程上下文加载器</strong>：可以通过<code>java.lang.Thread</code>类的setContextClassLoader()方法来设置当前</li></ul><h3 id="4、为什么要破坏双亲委派模型？"><a href="#4、为什么要破坏双亲委派模型？" class="headerlink" title="4、为什么要破坏双亲委派模型？"></a>4、为什么要破坏双亲委派模型？</h3><p><strong>为什么要破坏双亲委派模型？</strong>：由于加载范围的限制，顶层的ClassLoader无法访问底层ClassLoader所加载的类，此时就需要破坏双亲委派模型</p><blockquote><p>以JDBC为例，讲一下为什么要破坏双亲委派模型</p></blockquote><h4 id="a、JDBC不使用Java-SPI"><a href="#a、JDBC不使用Java-SPI" class="headerlink" title="a、JDBC不使用Java SPI"></a>a、JDBC不使用Java SPI</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestSqlClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 加载驱动类</span>        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbd.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获取数据库连接</span>        <span class="token class-name">Conncetion</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnect</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://xxx"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="b、JDBC使用Java-SPI"><a href="#b、JDBC使用Java-SPI" class="headerlink" title="b、JDBC使用Java SPI"></a>b、JDBC使用Java SPI</h4><p>在JDBC4.0之后，开始支持使用SPI的方式来注册Driver，具体做法是在MySQL的jar里的<code>META-INF/services/java.sql.Driver</code>文件中指定当前使用的Driver是哪个<br><strong>什么是SPI？</strong>：SPI就是策略模式，根据配置来决定运行时接口的实现类是哪个<br><img src="/images/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BDJDBC.png"><br>用这种方式的话，当使用不同的驱动时，我们不需要手动通过Class.forName加载驱动类，而是引入对应的jar包即可，所以上面的代码可以改成如下形式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestSqlClass</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnect</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:/xxx"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">,</span> <span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对应的驱动类是如何加载的？</p></blockquote><ul><li>从META-INF/services/java.sql.Driver文件中获取具体的实现类<code>com.mysql.jdbd</code></li><li>通过<code>Class.forName("com.mysql.jdbc.Driver")</code>将这个类加载进来</li></ul><blockquote><p>存在什么问题呢？</p></blockquote><ul><li><code>DriberManager</code>位于rt.jar包中，所以是通过<code>BootStrapClassLoader</code>加载的</li><li>而<code>Class.forName()</code>加载用的是调用者的ClassLoader<br>如果用<code>BootStrapClassLoader</code>去加载<code>com.mysql.jdbc.Driver</code>，是肯定加载不到的（<font color="red">因为一般情况下启动类加载器只加载rt.jar包中的类</font>）</li></ul><blockquote><p>如何解决这个问题呢？</p></blockquote><p>想让顶层的ClassLoader加载底层的ClassLoader，只能<strong>破坏双亲委派机制</strong><br>DriverManager在加载时，会先执行静态代码块，在静态代码块中，会执行loadInitialDrivers()方法，这个方法会加载对应的驱动类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DriverManager</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"JDBC DriverManager initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">// ...</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//...</span>        <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 根据配置文件加载驱动实现类</span>                <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Driver</span><span class="token punctuation">&gt;</span></span> loadedDrivers <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Driver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Driver</span><span class="token punctuation">&gt;</span></span> driversIterator <span class="token operator">=</span> loadedDrivers<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">try</span> <span class="token punctuation">{</span>                  <span class="token keyword">while</span> <span class="token punctuation">(</span>driversIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      driversIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//Do nothing</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.initialize: jdbc.drivers = "</span> <span class="token operator">+</span> drivers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>进入ServiceLoader的load()方法，可以看到通过执行<code>Thread.currentThread().getContextClassLoader()</code>获取了线程上下文加载器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">S</span><span class="token punctuation">&gt;</span></span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ClassLoader</span> cl <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>线程上下文类加载器可以通过<code>Thread.setContextClassLoader()</code>方法设置（默认是<code>AppClassLoader</code>，通过Launcher类创建，ExtClassLoader同理）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Launcher</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>    <span class="token keyword">public</span> <span class="token class-name">Launcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Launcher<span class="token punctuation">.</span>ExtClassLoader</span> var1<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            var1 <span class="token operator">=</span> <span class="token class-name">Launcher<span class="token punctuation">.</span>ExtClassLoader</span><span class="token punctuation">.</span><span class="token function">getExtClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var10<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span><span class="token string">"Could not create extension class loader"</span><span class="token punctuation">,</span> var10<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>loader <span class="token operator">=</span> <span class="token class-name">Launcher<span class="token punctuation">.</span>AppClassLoader</span><span class="token punctuation">.</span><span class="token function">getAppClassLoader</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var9<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span><span class="token string">"Could not create application class loader"</span><span class="token punctuation">,</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment">// 设置上下文类加载器为AppClassLoader</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setContextClassLoader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，线程上下文类加载器让父类加载器能通过调用子类加载器来加载类，达到<font color="red">打破双亲委派模型</font>的目的</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 双亲委派模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring如何解决循环依赖的问题？</title>
      <link href="/2023/08/01/spring/spring-ru-he-jie-jue-xun-huan-yi-lai-de-wen-ti/"/>
      <url>/2023/08/01/spring/spring-ru-he-jie-jue-xun-huan-yi-lai-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是循环依赖？"><a href="#一、什么是循环依赖？" class="headerlink" title="一、什么是循环依赖？"></a>一、什么是循环依赖？</h2><p><strong>循环依赖</strong>其实就是两个对象互相依赖，包括直接和间接，比如</p><ul><li><strong>直接</strong>：A依赖B，B依赖A</li><li><strong>间接</strong>：A依赖B，B依赖C，C依赖A<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// A依赖B</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// B依赖A</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在Spring中，一个对象经过一系列的<strong>Bean的生命周期</strong>，就会出现<strong>循环依赖</strong>问题</li></ul><h2 id="二、Bean的生命周期（简易版）"><a href="#二、Bean的生命周期（简易版）" class="headerlink" title="二、Bean的生命周期（简易版）"></a>二、Bean的生命周期（<strong>简易版</strong>）</h2><p>Bean就是被Spring管理的对象，生成步骤如下：</p><ol><li><strong>生成bean</strong>：执行getBean()，根据BeanDefinition生成bean</li><li><strong>实例化</strong>：根据其构造方法（默认是无参）反射创建一个对象</li><li><strong>填充属性</strong>：也就是<strong>依赖注入</strong></li><li><strong>AOP</strong>：如果该对象某个方法被AOP了，那么就要基于该对象生成一个代理对象</li><li><strong>放入单例池</strong>：也叫做一级缓存（singletonObjects），后续getBean直接从单例池取即可</li></ol><h2 id="三、为什么会出现循环依赖？"><a href="#三、为什么会出现循环依赖？" class="headerlink" title="三、为什么会出现循环依赖？"></a>三、为什么会出现循环依赖？</h2><p><strong>一般情况</strong>：</p><ol><li>A创建了一个原始对象（类似new）</li><li>给属性b赋值，根据B的类型和属性名去BeanFactory获取B类对应的单例bean 、<br>2.1 如果存在B类对应的单例bean， 则直接赋值给b<br>2.2 如果不存在B类对应的单例bean，则先创建该bean，再赋值给b</li><li>…<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>特殊情况（循环依赖）</strong>：如果A在填充b属性的时候，要去创建B对象，但是B又需要填充a属性，此时A还在创建中，导致A和B都创建不了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而在Spring中，使用了<strong>三级缓存</strong>来解决<strong>循环依赖</strong>的问题</p><h2 id="四、三级缓存"><a href="#四、三级缓存" class="headerlink" title="四、三级缓存"></a>四、三级缓存</h2><p><strong>三级缓存</strong>分别为：</p><ul><li><strong>一级缓存</strong>：即源码中的singletonObjects，也叫做单例池。存放的对象是<font color="red">完成了完整生命周期的bean对象</font></li><li><strong>二级缓存</strong>：即源码中的earlySingletonObjects。存放的对象是<font color="red">早期的bean对象，即没完成完整生命周期的bean对象</font></li><li><strong>三级缓存</strong>：即源码中的singletonFactories，也叫做对象工厂。存放的对象是<font color="red">创建对象的lambda表达式</font>，用来创建某个对象的</li></ul><h3 id="1、一级缓存（单例池）"><a href="#1、一级缓存（单例池）" class="headerlink" title="1、一级缓存（单例池）"></a>1、一级缓存（单例池）</h3><p><strong>什么时候使用一级缓存？</strong>：当一个bean完成了完整生命周期，就会放进<strong>一级缓存</strong>，但下次该bean被其他bean依赖注入时，直接从<strong>一级缓存</strong>取出赋值即可<br><strong>问题</strong>：如果两个/多个bean相互依赖，那么在依赖注入时，由于分别都没完成完整生命周期，所以<strong>一级缓存</strong>里找不到对应的bean，导致出现死循环<br><img src="/images/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="spring循环依赖"></p><h3 id="2、二级缓存（早期bean对象）"><a href="#2、二级缓存（早期bean对象）" class="headerlink" title="2、二级缓存（早期bean对象）"></a>2、二级缓存（早期bean对象）</h3><p><strong>背景</strong>：为了解决循环依赖，我们引入了<strong>二级缓存</strong>，允许一个bean创建后（依赖注入前）<font color="red">提前暴露</font>到缓存中，当该bean被其他bean依赖注入时，先从<strong>一级缓存</strong>找，找不到再从<strong>二级缓存</strong>找，这时候就能取到其原始对象并赋值即可<br><strong>问题</strong>：由于从<strong>二级缓存</strong>取出的对象是<font color="red">提前暴露的原始对象</font>，并不是最终的bean。这时候如果该原始对象进行了AOP产生了一个代理对象，这时候就会出现冲突<br><img src="/images/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt="spring循环依赖二级花奴才能"><br>如果所示，A生成了一个原始对象，B依赖注入A时赋值了该原始对象，而A如果在进入单例池前进行了AOP（BeanPostProcessor），那么就会出现矛盾：</p><ul><li>对于A而言：A的bean是AOP后的代理对象</li><li>对于B而言，B依赖注入的A是原始对象，而不是AOP后的代理对象</li></ul><p>所以这时候，经过了Spring的BeanPostProcessor对bean的加工，<strong>B依赖的A和最终的A不是同一个对象</strong>，我们可以通过一段代码证明一下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanPostProcessor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>        <span class="token comment">// 打印前面的值</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>beanName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 这里生成了一个新的对象</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">AnnotationConfigApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>XXX<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">A</span> a <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印后面的值</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行main方法，得到打印如下：</p><pre class="line-numbers language-none"><code class="language-none">com.test.service.A@4b0393b9com.test.service.A@2e052e20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以，BeanPostProcessor中可以完全替换掉某个beanName对应的bean对象：</p><ul><li>循环依赖注入的对象是发生在填充属性过程中的</li><li>BeanPostProcessor的执行是发生在填充属性过程之后的</li></ul><p><font>这种情况下的<strong>循环依赖</strong>，Spring是解决不了的，因为在填充属性时，Spring也不知道该对象后续会经过哪些BeanPostProcessor以及会对A对象做什么处理</font><br>虽然这种情况可能发生，但是肯定发生得很少，我们一般在开发中不会这样做。但是，有种情况，某个beanName对应的最终对象和原始对象不是同一个对象却经常出现，这就是<strong>AOP</strong></p><h3 id="3、AOP"><a href="#3、AOP" class="headerlink" title="3、AOP"></a>3、AOP</h3><p><strong>AOP</strong>是通过一个BeanPostProcessor来实现，也就是<code>AnnotationAwareAspectJAutoProxyCreator</code>，它继承了<code>AbstractAutoProxy</code><br>在Spring中AOP利用的要么是JDK动态代理，要么是CGLib的动态代理，所以<font color="red">如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象</font></p><p>（上面有提到）Spring中AOP的一般流程：生成bean-&gt;实例化-&gt;填充属性-&gt;AOP-&gt;放入单例池</p><p>而要解决AOP导致的前后对象不一致的问题，就需要引入<strong>三级缓存</strong></p><h3 id="4、三级缓存（对象工厂）"><a href="#4、三级缓存（对象工厂）" class="headerlink" title="4、三级缓存（对象工厂）"></a>4、三级缓存（对象工厂）</h3><p><strong>三级缓存</strong>对应源码的<code>singletonFactories</code>，在bean生成完原始对象后，会构造一个ObjectFactory存入<code>singletonFactories</code><br><code>ObjectFactory</code>是一个函数式接口，所以支持lambda表达式：<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code></p><p>//TODO</p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li>bean工厂：ObjectFactoru</li><li>bean仓库/单例池：SingletonBeanRegistry</li></ul><p>bean创建步骤：</p><ul><li>执行getBean</li><li>实例化：createBeanInstance，用构造方法</li><li>填充属性：populateBean</li><li>初始化：执行initializeBean</li></ul><p>a依赖b的话：</p><ul><li>执行getBean(“a”)</li><li>实例化：createBeanInstance(“a”)   //放在半成品池</li><li>填充属性：populateBean(“a”)<ul><li>执行getBean(“b”)</li><li>实例化：createBeanInstance(“b”)</li><li>填充属性：populateBean(“b”)</li><li>初始化：执行initializeBean(“b”)</li></ul></li><li>初始化：执行initializeBean(“a”)     //放在单例池</li></ul><p>后面还有工厂池</p><p>一级缓存：singletonObjects，用于保存实例化、注入、初始化完成的bean实例<br>二级缓存：earlySingletonObject，用于保存实例化完成的bean实例<br>三级缓存：singletonFactories，用于保存bean创建工厂，便于后续创建代理对象</p><p>场景：<br>A依赖A<br>A依赖B，B依赖A<br>A依赖B，B依赖C，C依赖A</p><p>顺序加载，如TestService1会先比TestService2加载</p><p>上课笔记：</p><ul><li>@Autowired的reequired为true，说明一定要赋值，不能为null</li><li>赋值给@Autowired对象的是service的普通对象还是代理对象？  其实是代理对象</li><li>三级缓存存的lambda表达式，判断是否要aop，如果不要就返回普通对象，如果要就返回代理对象</li><li>为什么会有提前aop和后续aop？</li><li>用构造方法去创建对象，如果自定义了构造方法，那么默认的无参构造方法就不生效了，如果这个自定义的有参构造方法包含了循环依赖的service类，那么就会报错，因为生成不了普通对象。加@Lazy可解决</li></ul><p>为什么@Lazy可以？</p><ul><li>生成形参的代理对象：比如public AService(BService bService)，则自动生成bService代理对象</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 循环依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个点赞功能？</title>
      <link href="/2023/07/31/ru-he-shi-xian-yi-ge-dian-zan-gong-neng/"/>
      <url>/2023/07/31/ru-he-shi-xian-yi-ge-dian-zan-gong-neng/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>点赞</strong>一般出现在朋友圈、微博、动态等场景，基本操作有点赞、取消点赞、查询点赞数量、判断自己是否点过赞等</p><h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><p>使用Redis的set结构简单实现，key存储帖子id，value存储点赞用户的uid<br><strong>点赞</strong>：<code>sadd &lt;key&gt; &lt;uid&gt;</code><br><strong>取消点赞</strong>：<code>srem &lt;key&gt; &lt;uid&gt;</code><br><strong>查询点赞用户列表</strong>：<code>smembers &lt;key&gt;</code><br><strong>查询点赞数量</strong>：<code>scard &lt;key&gt;</code><br><strong>判断自己是否点过赞</strong>：<code>sismember &lt;key&gt; &lt;uid&gt;</code></p><h2 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h2><h3 id="1、用Redis存储数据的话，如果丢数据了怎么办，需要配合MySQL持久化数据吗？"><a href="#1、用Redis存储数据的话，如果丢数据了怎么办，需要配合MySQL持久化数据吗？" class="headerlink" title="1、用Redis存储数据的话，如果丢数据了怎么办，需要配合MySQL持久化数据吗？"></a>1、用Redis存储数据的话，如果丢数据了怎么办，需要配合MySQL持久化数据吗？</h3><ul><li>Redis不单单是作为缓存使用，也可以持久化使用。它提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）</li><li>并且如果我们要用MySQL持久化数据的话，还要考虑性能、数据一致性等问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 场景题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优化大量if-else代码结构？</title>
      <link href="/2023/07/31/ru-he-you-hua-da-liang-if-else-dai-ma-jie-gou/"/>
      <url>/2023/07/31/ru-he-you-hua-da-liang-if-else-dai-ma-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="一、提前return"><a href="#一、提前return" class="headerlink" title="一、提前return"></a>一、提前return</h2><p><strong>适用场景</strong>：if-else代码结构包含return语句<br><strong>优点</strong>：优化代码阅读体验，如果if处理逻辑复杂不用拉到底才知道else是return逻辑<br><strong>例子代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">优化前：if(condition) {    // do sth} else {    return;}优化后：if(!condition) {    return;}// do sth<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、使用三目运算符"><a href="#二、使用三目运算符" class="headerlink" title="二、使用三目运算符"></a>二、使用三目运算符</h2><p><strong>适用场景</strong>：if-else条件都是为某个变量赋值<br><strong>优点</strong>：使代码更加简洁<br><strong>例子代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">优化前：int price;if(condition) {    price = 10;  } else {    price = 20;}优化后：int price = condition ? 10 : 20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、使用枚举"><a href="#三、使用枚举" class="headerlink" title="三、使用枚举"></a>三、使用枚举</h2><p><strong>适用场景</strong>：condition的判断维度一致，且if-else逻辑都是为某个变量赋值<br><strong>优点</strong>：方便扩展<br><strong>例子代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">优化前：int status;String remark;if(status == 0) {    remark = "正常";} else if (status == 1) {    remark = "已隐藏";} else if (status == 2) {    remark = "已删除";}优化后：@AllArgsConstructor@Getterpublic enum StatusEnum {    COMMON(0,"正常"),    HIDDEN(1,"已隐藏"),    DELETED(2,"已删除");        private int status;    private String remark;        public static String getRemarkByStatus(int status) {        for(StatusEnum statusEnum : StatusEnum.values()) {            if(status == statusEnum.getStatus()) {                return statusEnum;            }        }                return null;    }}int status;String remark = StatusEnum.getRemarkByStatus(status);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、合并条件表达式"><a href="#四、合并条件表达式" class="headerlink" title="四、合并条件表达式"></a>四、合并条件表达式</h2><p><strong>适用场景</strong>：多个if-else对应一样的逻辑处理<br><strong>例子代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">优化前：if(age &lt; 0) {    return -1;}if(id &lt; 0) {    return -1;}if(StringUtils.isBlank(name)) {    return -1;}优化后：if(age &lt; 0 || id &lt; 0 || StringUtils.isBlank(name)) {    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、策略模式-工厂模式"><a href="#五、策略模式-工厂模式" class="headerlink" title="五、策略模式+工厂模式"></a>五、策略模式+工厂模式</h2><p><strong>使用场景</strong>：每个if-else逻辑处理比较复杂，放在一个方法里会不好维护<br><strong>优点</strong>：基于接口编程，可读性好，方便维护扩展<br><strong>例子代码</strong>：</p><pre class="line-numbers language-none"><code class="language-none">优化前：int type;if(type == 1) {    // do sth1} else if (type == 2) {    // do sth2}优化后：@Servicepublic class TestFactory implements InitializingBean {    @Autowired    private List&lt;TestStrategy&gt; strategies;    private Map&lt;Integer, TestStrategy&gt; strategyMap = new HashMap&lt;&gt;();        @Override    public void afterPropertiesSet() throws Exception {        for(TestStrategy testStrategy : strategies) {            strategyMap.put(testStrategy.getType(), testStrategy);         }    }        public TestStrategy getTestStrategy(int type) {        return strategyMap.get(type);    }}public interface TestStrategy {    // 获取类型    int getType();    // 执行    void execute();}@Serivcepublic class TestStrategyImpl1 implements TestStrategy {    @Override    public int getType() {        return 1;     }        @Override    public void execute() {        //do sth    }}@Serivcepublic class TestStrategyImpl2 implements TestStrategy {    @Override    public int getType() {        return 2;     }        @Override    public void execute() {        //do sth    }}int type;TestFactory.getTestStrategy(type).execute();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码优化 </tag>
            
            <tag> 策略模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何排查CPU飙升问题？</title>
      <link href="/2023/07/29/ru-he-pai-cha-cpu-biao-sheng-wen-ti/"/>
      <url>/2023/07/29/ru-he-pai-cha-cpu-biao-sheng-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CPU飙升可能的原因"><a href="#一、CPU飙升可能的原因" class="headerlink" title="一、CPU飙升可能的原因"></a>一、CPU飙升可能的原因</h2><p><strong>背景</strong>：CPU是整个电脑的核心计算资源，对于一个应用进程来说，CPU的最小执行单元是线程<br>导致CPU飙高的原因有几个方面：</p><ul><li><strong>CPU上下文切换过多</strong>：由于在同一时刻下每个CPU核心只能运行一个线程，如果存在多个线程，CPU就只能通过上下文切换（上下文切换=保存运行线程的执行状态+执行处于等待中的线程）来执行不同的线程。<font color="red">在Java中，文件IO、网络IO、锁等待、线程阻塞等操作都会造成线程阻塞从而触发上下文切换</font></li><li><strong>CPU资源过度消耗</strong>：也就是在程序中创建了大量的线程，或者有线程一直占用CPU资源无法被释放。<font color="red">比如死循环</font></li></ul><h2 id="二、排查步骤"><a href="#二、排查步骤" class="headerlink" title="二、排查步骤"></a>二、排查步骤</h2><ol><li><strong>查找占用CPU高的进程PID</strong>：使用<code>top</code>命令查找，找到CPU高的进程PID</li><li><strong>查找进程中CPU高的线程TID</strong>：使用<code>ps -mp &lt;PID&gt; -o THREAD,tid,time</code>命令查找，找到CPU高的线程TID（这里打印的TID是十进制的，需要转为十六进制，可以通过命令<code>printf "%x\n" &lt;TID&gt;</code>转换，如十进制3936对应十进制f60）</li><li><strong>查看占用资源异常的线程栈</strong>：使用<code>jstack &lt;TID&gt;</code>命令查看（简易的话可以用<code>jstack &lt;TID&gt; | grep &lt;十六进制TID&gt; -A20</code>快速定位异常堆栈），就可以看到具体是哪一块代码出现了问题（一般是死循环、阻塞等）</li></ol><p>如果定位的结果是程序正常，有可能是CPU飙升时，用户访问量较大，导致系统资源不够，可适当调整配置</p><p>//TODO 截图补充</p>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景题 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用Redis实现延迟队列？</title>
      <link href="/2023/07/29/ru-he-yong-redis-shi-xian-yan-chi-dui-lie/"/>
      <url>/2023/07/29/ru-he-yong-redis-shi-xian-yan-chi-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是延迟队列？"><a href="#一、什么是延迟队列？" class="headerlink" title="一、什么是延迟队列？"></a>一、什么是延迟队列？</h2><p><strong>延迟队列</strong>是一种特殊类型的消息队列，它允许把消息发送到队列中，但不立即投递给消费者，而是在一定时间后再将消息投递给消费者</p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><p><strong>延迟队列</strong>适用于需要在未来的某个时间执行某个任务的场景，如：</p><ul><li><strong>订单的超时处理</strong>：如电商交易场景，订单下单后暂未支付，此时不可以直接关闭订单，而是需要等待一段时间后才能关闭订单</li><li><strong>定时任务</strong>：如每天5点执行文件清理</li><li><strong>游戏中定时事件触发</strong>：如第2分钟要发一次消息推送</li><li>…</li></ul><h2 id="三、实现原理"><a href="#三、实现原理" class="headerlink" title="三、实现原理"></a>三、实现原理</h2><p><strong>延迟队列</strong>是通过Redis的Zset这个有序集合来实现的，具体步骤为：</p><ol><li><strong>写入</strong>：使用<code>ZADD</code>命令把消息写入到sorted set中，并将<font color="red">当前时间作为score</font>，对应命令为<code>ZADD delay-queue &lt;timestamp&gt; &lt;message&gt;</code></li><li><strong>读取</strong>：启动一个消费者线程，使用<code>ZRANGEBYSCORE</code>命令获取定时从Zset中获取<font color="red">当前时间之前的所有消息</font>，对应命令为<code>ZRANGEBYSCORE delay-queue 0 &lt;current_time&gt; WITHSCORES LIMIT 0 &lt;batch_size&gt;</code></li><li><strong>移出</strong>：消费者处理完消息后，可以从有序集合中删除这些消息，对应命令为<code>ZREMRANGEBYSCORE delay-queue 0 &lt;current_time&gt;</code></li></ol><h2 id="四、缺陷"><a href="#四、缺陷" class="headerlink" title="四、缺陷"></a>四、缺陷</h2><p>由于消费者线程需要不断向Redis发起轮询，所以会出现两个问题：</p><ul><li>轮询存在时间间隔，所以延时消息的实际消费时间会大于设定的时间</li><li>大量轮询会对Redis服务造成压力，所以考虑到性能问题的话，可以考虑MQ，也是支持延时队列</li></ul><h2 id="五、RocketMQ实现延迟队列"><a href="#五、RocketMQ实现延迟队列" class="headerlink" title="五、RocketMQ实现延迟队列"></a>五、RocketMQ实现延迟队列</h2><p><strong>介绍</strong>：RocketMQ的定时消息和延时消息本质相同，都是服务端根据消息设置的定时时间在某一固定时刻将消息投递给消费者消费<br><strong>优势</strong>：传统的数据库扫描方式较为复杂，需要轮询，容易产生性能瓶颈，而RocketMQ具有高并发和水平扩展的能力<br><strong>参考链接</strong>：<br><a href="https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage/">https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage/</a><br><a href="https://blog.csdn.net/qq_19734597/article/details/129194011">https://blog.csdn.net/qq_19734597/article/details/129194011</a></p>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 场景题 </tag>
            
            <tag> 延迟队列 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2023/07/25/java-mian-shi-ti/"/>
      <url>/2023/07/25/java-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、随手记录的Java面试题"><a href="#一、随手记录的Java面试题" class="headerlink" title="一、随手记录的Java面试题"></a>一、随手记录的Java面试题</h2><ul><li>==和equals有什么区别？</li><li>浅拷贝和深拷贝有什么区别？</li><li>线程的sleep和wait有什么区别？</li><li>什么是动态代理？有什么优点和缺点？</li><li>关于锁的synchronized和ReentrantLock有什么区别？</li><li></li></ul><h2 id="二、常见的Java面试题-amp-答案"><a href="#二、常见的Java面试题-amp-答案" class="headerlink" title="二、常见的Java面试题&amp;答案"></a>二、常见的Java面试题&amp;答案</h2><p>//TODO</p><h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><ul><li>怎么实现单例模式</li><li>redis如何做分布式锁？释放锁的时候怎么判断是当前线程？：存UUID或线程ID</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对缓存雪崩和缓存穿透的理解，以及如何避免？</title>
      <link href="/2023/07/24/guan-yu-dui-huan-cun-xue-beng-he-huan-cun-chuan-tou-de-li-jie-yi-ji-ru-he-bi-mian/"/>
      <url>/2023/07/24/guan-yu-dui-huan-cun-xue-beng-he-huan-cun-chuan-tou-de-li-jie-yi-ji-ru-he-bi-mian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、缓存雪崩"><a href="#一、缓存雪崩" class="headerlink" title="一、缓存雪崩"></a>一、缓存雪崩</h2><p><strong>定义</strong>：<strong>缓存雪崩</strong>是存储在缓存里的大量数据，在同一时刻全部过期，导致所有流量到达了数据库，导致<font color="red">数据库压力增加造成数据库服务端崩溃</font>的现象<br><strong>具体原因&amp;解决方案</strong>：</p><ul><li><strong>缓存中间件宕机</strong>：如redis挂了，可对缓存中间件做高可用集群来避免</li><li><strong>缓存大部分key设置了相同的过期时间</strong>：导致同一时刻大量key过期，可设置过期时间时尽量加上1~5分钟的随机值（使ttl更分散）</li></ul><h2 id="二、缓存穿透"><a href="#二、缓存穿透" class="headerlink" title="二、缓存穿透"></a>二、缓存穿透</h2><p><strong>定义</strong>：<strong>缓存穿透</strong>是指短时间内大量不存在的key请求到应用里面，而由于这些key在缓存里不存在，从而全部穿透到了数据库，造成数据库压力<br><strong>解决方案</strong>：</p><ul><li><strong>把无效的key也保存到redis里面</strong>：设置一个特殊值，比如null，代表这个key数据库也不存在，就不会再去查数据库了</li><li><strong>布隆过滤器</strong>：如果key比较固定，可以在启动的时候加载到布隆过滤器里，然后攻击者用不存在的key来请求的时候，先去布隆过滤器里查询，如不存在，则说明数据库里也不存在<ul><li><strong>优点</strong>：布隆过滤器用bitmap存储，占用空间小，虽然增加了复杂度</li></ul></li></ul><h2 id="三、如果发生了缓存雪崩，数据库会怎样？"><a href="#三、如果发生了缓存雪崩，数据库会怎样？" class="headerlink" title="三、如果发生了缓存雪崩，数据库会怎样？"></a>三、如果发生了缓存雪崩，数据库会怎样？</h2><ul><li>数据库的从、双主、读写分离会很好缓解这些并发流量</li><li>数据库有最大连接数的限制，超过限制的请求会被拒绝，再结合熔断机制能很好保护数据库，最多也是造成部分用户体验不好</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis和MySQL如何保证数据一致性？</title>
      <link href="/2023/07/23/redis-he-mysql-ru-he-bao-zheng-shu-ju-yi-zhi-xing/"/>
      <url>/2023/07/23/redis-he-mysql-ru-he-bao-zheng-shu-ju-yi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>一般情况下，Redis是用来实现应用和数据库之间读操作的缓存层，主要目的是<font color="red">减少数据库IO</font>，还可以用来<font color="red">提升数据的IO性能</font></p><h2 id="二、设计思想"><a href="#二、设计思想" class="headerlink" title="二、设计思想"></a>二、设计思想</h2><p>当应用需要读取某个数据的时候，会有几个步骤：</p><ul><li>尝试去Redis查询，如果命中就直接返回</li><li>如果没有命中，则从数据库查询</li><li>同步数据库数据到Redis</li></ul><h2 id="三、分析可能出现问题的场景"><a href="#三、分析可能出现问题的场景" class="headerlink" title="三、分析可能出现问题的场景"></a>三、分析可能出现问题的场景</h2><p>当数据发生变化的时候，需要同时更新Redis和MySQL，<strong>原先方案</strong>有：<br><strong>先更新数据库，再更新缓存</strong>：</p><ul><li><strong>问题1</strong>：如果更新数据库成功，还没来得及更新缓存，这时候有另外一个客户端去访问了缓存，访问到了是旧的数据，这时候就会出现<font color="red">数据不一致</font></li><li><strong>问题2</strong>：如果缓存更新失败，也会导致<font color="red">数据不一致</font></li></ul><p><strong>先删除缓存，再更新数据库</strong>：</p><ul><li><strong>预期</strong>：应用下次请求数据，发现缓存没数据，则从数据库同步数据到缓存里</li><li><strong>分析</strong>：极端情况下，由于删除缓存和更新数据库的这两个操作不是原子的，所以还是会出现<font color="red">数据不一致</font></li><li><strong>问题</strong>：如果删除了缓存，还没来得及更新数据库，这时候有另外一个客户端去访问了缓存，发现没数据，所以去数据库同步了旧的数据，这时候数据库才更新了新的数据，就会出现<font color="red">数据不一致</font></li></ul><h2 id="四、解决方案：延迟双删"><a href="#四、解决方案：延迟双删" class="headerlink" title="四、解决方案：延迟双删"></a>四、解决方案：延迟双删</h2><p>解决数据一致性比较简单的方案有<strong>延迟双删</strong>，步骤为：</p><ol><li>删除缓存</li><li>可能有其他客户端读操作（查到缓存为空，去数据库差旧的数据）</li><li>更新数据库</li><li><font color="red">延迟删除缓存</font>（因为可能第二部的读操作还没执行完成，如果立马删除的画，读操作还没来得及写缓存，那么又会把缓存更新成旧的数据）</li></ol><p>但是<strong>延迟双删</strong>也有缺点，就是<font color="red">性能低，不适合高并发场景</font><br>所以在极端情况下仍然需要保证Redis和MySQL的数据一致性，就只能采用<strong>最终一致性</strong>方案</p><h2 id="五、解决方案：最终一致性"><a href="#五、解决方案：最终一致性" class="headerlink" title="五、解决方案：最终一致性"></a>五、解决方案：最终一致性</h2><p><strong>介绍</strong>：由于<strong>延迟双删</strong>性能低，在高并发场景下并不合适，所以出现了<strong>最终一致性</strong>的方案，它保证了最终一致性，但是可能会出现短期不一致性（如果场景不能接受短期不一致性，可以采用读写锁等的方式实现强一致性，不过性能上会有一定影响）</p><h3 id="1、采用MQ的重试机制"><a href="#1、采用MQ的重试机制" class="headerlink" title="1、采用MQ的重试机制"></a>1、采用MQ的重试机制</h3><p><strong>步骤</strong>：</p><ol><li>更新数据库</li><li>删除缓存（需要<font color="red">保证删除成功！！！</font>）</li><li>如果删除失败，则发送到MQ，使用其<font color="red">重试+手动确认</font>的机制<font color="red">保证删除成功</font></li></ol><p><strong>缺点</strong>：高耦合，每个步骤都要发MQ，比较麻烦</p><h3 id="2、用canal组件"><a href="#2、用canal组件" class="headerlink" title="2、用canal组件"></a>2、用canal组件</h3><p><strong>原理</strong>：通过监听MySQL中binlog日志，把更新后的数据同步到Redis里面<br><strong>优点</strong>：低耦合，省去了每步都需要发MQ的流程</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 并发 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决幂等性问题？</title>
      <link href="/2023/07/21/ru-he-jie-jue-mi-deng-xing-wen-ti/"/>
      <url>/2023/07/21/ru-he-jie-jue-mi-deng-xing-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是幂等？"><a href="#一、什么是幂等？" class="headerlink" title="一、什么是幂等？"></a>一、什么是幂等？</h2><p><strong>幂等</strong>指一个方法被多次重复执行的时候产生的影响和第一次执行的影响相同</p><h2 id="二、哪些行为会导致幂等性问题？"><a href="#二、哪些行为会导致幂等性问题？" class="headerlink" title="二、哪些行为会导致幂等性问题？"></a>二、哪些行为会导致幂等性问题？</h2><ul><li><strong>用户行为</strong>：用户的重复提交或用户的恶意攻击，导致这个请求被多次重复进行</li><li><strong>网络异常</strong>：在分布式架构中，为了避免网络通信导致的数据丢失，在服务之间进行通信（如http、rpc等）的时候都会设计超时重试的机制，而这种机制有可能会导致服务端接口被重复调用</li></ul><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p><strong>核心思想</strong>：保证接口的执行结果只影响一次（即后续再次调用，也不能对数据产生影响）<br><strong>解决方案</strong>：</p><ul><li><strong>redis实现</strong>：用setNx指令把每次执行的唯一标识存起来，判断是否执行过</li><li><strong>mysql实现</strong>：用唯一索引，判断是否存在（或插入时会主键冲突），比如创建订单的时候订单号是唯一的，可以用来做唯一索引，从而避免一个请求创建多个订单的问题</li><li><strong>状态机</strong>：状态机指一条数据的完整运行状态的转换流程，比如订单状态，只会向前变更（如已锁定、待支付、已支付等），所以多次修改同一条数据时，对这条数据影响只会发生一次</li></ul><p><strong>总结</strong>：</p><ul><li>要么是接口只允许调用一次，如唯一约束、redis锁</li><li>要么是对数据影响只会触发一次，如幂等性、乐观锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计分布式ID？</title>
      <link href="/2023/07/19/ru-he-she-ji-fen-bu-shi-id/"/>
      <url>/2023/07/19/ru-he-she-ji-fen-bu-shi-id/</url>
      
        <content type="html"><![CDATA[<h2 id="一、为什么要使用分布式ID？"><a href="#一、为什么要使用分布式ID？" class="headerlink" title="一、为什么要使用分布式ID？"></a>一、为什么要使用分布式ID？</h2><ul><li>比如MySQL的主键ID一般用自增的方式，但如果用分表的话，多个表中会生成重复的ID</li></ul><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><ul><li><strong>使用MySQL的全局表</strong>：每获取一次都需要更新数据库，性能差</li><li><strong>使用redis的自增id</strong></li><li><strong>UUID</strong></li><li><strong>雪花算法</strong>  </li><li>…</li></ul><h2 id="三、考虑因素"><a href="#三、考虑因素" class="headerlink" title="三、考虑因素"></a>三、考虑因素</h2><ul><li><strong>有序性</strong>：有序的ID能更好地确认数据的位置，也可以提高范围搜索的效率</li><li><strong>安全性</strong>：避免数据泄露</li><li><strong>可用性</strong>：全局ID生成系统的可用性要求非常高，一旦出现故障会造成业务不可用的问题</li><li><strong>性能</strong>：全局ID生成系统需满足整个公司的业务需求，涉及到亿级别的调用，对性能要求较高</li></ul><h2 id="四、最佳方案-雪花算法"><a href="#四、最佳方案-雪花算法" class="headerlink" title="四、最佳方案-雪花算法"></a>四、最佳方案-雪花算法</h2><p><strong>介绍</strong>：<strong>雪花算法</strong>是目前市面上主流的全局ID解决方案，由64位长度组成的全局ID生成算法，通过对64位区间划分来表述不同含义来实现唯一性<br><strong>ID划分</strong>：</p><ul><li>最高1位：固定位0（0表示位正数，因为生成的id是正整数，如果是1就是负数了）</li><li>接下来41位：毫秒级时间戳（2^41/1000<em>60</em>60<em>24</em>365=69，也就是大概可以使用69年）</li><li>再接下来10位：机器码（包括5位datacenterId和5位workerId，最后可以部署2^10=1024台机器）</li><li>最后12位：序列号（同一毫秒时间戳时，通过这个递增的序列号来区分，即对于同一台机器而言，同一个毫秒时间戳瞎，可以生成2^12=4096个不重复id）<br><img src="/images/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%88%86%E5%B8%83%E5%BC%8FID.png"></li></ul><p><strong>如何使用？</strong>：可单独将雪花算法部署到一个单独的服务，然后每一个需要使用全局唯一ID的系统，请求雪花算法服务即可<br><strong>优点</strong>：</p><ul><li>高并发分布式环境下，每秒可生成百万个不重复ID</li><li>基于时间戳+同一时间戳下序列号自增，基本保证ID有序递增</li><li>不依赖第三方或中间件</li><li>算法简单，在内存中进行，效率高</li></ul><p><strong>缺点</strong>：</p><ul><li>依赖服务器时间：服务器时钟回拨时可能会生成重复ID<ul><li><strong>解决</strong>：可在算法中记录最后一个生成ID的时间戳来解决，每次生成ID判断当前服务器时钟是否被回拨，避免生成重复ID</li></ul></li><li>低并发下生成的ID会大概率位偶数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个高并发系统？</title>
      <link href="/2023/07/19/ru-he-she-ji-yi-ge-gao-bing-fa-xi-tong/"/>
      <url>/2023/07/19/ru-he-she-ji-yi-ge-gao-bing-fa-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h2 id="二、如何设计一个高并发系统？"><a href="#二、如何设计一个高并发系统？" class="headerlink" title="二、如何设计一个高并发系统？"></a>二、如何设计一个高并发系统？</h2><p>通常设计一个高并发系统要从多个方面优化，大概方面如下：</p><ul><li><strong>分布式架构</strong>：将系统拆分为多个模块，采用分布式架构来降低单点故障的风险，并提高系统的可伸缩性和性能</li><li><strong>集群部署</strong>：即多机器部署，结合<strong>负载均衡</strong>技术将请求均衡分配给各个机器，以提高系统的吞吐量和响应速度</li><li><strong>缓存设计</strong>：使用Redis、本地缓存等缓存设计，避免全部请求打到数据库，以提高请求的响应速度</li><li><strong>异步处理</strong>：采用异步处理机制，将一些允许异步延迟处理的事件特殊处理，以降低请求的响应时间</li><li><strong>数据库优化</strong>：合理的数据库设计和优化，比如索引优化、<strong>分库分表</strong>、<strong>读写分离</strong>等，可以有效提高系统的性能</li><li><strong>池化技术</strong>：根据不同场景配置不同的线程池、连接池等，达到资源复用的目的，减少连接创建带来的开销，可以有效提高服务的性能</li><li><strong>限流</strong>：合理配置限流策略，拦截大部分异常、不合理请求，防止出现系统雪崩</li><li><strong>降级</strong>：合理做好降级处理，避免由于部分服务不可用导致功能异常，保证服务可用性</li><li><strong>压力测试</strong>：功能上线前，可以合理做一些压力测试，及时发现服务瓶颈并解决</li><li><strong>硬件支持</strong>：高性能的服务也需要高配置的CPU、内存、磁盘、带宽等支持</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何限流？</title>
      <link href="/2023/07/19/ru-he-xian-liu/"/>
      <url>/2023/07/19/ru-he-xian-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、限流目的"><a href="#一、限流目的" class="headerlink" title="一、限流目的"></a>一、限流目的</h2><p><strong>限流算法</strong>是一种系统保护策略，主要是避免流量高峰导致系统被压垮，造成系统不可用的问题</p><h2 id="二、常见的限流算法"><a href="#二、常见的限流算法" class="headerlink" title="二、常见的限流算法"></a>二、常见的限流算法</h2><ul><li><strong>计数器限流</strong>：一般用在单一维护的访问频率限制上（如短信验证码每60s只能发送一次）</li><li><strong>滑动窗口限流</strong>：本质也是计数器，区别是通过时间为维护的可滑动窗口设计，来减少临界值带来的并发超过阈值的问题（如限制过去1小时内只能发10次动态，过去24小时内只能发100条动态等）<ul><li><strong>常见框架</strong>：如Spring Cloud的熔断框架Hystrix，Alibaba的Sentinel都用了滑动窗口来做数据统计<br><img src="/images/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"></li></ul></li><li><strong>漏桶算法</strong>：是一种恒定速率的限流算法，不管请求量是多少，服务端的处理速率是恒定的<ul><li><strong>实现</strong>：如基于MQ实现的生产者消费者模型也算漏桶算法<br><img src="/images/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95-%E6%BC%8F%E6%A1%B6.png"></li></ul></li><li><strong>令牌桶算法</strong>：相比<font color="red">漏桶算法</font>来说，它可以<font color="red">处理突发流量</font>的问题<ul><li><strong>实现</strong>：令牌桶<font color="red">以恒定速率去生成令牌</font>，桶大小是固定的，满了就不再生成。客户端请求的时候，会<font color="red">获取一个令牌才能访问</font>，否则<font color="red">只能排队等待</font></li><li><strong>能够处理突发流量原理</strong>：流量低峰的时候，令牌桶会出现堆积。因为出现<font color="red">瞬时高峰</font>的时候，会有足够多的令牌可以获取，因此令牌桶可以<font color="red">允许瞬时流量</font>的处理</li><li><strong>例子</strong>：如网关层面的限流、或者接口调用的限流，都可以使用令牌桶算法，如Google的Guava、Redisson的限流，都用到了令牌桶节奏</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个秒杀系统？</title>
      <link href="/2023/07/17/ru-he-she-ji-yi-ge-miao-sha-xi-tong/"/>
      <url>/2023/07/17/ru-he-she-ji-yi-ge-miao-sha-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、分析秒杀系统"><a href="#一、分析秒杀系统" class="headerlink" title="一、分析秒杀系统"></a>一、分析秒杀系统</h2><h3 id="1、秒杀系统的特点"><a href="#1、秒杀系统的特点" class="headerlink" title="1、秒杀系统的特点"></a>1、秒杀系统的特点</h3><ul><li><strong>高并发</strong>：瞬间流量大</li><li><strong>超卖问题</strong>：秒杀商品库存少</li><li><strong>接口防刷</strong>：秒杀前刷新频繁</li></ul><h3 id="2、秒杀系统需要考虑的点"><a href="#2、秒杀系统需要考虑的点" class="headerlink" title="2、秒杀系统需要考虑的点"></a>2、秒杀系统需要考虑的点</h3><p><strong>秒杀前</strong>：</p><ul><li><strong>页面资源访问多</strong>：资源静态化，存CDN就近访问，开启资源压缩，减少传输数据量，提高速度</li><li><strong>秒杀按钮置灰</strong>：前端可通过秒杀按钮置灰来拦截部分流量到后端，如秒杀前置灰，请求未返回置灰</li><li><strong>秒杀真链接隐藏</strong>：秒杀开始后才暴露秒杀真链接，防止刷子提前获取链接做脚本刷新</li></ul><p><strong>秒杀中</strong>：</p><ul><li><font color="red"><strong>高并发/快响应</strong></font>：上线前要做好压测，评估服务器qps瓶颈点</li><li><font color="red"><strong>防止超卖</strong></font>：大量用户抢少量商品，需要防止高并发（可以用redis的lua脚本保证原子性操作）</li><li><strong>限流</strong>：限制用户请求频率，如一个人1s内只能请求10次，一个ip最多请求10次等</li></ul><p><strong>秒杀后</strong>：</p><ul><li><strong>异步处理订单后续</strong>：秒杀成功后，同步返回秒杀结果，并异步处理订单后续（如生成订单、通知等）</li><li><strong>服务降级（系统）</strong>：如用户秒杀成功但没正常生成订单，需要用MQ处理并重试，并且需要做好监控告警</li><li><strong>服务降级（人工）</strong>：如商品错误设置了价格（如iphone设置了1元一台），为了及时止损，需要加一个降级开关，返回秒杀已结束等文案</li></ul><h2 id="二、设计秒杀系统"><a href="#二、设计秒杀系统" class="headerlink" title="二、设计秒杀系统"></a>二、设计秒杀系统</h2><h3 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h3><ul><li>将商品（如库存等）提前写入到缓存里</li><li>用户秒杀后，我们要在redis对商品进行扣减</li><li>如果秒杀成功，则把秒杀成功的消息发送到mq，具体的下游业务异步处理（如订单服务、支付服务等）</li><li>同步更新MySQL数据（如库存等）</li></ul><h3 id="2、如何实现高并发？"><a href="#2、如何实现高并发？" class="headerlink" title="2、如何实现高并发？"></a>2、如何实现高并发？</h3><p><strong>背景</strong>：秒杀瞬时流量大，所以如何防止高并发造成缓存击穿或者缓存失效、击垮数据库都是我们需要考虑的问题<br><strong>方案</strong>：</p><ul><li>使用redis集群代替单体redis：考虑到缓存击穿问题，我们可以构建redis集群（如哨兵模式），来保证系统高可用</li><li>…</li></ul><h3 id="3、如何实现接口防刷-限流？"><a href="#3、如何实现接口防刷-限流？" class="headerlink" title="3、如何实现接口防刷/限流？"></a>3、如何实现接口防刷/限流？</h3><p><strong>方案</strong>：</p><ul><li><strong>前端限流</strong>：多次点击秒杀按钮之间，可以将按钮置灰n秒，也就是无法连续点击</li><li><strong>后端限流</strong>：<strong>滑动窗口算法限流</strong>（用户uid作为key统计次数）、<strong>令牌桶算法限流</strong>（有效应对瞬时流量）</li></ul><h3 id="4、如何实现秒杀链接的动态性？"><a href="#4、如何实现秒杀链接的动态性？" class="headerlink" title="4、如何实现秒杀链接的动态性？"></a>4、如何实现秒杀链接的动态性？</h3><p><strong>方案</strong>：可以在URL后面拼接一串MD5加密后的随机字符串，具体步骤为前端访问后端获取秒杀的URL，然后再访问该URL，后端会对该URL进行校验，校验通过的画才能继续秒杀操作</p><h3 id="5、数据库设计"><a href="#5、数据库设计" class="headerlink" title="5、数据库设计"></a>5、数据库设计</h3><p><strong>背景</strong>：防止秒杀系统崩了影响其他业务，我们的秒杀系统数据库一般不能与其他业务数据库放在一起<br>可以设计的<strong>秒杀系统表</strong>有：</p><ul><li>秒杀商品表</li><li>秒杀订单表</li><li>秒杀订单明细表</li><li>秒杀活动表</li><li>用户表</li><li>…</li></ul><h3 id="6、如何实现库存预热？"><a href="#6、如何实现库存预热？" class="headerlink" title="6、如何实现库存预热？"></a>6、如何实现库存预热？</h3><p><strong>方案</strong>：秒杀活动开始前，使用定时任务等方式将商品的库存信息提前缓存到redis中，等到用户秒杀下单时，可以快速直接扣减redis中的商品库存，无需直接操作数据库<br><strong>注意</strong>：为了保证<strong>查询库存</strong>和<strong>扣除库存</strong>这两个操作之间的原子性，可以借助redis的lua脚本</p><h3 id="7、如何做好服务降级、熔断问题？"><a href="#7、如何做好服务降级、熔断问题？" class="headerlink" title="7、如何做好服务降级、熔断问题？"></a>7、如何做好服务降级、熔断问题？</h3><p><strong>背景</strong>：为了避免某些服务/服务器发生宕机或服务不可用的情况，我们需要做一些服务熔断和降级措施，即进行快速失败<br><strong>方案</strong>：使用一些中间件，如Alibaba Sentinel、Hystrix等</p><h2 id="三、解决秒杀系统的常见问题"><a href="#三、解决秒杀系统的常见问题" class="headerlink" title="三、解决秒杀系统的常见问题"></a>三、解决秒杀系统的常见问题</h2><h3 id="1、如何解决秒杀系统中超卖问题？"><a href="#1、如何解决秒杀系统中超卖问题？" class="headerlink" title="1、如何解决秒杀系统中超卖问题？"></a>1、如何解决秒杀系统中超卖问题？</h3><p><strong>超卖</strong>指的是同一个时间有多个用户同时去抢单，即同时扣减多个库存，这时候就可能出现用户数大于redis缓存的库存数，出现<font color="red">超卖</font>的问题</p><ul><li>例子：比如商品只有10个，但是发现秒杀后卖了20个，那么有10个人是拿不到商品的</li></ul><p><strong>秒杀扣减库存</strong>分为两个步骤，分别为：</p><ul><li>判断库存数是否充足</li><li>扣减库存</li></ul><p><strong>解决方案</strong>：使用redis的lua脚本，保证操作的原子性</p><h3 id="2、如果redis减库存成功，但mq消费失败了怎么办？"><a href="#2、如果redis减库存成功，但mq消费失败了怎么办？" class="headerlink" title="2、如果redis减库存成功，但mq消费失败了怎么办？"></a>2、如果redis减库存成功，但mq消费失败了怎么办？</h3><p><strong>可能出现问题</strong>：订单生成失败等，这就是秒杀系统的<font color="red">少卖</font>问题<br><strong>解决方案</strong>：</p><ul><li><strong>mq添加重试机制</strong>：如果重试多次仍发送失败，则需要把该消息持久化（如存到MySQL中），并进行轮询重试处理，保证该消息能正常处理</li><li><strong>持久化mq消息</strong>：增加一张消息发送表，在生产者发送mq之前，先把消息存到消息发送表中，并设置消息状态为<strong>待处理</strong>，然后再发送mq，消费者消费后，回调生产者的接口，修改消息的状态为<strong>已处理</strong>。这样如果在写表后发送失败，可以借助定时任务扫描待处理的消息，然后重新发送</li><li><strong>监控告警</strong>：做好解决方案后，还是需要监控mq是否发送失败，以及重试后是否最终还是发送失败，并做对应的告警</li></ul>]]></content>
      
      
      <categories>
          
          <category> 场景题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 场景题 </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客导航</title>
      <link href="/2023/07/17/bo-ke-dao-hang/"/>
      <url>/2023/07/17/bo-ke-dao-hang/</url>
      
        <content type="html"><![CDATA[<h2 id="strawberry-Java"><a href="#strawberry-Java" class="headerlink" title=":strawberry: Java"></a><span class="github-emoji"><span>🍓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f353.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Java</h2><ul><li><a href="https://garyleeeee.github.io/2023/08/12/java-dong-tai-dai-li/">Java动态代理</a></li></ul><h2 id="floppy-disk-MySQL"><a href="#floppy-disk-MySQL" class="headerlink" title=":floppy_disk: MySQL"></a><span class="github-emoji"><span>💾</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4be.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> MySQL</h2><ul><li><a href="https://garyleeeee.github.io/2023/07/06/mysql/mysql-suo/">MySQL锁</a></li><li><a href="https://garyleeeee.github.io/2023/07/03/mysql/mysql-suo-yin/">MySQL索引</a></li><li><a href="https://garyleeeee.github.io/2023/07/03/mysql/mysql-shi-wu/">MySQL事务</a></li><li><a href="https://garyleeeee.github.io/2023/07/01/mysql/mvcc-bi-ji/">MVCC笔记</a></li><li><a href="https://garyleeeee.github.io/2023/06/27/mysql/mysql-ri-zhi-pian/">MySQL日志篇</a></li><li><a href="https://garyleeeee.github.io/2023/08/15/mysql/ru-he-pai-cha-mysql-suo-yin-shi-xiao-de-wen-ti/">如何排查MySQL索引失效的问题？</a></li><li><a href="https://garyleeeee.github.io/2023/08/17/mysql/shi-me-shi-ju-cu-suo-yin-he-fei-ju-cu-suo-yin/">什么是聚簇索引和非聚簇索引？</a></li><li><a href="https://garyleeeee.github.io/2023/08/17/mysql/shi-me-shi-hui-biao-zen-me-jian-shao-hui-biao-de-ci-shu/">什么是回表，怎么减少回表的次数？</a></li><li><a href="https://garyleeeee.github.io/2023/08/18/mysql/mysql-zhi-xing-ji-hua-fen-xi/">MySQL执行计划分析</a></li><li><a href="https://garyleeeee.github.io/2023/08/19/mysql/ru-he-jin-xing-sql-diao-you/">如何进行SQL调优？</a></li><li><a href="https://garyleeeee.github.io/2023/08/19/mysql/ru-he-pai-cha-man-sql-wen-ti/">如何排查慢SQL问题？</a></li><li><a href="https://garyleeeee.github.io/2023/08/20/mysql/limit1000000-0-jia-zai-hen-man-ru-he-you-hua/">limit 1000000,0加载很慢如何优化？</a></li><li><a href="https://garyleeeee.github.io/2023/09/05/mysql/innodb-he-myisam-you-shi-me-qu-bie/">InnoDB和MyISAM有什么区别？</a></li></ul><h2 id="cloud-Redis"><a href="#cloud-Redis" class="headerlink" title=":cloud: Redis"></a><span class="github-emoji"><span>☁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2601.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Redis</h2><ul><li><a href="https://garyleeeee.github.io/2023/07/24/guan-yu-dui-huan-cun-xue-beng-he-huan-cun-chuan-tou-de-li-jie-yi-ji-ru-he-bi-mian/">关于对缓存雪崩和缓存穿透的理解，以及如何避免？</a></li><li><a href="https://garyleeeee.github.io/2023/08/08/redis/redis-ji-qun/">Redis集群</a></li><li><a href="https://garyleeeee.github.io/2023/08/16/redis/redis-guo-qi-ce-lue/">Redis过期策略</a></li><li><a href="https://garyleeeee.github.io/2023/08/16/redis/redis-nei-cun-tao-tai-ce-lue/">Redis内存淘汰策略</a></li><li><a href="https://garyleeeee.github.io/2023/08/19/redis/ru-he-chu-li-redis-de-da-key-wen-ti/">如何处理Redis的大key问题？</a></li><li><a href="https://garyleeeee.github.io/2023/08/23/redis-wei-shi-me-zhe-me-kuai/">Redis为什么这么快？</a></li><li><a href="https://garyleeeee.github.io/2023/08/25/redis/ru-he-shi-xian-duo-ji-huan-cun/">如何实现多级缓存？</a></li><li><a href="https://garyleeeee.github.io/2023/09/05/redis/redis-de-chi-jiu-hua-ji-zhi-shi-zen-yang-de/">Redis的持久化机制是怎样的？</a></li></ul><h2 id="computer-JVM"><a href="#computer-JVM" class="headerlink" title=":computer: JVM"></a><span class="github-emoji"><span>💻</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4bb.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> JVM</h2><ul><li><a href="https://garyleeeee.github.io/2023/07/12/jvm/gc-xue-xi-bi-ji/">GC学习笔记</a></li><li><a href="https://garyleeeee.github.io/2023/08/04/java-lei-jia-zai-ji-zhi/">Java类加载机制</a></li><li><a href="https://garyleeeee.github.io/2023/09/06/jvm/jvm-yun-xing-shi-shu-ju-qu-yu-shi-zen-yang-de/">JVM运行时数据区域是怎样的？</a></li></ul><h2 id="dart-并发"><a href="#dart-并发" class="headerlink" title=":dart: 并发"></a><span class="github-emoji"><span>🎯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3af.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 并发</h2><ul><li><a href="https://garyleeeee.github.io/2021/08/01/gao-ke-yong-xue-xi-bi-ji-ke-pu-xiang/">高可用学习笔记(科普向)</a></li><li><span class="github-emoji"><span>🏆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><a href="https://garyleeeee.github.io/2021/07/28/xian-cheng-chi-xue-xi-bi-ji/">线程池学习笔记</a></li><li><a href="https://garyleeeee.github.io/2023/07/19/ru-he-xian-liu/">如何限流？</a></li><li><a href="https://garyleeeee.github.io/2023/07/19/ru-he-she-ji-fen-bu-shi-id/">如何设计分布式ID？</a></li><li><a href="https://garyleeeee.github.io/2023/07/21/ru-he-jie-jue-mi-deng-xing-wen-ti/">如何解决幂等性问题？</a></li><li><a href="https://garyleeeee.github.io/2023/07/19/ru-he-she-ji-yi-ge-gao-bing-fa-xi-tong/">如何设计一个高并发系统？</a></li><li><span class="github-emoji"><span>🏆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><a href="https://garyleeeee.github.io/2023/07/23/redis-he-mysql-ru-he-bao-zheng-shu-ju-yi-zhi-xing/">Redis和MySQL如何保证数据一致性？</a></li><li><a href="https://garyleeeee.github.io/2023/08/25/concurrent/shi-me-shi-fu-wu-jiang-ji/">什么是服务降级？</a></li><li><a href="https://garyleeeee.github.io/2023/09/05/concurrent/ru-he-shi-xian-yi-ge-fen-bu-shi-suo/">如何实现一个分布式锁？</a></li></ul><h2 id="art-Kafka"><a href="#art-Kafka" class="headerlink" title=":art: Kafka"></a><span class="github-emoji"><span>🎨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3a8.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Kafka</h2><ul><li><a href="https://garyleeeee.github.io/2023/07/12/kafka-mian-shi-ti/">Kafka面试题</a></li><li><a href="https://garyleeeee.github.io/2023/09/06/kafka/kafka-ru-he-jie-jue-xiao-xi-ji-ya-wen-ti/">Kafka如何解决消息积压问题？</a></li></ul><h2 id="memo-Http"><a href="#memo-Http" class="headerlink" title=":memo: Http"></a><span class="github-emoji"><span>📝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4dd.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Http</h2><ul><li><a href="https://garyleeeee.github.io/2023/07/03/http-xue-xi-bi-ji/">Http学习笔记</a></li></ul><h2 id="wrench-工具"><a href="#wrench-工具" class="headerlink" title=":wrench: 工具"></a><span class="github-emoji"><span>🔧</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f527.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 工具</h2><ul><li><a href="https://garyleeeee.github.io/2022/10/19/fen-ye-cha-jian-pagehelper-de-shi-yong/">分页插件PageHelper的使用</a></li><li><a href="https://garyleeeee.github.io/2022/10/16/dubbo-shi-yong-bi-ji/">Dubbo使用笔记</a></li><li><a href="https://garyleeeee.github.io/2021/07/31/hexo-shi-yong-bi-ji/">hexo使用笔记</a></li><li><a href="https://garyleeeee.github.io/2021/08/07/dai-ma-ku/">代码库</a></li><li><a href="https://garyleeeee.github.io/2021/11/05/rabbitmq-an-zhuang-bi-ji/">RabbitMQ安装笔记</a></li><li><a href="https://garyleeeee.github.io/2022/03/02/vue-xiang-mu-chuang-jian-fang-shi/">Vue项目创建方式</a></li><li><a href="https://garyleeeee.github.io/2021/08/12/k8s-xue-xi-bi-ji/">k8s学习笔记</a></li><li><a href="https://garyleeeee.github.io/2021/11/09/mybatis-plus-shi-yong-bi-ji/">Mybatis-Plus使用笔记</a></li></ul><h2 id="book-场景题"><a href="#book-场景题" class="headerlink" title=":book: 场景题"></a><span class="github-emoji"><span>📖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4d6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 场景题</h2><ul><li><span class="github-emoji"><span>🏆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><a href="https://garyleeeee.github.io/2023/07/17/ru-he-she-ji-yi-ge-miao-sha-xi-tong/">如何设计一个秒杀系统？</a></li><li><a href="https://garyleeeee.github.io/2023/07/29/ru-he-yong-redis-shi-xian-yan-chi-dui-lie/">如何用Redis实现延迟队列？</a></li><li><a href="https://garyleeeee.github.io/2023/07/29/ru-he-pai-cha-cpu-biao-sheng-wen-ti/">如何排查CPU飙升问题？</a></li><li><a href="https://garyleeeee.github.io/2023/07/31/ru-he-shi-xian-yi-ge-dian-zan-gong-neng/">如何实现一个点赞功能？</a></li><li><a href="https://garyleeeee.github.io/2023/08/20/ru-he-shi-xian-yi-ge-sao-ma-deng-lu-gong-neng/">如何实现一个扫码登录功能？</a></li><li><a href="https://garyleeeee.github.io/2023/08/20/scene/ru-he-shi-xian-yi-ge-fen-shu-xiang-tong-ze-an-shi-jian-pai-xu-de-pai-xing-bang/">如何实现一个分数相同则按时间排序的排行榜？</a></li><li><a href="https://garyleeeee.github.io/2023/08/20/scene/ru-he-fang-zhi-ku-cun-chao-mai/">如何防止库存超卖？</a></li><li><a href="https://garyleeeee.github.io/2023/08/25/scene/ru-he-she-ji-yi-ge-gou-wu-che-gong-neng/">如何设计一个购物车功能？</a></li></ul><h2 id="battery-代码优化"><a href="#battery-代码优化" class="headerlink" title=":battery: 代码优化"></a><span class="github-emoji"><span>🔋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 代码优化</h2><ul><li><a href="https://garyleeeee.github.io/2023/07/31/ru-he-you-hua-da-liang-if-else-dai-ma-jie-gou/">如何优化大量if-else代码结构？</a></li></ul><h2 id="coffee-Spring"><a href="#coffee-Spring" class="headerlink" title=":coffee: Spring"></a><span class="github-emoji"><span>☕</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2615.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Spring</h2><ul><li><a href="https://garyleeeee.github.io/2023/08/01/spring/spring-ru-he-jie-jue-xun-huan-yi-lai-de-wen-ti/">Spring如何解决循环依赖的问题？</a></li><li><a href="https://garyleeeee.github.io/2023/08/13/spring/jie-shao-yi-xia-spring-de-aop/">介绍一下Spring的AOP</a></li><li><a href="https://garyleeeee.github.io/2023/08/22/spring/springbean-de-sheng-ming-zhou-qi/">Spring Bean的生命周期</a></li><li><a href="https://garyleeeee.github.io/2023/09/06/spring/spring-shi-wu/">Spring事务</a></li></ul><h2 id="mag-ElasticSearch"><a href="#mag-ElasticSearch" class="headerlink" title=":mag: ElasticSearch"></a><span class="github-emoji"><span>🔍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f50d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> ElasticSearch</h2><ul><li><a href="https://garyleeeee.github.io/2023/08/26/wei-shi-me-yao-shi-yong-elasticsearch/">为什么要使用ElasticSearch？</a></li><li><a href="https://garyleeeee.github.io/2023/08/26/shi-me-shi-dao-pai-suo-yin/">什么是倒排索引？</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka面试题</title>
      <link href="/2023/07/12/kafka-mian-shi-ti/"/>
      <url>/2023/07/12/kafka-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Kafka面试题"><a href="#一、Kafka面试题" class="headerlink" title="一、Kafka面试题"></a>一、Kafka面试题</h2><h3 id="1、Kafka的副本机制有什么用？"><a href="#1、Kafka的副本机制有什么用？" class="headerlink" title="1、Kafka的副本机制有什么用？"></a>1、Kafka的副本机制有什么用？</h3><p>Kafka的副本机制是保证消息可靠性的重要手段之一，它可以：</p><ul><li><strong>提高可用性</strong>：Kafka每个topic有多个分区，每个分区有多个副本，但其中只能有一个是leader副本，其余的都是follower副本，不像MySQL一样，Kafka只有leader副本才可以处理读写请求，follower副本只是从leader副本同步数据，并不会处理读写请求。<font color="red">当leader副本宕机时，会自动切换其中一个follower副本为新的leader副本，从而提高系统的可用性</font></li><li><strong>提高容错性</strong>：能够防止数据丢失。在写入成功后，只有当数据被所有副本写入磁盘后，才认为该消息已经成功提交。如果某个节点出现故障导致不能正常同步，Kafka就会自动重试发送该消息，直到超时或成功为止</li></ul><h3 id="2、Kafka如何避免重复消费？"><a href="#2、Kafka如何避免重复消费？" class="headerlink" title="2、Kafka如何避免重复消费？"></a>2、Kafka如何避免重复消费？</h3><p><strong>背景</strong>：</p><ul><li>Kafka broker的record都有一个offset标记（自己在分区中的位置信息）</li><li>Kafka consumer也有个offset标记来维护当前已经消费数据的位置信息</li><li>每消费一批数据，broker就会更新offset的值，避免重复消费</li><li>默认record消费完会自动提交offset的值<ul><li><strong>自动提交时机</strong>：默认5s间隔提交（即5s后的下一次向broker拉取消息的时候提交）</li><li><strong>重复消费1</strong>：当consumer消费时，如果程序宕机，那么会导致offset没提交，从而重复消费</li></ul></li><li><strong>rebalance机制</strong>：把多个partition随机分配给多个消费者实例，如果其中某些partition不能正常使用，则会分配给其余正常的partition<ul><li><strong>重复消费2</strong>：如果consumer在默认的5分钟内处理不完从partition拉的消息，就会出发rebalance，从而导致offset自动提交失败。而rebalance后，新的consumer会从之前没提交的offset位置开始消费，从而导致重复消费</li></ul></li></ul><p><strong>避免方案</strong>：</p><ul><li>提高consumer的消费速率，如异步处理</li><li>减少一次性从broker拉取消息条数，减少问题出现</li><li>调整消息处理的超时时间</li><li><strong>幂等性</strong>：针对消息生成md5（或其他唯一标识），存到redis或mysql，每次消费消息都判断是否已消费过</li></ul><h3 id="3、Kafka如何保证消息消费的顺序性？"><a href="#3、Kafka如何保证消息消费的顺序性？" class="headerlink" title="3、Kafka如何保证消息消费的顺序性？"></a>3、Kafka如何保证消息消费的顺序性？</h3><p><strong>背景</strong>：</p><ul><li>Kafka通过partition来实现消息的物理存储，一个topic有多个partition</li><li>同一个partition的消息是有序的</li><li>同一个consumer有多个实例消费，每一个实例负责的partitin是有序的，但是每一个实例消费速率不同，导致可能宏观上看并不是有序的</li><li>如果用异步线程来消费数据，可以提高消费速率，但是每个线程的消息处理速率是不同的，所以单个partition的消费也可能会出现无序问题</li></ul><p><strong>解决方案</strong>：</p><ul><li>调整路由策略，把指定key发送到同一个partition中（如用户行为可以通过uid去路由，这样就可以保证该用户是有序消费的）</li><li>把消息放到阻塞队列，然后用异步线程去阻塞队列获取消息消费</li></ul><h3 id="4、Kafka如何实现高吞吐量？"><a href="#4、Kafka如何实现高吞吐量？" class="headerlink" title="4、Kafka如何实现高吞吐量？"></a>4、Kafka如何实现高吞吐量？</h3><ul><li><strong>磁盘顺序读写</strong>：日志追加写，减少随机I/O的耗时，提高了写入的吞吐量</li><li><strong>零拷贝</strong>：节约了用户空间和内核空间的切换<ul><li>一般文件拷贝：读取磁盘-&gt;写入内核缓冲区-&gt;拷贝到用户空间缓冲区-&gt;调用write等方法拷贝到内核空间的socket buffer-&gt;发送到网卡缓冲区-&gt;发送到目标服务器</li><li>Kafka拷贝：读取磁盘-&gt;写入内核缓冲区-&gt;拷贝到socket buffer-&gt;发送到网卡缓冲区-&gt;发送到目标服务器</li></ul></li><li><strong>批量处理</strong>：Kafka允许生产者批量打包多个消息发送，减少网络传输的开销和提高I/O吞吐量，同时也允许消费者批量从broker拉取一批数据，并批量处理以提高效率</li></ul><h3 id="5、Kafka如何保证消息不丢失？"><a href="#5、Kafka如何保证消息不丢失？" class="headerlink" title="5、Kafka如何保证消息不丢失？"></a>5、Kafka如何保证消息不丢失？</h3><p>一般是通过三个方面来保证消息不丢失：</p><ul><li><strong>producer端</strong>：保证消息不丢失，也就是保证数据发送成功<ul><li>失败重试：默认是异步发送，改为同步发送的话，producer可以感知消息发送的结果，并添加回调函数来监听消息发送结果，如果失败则重试</li><li>调整retries参数：如果因为网络原因或broker故障等问题，producer会自动重试</li></ul></li><li><strong>broker端</strong>：保证消息不丢失，也就是把数据持久化到硬盘即可<ul><li>背景：为了保证性能，Kafka采用了异步批量刷盘机制（达到一定消息量和时间间隔来刷盘），如果在刷盘之前系统崩溃，就会出现数据丢失</li><li>解决方案：通过partition的副本机制+acks机制来解决<ul><li>acks=0，表示producer不许等broker响应就认为发送成功，会存在<font color="red">消息丢失</font></li><li>acks=1，表示producer会等leader返回确认就认为发送成功（不需要等follower同步完成），如果这时候leader挂了，就会存在<font color="red">消息丢失</font></li><li>acks=-1，表示leader收到消息后，<font color="red">需要等待ISR列表的follower同步完成</font>，才会给producer返回确认，<font color="red">这个配置可以保证数据的可靠性</font></li></ul></li></ul></li><li><strong>consumer端</strong>：保证消息不丢失，也就是保证数据正常消费并提交<ul><li>解决方案：手动提交offset，如果出现消息丢失的情况，则可以通过调整offset的值重新消费</li></ul></li></ul><h3 id="6、Kafka的ISR、OSR有什么区别？"><a href="#6、Kafka的ISR、OSR有什么区别？" class="headerlink" title="6、Kafka的ISR、OSR有什么区别？"></a>6、Kafka的ISR、OSR有什么区别？</h3><p>Kafka的ISR、OSR都是指副本机制中需要同步数据的副本，区别在于：</p><ul><li><strong>ISR</strong>：即in-sync reply（同步中副本），指同步进度较好的副本，包含leader副本，在重新选举leader的时候会从ISR中选择</li><li><strong>OSR</strong>：即out-sync reply，指同步进度滞后的副本</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC学习笔记</title>
      <link href="/2023/07/12/jvm/gc-xue-xi-bi-ji/"/>
      <url>/2023/07/12/jvm/gc-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>背景</strong>：我们在Java开发中，会不断创建很多的对象，这些对象会占用系统内存，如果得不到有效的管理，内存的占用会越来越多，甚至会出现内存溢出的情况，所以，我们需要进行对内存合理地释放，</p><p><strong>介绍</strong>：GC，也就是Garbage Collection（垃圾收集），是JVM提供的一种对内存回收的机制，它一般会在内存空闲或者内存占用过高的时候对那些没有任何引用的对象不定时地进行回收</p><h2 id="二、垃圾回收算法"><a href="#二、垃圾回收算法" class="headerlink" title="二、垃圾回收算法"></a>二、垃圾回收算法</h2><h3 id="1、标记清除算法（Mark-Sweep）"><a href="#1、标记清除算法（Mark-Sweep）" class="headerlink" title="1、标记清除算法（Mark-Sweep）"></a>1、标记清除算法（Mark-Sweep）</h3><p><strong>介绍</strong>：标记所有需要回收的对象，并清理<br><strong>缺点</strong>：</p><ul><li>会产生大量内存碎片，导致后续可能大对象找不到连续可用空间</li><li>标记、清理效率不高，需要扫描所有对象（堆越大，gc越慢）<br><img src="/images/jvm/gc%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记清除算法"></li></ul><h3 id="2、标记复制算法（Mark-Copy）"><a href="#2、标记复制算法（Mark-Copy）" class="headerlink" title="2、标记复制算法（Mark-Copy）"></a>2、标记复制算法（Mark-Copy）</h3><p><strong>介绍</strong>：把内存分为等大小的两块，每次只使用其中一块，当这一块内存满后将存活对象复制到另一块去，然后清理，反过来亦然<br><strong>优点</strong>：</p><ul><li>不会产生内存碎片</li></ul><p><strong>缺点</strong>：</p><ul><li>可用空间缩小为原来一半（即需要双倍空间）</li><li>在对象存活率高时，效率低下<br><img src="/images/jvm/gc%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="标记复制算法"></li></ul><h3 id="3、标记整理算法（Mark-Compact）"><a href="#3、标记整理算法（Mark-Compact）" class="headerlink" title="3、标记整理算法（Mark-Compact）"></a>3、标记整理算法（Mark-Compact）</h3><p><strong>介绍</strong>： 标记后，将存活对象整理到一起，然后再清理<br><strong>优点</strong>：</p><ul><li>不会产生内存碎片</li><li>不用额外的内存空间</li></ul><p><strong>缺点</strong>：</p><ul><li>相比标记清除算法耗时更多<br><img src="/images/jvm/gc%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记整理算法"></li></ul><h2 id="三、CMS垃圾收集器"><a href="#三、CMS垃圾收集器" class="headerlink" title="三、CMS垃圾收集器"></a>三、CMS垃圾收集器</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><ul><li>CMS（Concurrent Mark Sweep）收集器是一种以<font color="red">获取最短回收时间</font>为目标的收集器</li><li>面向老年代</li><li>基于标记清除算法实现</li></ul><h3 id="2、步骤"><a href="#2、步骤" class="headerlink" title="2、步骤"></a>2、步骤</h3><ul><li><strong>初始标记</strong>：标记gc roots直接关联的对象，这个过程需要STW</li><li><strong>并发标记</strong>：标记所有对象，这个过程会和用户线程并发执行</li><li><strong>重新标记</strong>：由于<code>并发标记</code>是并发的，可能会有部分引用异常，所以需要重新标记，来标记<code>并发标记</code>中变动过的少数对象，这个过程需要STW</li><li><strong>并发清除</strong>：并发清理，这个过程会和用户线程并发执行</li></ul><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><h3 id="1、如何判断哪些垃圾能回收？"><a href="#1、如何判断哪些垃圾能回收？" class="headerlink" title="1、如何判断哪些垃圾能回收？"></a>1、如何判断哪些垃圾能回收？</h3><p><strong>可达性分析算法</strong>：从整个堆内存的根对象出发，看看哪些对象是可达的，哪些对象是不可达的<br><strong>哪些可以作为根对象（GC ROOTS）</strong>：</p><ul><li>栈中引用的对象（如局部变量等）</li><li>类静态属性引用的对象（如java类的引用类型静态变量）</li><li>常量引用的对象（如字符串常量池中的引用）</li><li>synchronized修饰的对象</li><li>native修饰的对象</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁</title>
      <link href="/2023/07/06/mysql/mysql-suo/"/>
      <url>/2023/07/06/mysql/mysql-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>MySQL的锁主要为：</p><ul><li>全局锁</li><li>表锁</li><li>行锁</li></ul><h2 id="二、全局锁"><a href="#二、全局锁" class="headerlink" title="二、全局锁"></a>二、全局锁</h2><p><strong>全局锁</strong>分为：</p><ul><li>读锁（共享锁）：允许别人读取数据，不允许更新数据</li><li>写锁（排它锁）：不允许别人读取和更新数据</li></ul><p><strong>使用场景</strong>：进行一些需要确保整个数据库一致性的操作，例如全库备份、全库导出等<br><strong>添加锁语句</strong>：<code>FLUSH TABLES WITH READ LOCK</code><br><strong>释放锁语句</strong>：<code>UNLOCK TABLES</code></p><h2 id="三、表锁"><a href="#三、表锁" class="headerlink" title="三、表锁"></a>三、表锁</h2><p><strong>特点</strong>：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>InnoDB引擎在必要情况下会使用表锁，但主要是使用行锁来实现多版本并发控制（MVCC），它能提供更好的并发性能和更少的锁冲突</p><h3 id="1、使用场景"><a href="#1、使用场景" class="headerlink" title="1、使用场景"></a>1、使用场景</h3><ul><li><strong>读多写少</strong>：因为表级读锁不会阻塞其他的读锁，所以这种场景下表锁能够提供很高的性能</li><li><strong>数据量少</strong>：由于数据量少，那么即使在写操作中，由于锁定整张表，对性能的影响也不大</li><li><strong>全表更新/删除</strong>：例如更新表中所有记录的某个字段的值，或删除表中的所有记录，那么使用表级锁是最合适的</li></ul><h3 id="2、MySQL哪些命令会发生表级锁"><a href="#2、MySQL哪些命令会发生表级锁" class="headerlink" title="2、MySQL哪些命令会发生表级锁"></a>2、MySQL哪些命令会发生表级锁</h3><ul><li>ALTER TABLE</li><li>DROP TABLE/TRUNCATE TABLE</li><li>LOCK TABLES：如<code>LOCK TABLES t1 WRITE, t2 READ</code></li><li>全表扫描/大范围扫描：针对MyISAM存储引擎，全局扫描/大范围扫描会触发表级锁</li><li>FLUSH TABLES WITH READ LOCK：可以给所有表加上全局读锁</li></ul><h3 id="3、不同的存储引擎主要用哪些锁？"><a href="#3、不同的存储引擎主要用哪些锁？" class="headerlink" title="3、不同的存储引擎主要用哪些锁？"></a>3、不同的存储引擎主要用哪些锁？</h3><ul><li>InnoDB存储引擎主要使用行级锁，并在一些情况下使用表级锁，如执行某些<code>ALTER TABLE</code>或<code>LOCK TABLES</code>命令等</li><li>MyISAM存储引擎只支持表级锁</li></ul><h3 id="4、表锁有哪些风险点？"><a href="#4、表锁有哪些风险点？" class="headerlink" title="4、表锁有哪些风险点？"></a>4、表锁有哪些风险点？</h3><ul><li><strong>性能下降</strong>：会锁整张表，可能会导致大量的请求阻塞</li><li><strong>并发性能差</strong>：因为写锁会阻塞读写操作，读锁会阻塞写操作</li><li><strong>可能导致锁等待和超时</strong>：由于表级锁粒度较大，可能会有很多线程在等待锁，如果等待时间过长，可能会导致锁超时</li><li><strong>写操作影响大</strong>：如果一个长时间运行的写操作（如大数量量的UPDATE或INSERT）获取了写锁，那么会阻塞所有其他的读操作和写操作，直到这个写操作完成</li><li><strong>死锁的可能性</strong>：如果获取顺序不对，可能会导致死锁（如线程A获取table1等待获取table2，线程B获取table2等待获取table1）</li></ul><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>为了避免上面提到的风险点，我们通常会选择InnoDB存储引擎，原因有：</p><ul><li>它主要使用<font color="red">行级锁</font>，可以提供更好的并发性能，并且在一定程度上减少了锁竞争的问题</li><li>而且，InnoDB还<font color="red">支持事务</font>，可以保证数据的一致性和完整性</li></ul><h2 id="四、行锁"><a href="#四、行锁" class="headerlink" title="四、行锁"></a>四、行锁</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>行级锁是MySQL的一种锁，可以对数据库表中的单一行进行锁定。相比表级锁和页锁，<font color="red">行级锁的粒度更小</font>，因此在处理高并发事务时，能提供更好的并发性能和更少的锁冲突。<br>然而，<font color="red">行级锁也需要更多的内存和CPU资源</font>，因为需要对每一行都进行管理</p><h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>InnoDB支持两种类型的行级锁：</p><ul><li>共享锁（S锁）：也称<strong>读锁</strong>，允许一个事务<font color="red">读取</font>一行数据，允许其他事务读取该行数据，但不允许修改</li><li>排他锁（X锁）：也称<strong>写锁</strong>，允许一个事务<font color="red">读取和修改</font>一行数据，不允许其他事务读取和修改该行数据</li></ul><h3 id="3、什么时候生效？"><a href="#3、什么时候生效？" class="headerlink" title="3、什么时候生效？"></a>3、什么时候生效？</h3><ul><li>行级锁只在事务中生效，也就是说，只有在一个事务开始（BEGIN）并在事务提交（COMMIT）或回滚（ROLLBACK）前，才会对数据行进行锁定</li><li>如果在非事务环节下执行SQL语句，那么InnoDB会在执行结束就释放所有的锁（如执行select xxx for update）</li></ul><h3 id="4、使用场景"><a href="#4、使用场景" class="headerlink" title="4、使用场景"></a>4、使用场景</h3><ul><li><strong>高并发读写操作</strong>：在高并发读写场景下，行锁可以提高性能和并发性，因为它<font color="red">允许多个事务并发地操作不同的行</font></li><li><strong>单行操作</strong>：对于需要操作单行数据的SQL语句（如基于主键或唯一索引的UPDATE、DELETE或INSERT语句），行级锁<font color="red">可以提供较好的并发性和性能</font></li><li><strong>短期锁</strong>：在需要对某行数据进行短期锁定的情况下，行级锁<font color="red">可以防止长时间阻塞其他事务</font></li><li><strong>实现并发控制</strong></li><li><strong>复杂的事务处理</strong>：在需要对多行数据进行复杂处理的事务中，行级锁可以锁定这些行，防止在事务处理过程中数据被其他事务修改</li></ul><h3 id="5、注意事项"><a href="#5、注意事项" class="headerlink" title="5、注意事项"></a>5、注意事项</h3><ul><li>由于行级锁的锁定粒度较小，它可能会消耗更多的系统资源（如内存和CPU），特别是在处理大量数据时</li><li>使用行级锁可能会导致死锁，需要使用合适的策略来避免死锁（如在事务中按照一定顺序锁定行）</li></ul><h3 id="6、MySQL哪些命令会发生行级锁"><a href="#6、MySQL哪些命令会发生行级锁" class="headerlink" title="6、MySQL哪些命令会发生行级锁"></a>6、MySQL哪些命令会发生行级锁</h3><table><thead><tr><th>MySQL命令</th><th>添加锁类型</th></tr></thead><tbody><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td></tr><tr><td>INSERT</td><td>排它锁</td></tr><tr><td>UPDATE</td><td>排它锁</td></tr><tr><td>DELETE</td><td>排它锁</td></tr></tbody></table><h3 id="7、行锁有哪些风险点？"><a href="#7、行锁有哪些风险点？" class="headerlink" title="7、行锁有哪些风险点？"></a>7、行锁有哪些风险点？</h3><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http学习笔记</title>
      <link href="/2023/07/03/http-xue-xi-bi-ji/"/>
      <url>/2023/07/03/http-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、面试题"><a href="#一、面试题" class="headerlink" title="一、面试题"></a>一、面试题</h2><h3 id="1、HTTP-1-0和HTTP-1-1有什么区别？"><a href="#1、HTTP-1-0和HTTP-1-1有什么区别？" class="headerlink" title="1、HTTP/1.0和HTTP/1.1有什么区别？"></a>1、HTTP/1.0和HTTP/1.1有什么区别？</h3><p><strong>参考</strong>：<a href="https://www.cnblogs.com/loren-Yang/p/7490011.html">https://www.cnblogs.com/loren-Yang/p/7490011.html</a><br><a href="https://pythonjishu.com/vuboqpkalikqgml/">https://pythonjishu.com/vuboqpkalikqgml/</a></p><p><strong>长连接和管道机制</strong>：</p><ul><li>HTTP/1.0每次请求都需要重新建立连接，效率低</li><li>HTTP/1.1支持<font color="red">长连接</font>和管道化技术，即在同一个连接上可以发送多个请求，避免重复建立和断开连接的开销，提高了传输效率</li></ul><p><strong>Host字段</strong>：</p><ul><li>HTTP/1.0没有Host头字段（因此默认监听80端口）</li><li>HTTP/1.1引入了Host头字段（用来区分<font color="red">同一个IP地址多个域名</font>，如<a href="http://www.baidu1.com和www.baidu2.com共用111.111.111.111,那么通过host指定特定的域名)/">www.baidu1.com和www.baidu2.com共用111.111.111.111，那么通过Host指定特定的域名）</a></li></ul><p><strong>状态码</strong>：</p><ul><li>HTTP/1.1引入了新状态码100（Continue），用来确认服务端是否能收到请求（节约了带宽，因为如果不确定服务器是否能收到请求，那贸然发送带实体的请求，如果被拒绝就会浪费带宽，所以<font color="red">在正士请求前发送一个只带100Continue的请求</font>）</li></ul><p><strong>方法</strong>：</p><ul><li>HTTP/1.0支持：GET、POST、HEAD</li><li>HTTP/1.1新增：PUT、DELETE、OPTIONS、TRACE、CONNECT</li></ul><h3 id="2、http用哪几种方法？"><a href="#2、http用哪几种方法？" class="headerlink" title="2、http用哪几种方法？"></a>2、http用哪几种方法？</h3><ul><li>GET：<font color="red">请求</font>指定的页面信息，并返回实体本体（暴露在地址栏URL中）</li><li>POST：向指定资源提交要被处理的数据，并返回处理后的结果（一般用于<font color="red">提交表单</font>等较隐私数据）</li><li>PUT：<font color="red">更新</font>指定资源</li><li>DELETE：<font color="red">删除</font>指定资源</li><li>HEAD：类似GET请求，不过返回响应中没有具体的内容，用于<font color="red">获取资源的元信息</font></li><li>OPTIONS：返回<font color="red">服务器支持的HTTP方法</font></li><li>TRACE：<font color="red">回显</font>服务器收到的请求，主要用于测试或诊断（可以回显当前请求头等信息，用于检查请求是否被修改）</li><li>CONNECT：HTTP/1.1协议中预留能够将连接改为管道方式的代理服务器</li></ul><h3 id="3、http有哪些状态码？"><a href="#3、http有哪些状态码？" class="headerlink" title="3、http有哪些状态码？"></a>3、http有哪些状态码？</h3><ul><li><strong>1xx（信息性状态码）</strong>：表示请求已被接受并继续处理<ul><li>100（继续）：表示服务器已经接收到请求头，并且客户端应该继续发送请求头（通常用于POST请求）</li><li>101（切换协议）：…</li></ul></li><li><strong>2xx（成功状态码）</strong>：表示请求已成功被服务器理解并接受<ul><li>200（成功）：表示请求已经成功，并且<font color="red">已返回请求的数据</font></li><li>201（已创建）：表示请求已被服务器接受，并且资源已被创建</li><li>204（无内容）：表示请求已经成功，但是没有返回任何内容</li></ul></li><li><strong>3xx（重定向状态码）</strong>：表示需要客户端采取进一步操作才能完成请求<ul><li>301（永久移动）</li><li>302（临时移动）</li><li>304（未修改）：表示所请求的资源在上次访问之后没有被修改过，客户端可以使用缓存的版本</li></ul></li><li><strong>4xx（客户端错误状态码）</strong>：表示客户端发送的请求错误<ul><li>400（客户端错误请求）：表示请求<font color="red">语法或参数有问题</font>，服务器无法处理</li><li>401（未授权）：表示请求需要身份验证</li><li>403（禁止访问）：表示服务器拒绝请求</li></ul></li><li><strong>5xx（服务器错误状态码）</strong>：表示服务器在处理请求时发生了错误<ul><li>500（服务器内部错误）</li><li>502（错误网关）：表示服务器作为网关或代理，从上游服务器收到的响应无效</li><li>503（服务不可用）：表示服务器暂时无法处理请求（<font color="red">可能是由于过载或维护等原因</font>）</li></ul></li></ul><h2 id="二、常见问题"><a href="#二、常见问题" class="headerlink" title="二、常见问题"></a>二、常见问题</h2><h3 id="1-参数值传yyyy-MM-dd报错-400"><a href="#1-参数值传yyyy-MM-dd报错-400" class="headerlink" title="1.参数值传yyyy-MM-dd报错(400)"></a>1.参数值传yyyy-MM-dd报错(400)</h3><p><strong>解决方案</strong>：改成yyyy/MM/dd<br><img src="/images/Http%E6%8E%A5%E5%8F%A3%E4%BC%A0%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E9%94%99%E8%AF%AF.png" alt="Http接口传时间格式错误"><br><img src="/images/Http%E6%8E%A5%E5%8F%A3%E4%BC%A0%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E6%AD%A3%E7%A1%AE.png" alt="Http接口传时间格式正确"></p><h3 id="2-参数值直接传json报错-400"><a href="#2-参数值直接传json报错-400" class="headerlink" title="2.参数值直接传json报错(400)"></a>2.参数值直接传json报错(400)</h3><p><strong>例子</strong>：{“id”:3,”name”:”gary”}<br><strong>原因</strong>：Http Get和Post请求不能传包含<code>{</code>、<code>}</code>等这类特殊字符<br><strong>解决方案</strong>：需要对特殊字符进行转义，如<code>"</code>转成<code>%22</code>,<code>{</code>转成<code>%7b</code>等<br><strong>在线转义</strong>：<a href="http://www.jsons.cn/urlencode/">http://www.jsons.cn/urlencode/</a><br><img src="/images/Http%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E8%BD%AC%E4%B9%89.png" alt="Http接口参数转义"></p>]]></content>
      
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2023/07/03/mysql/mysql-suo-yin/"/>
      <url>/2023/07/03/mysql/mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="一、面试题"><a href="#一、面试题" class="headerlink" title="一、面试题"></a>一、面试题</h2><h3 id="1、MySQL索引的优点和缺点是什么？"><a href="#1、MySQL索引的优点和缺点是什么？" class="headerlink" title="1、MySQL索引的优点和缺点是什么？"></a>1、MySQL索引的优点和缺点是什么？</h3><p>MySQL的InnoDB用B+树结构来实现索引和数据的存储<br><strong>优点</strong>：</p><ul><li>B+树是平衡树，用来存储数据，可以大大减少数据检索时的磁盘IO次数，从而提升数据查询的性能</li><li>B+树索引在进行范围查找时更快，因为叶子节点是双向链表，只需要找到起始节点，然后往下遍历读取即可</li><li>通过唯一索引，可以保证每一行数据的唯一性</li></ul><p><strong>缺点</strong>：</p><ul><li>当执行增加、修改、删除操作时，会涉及索引的维护，当数据量较大时，索引的维护会带来较大的性能开销</li><li>索引数不正确创建的话，会导致维护成本过高</li><li>…</li></ul><h3 id="2、为什么索引用B-树-B数，而不用其他数据结构？"><a href="#2、为什么索引用B-树-B数，而不用其他数据结构？" class="headerlink" title="2、为什么索引用B+树/B数，而不用其他数据结构？"></a>2、为什么索引用B+树/B数，而不用其他数据结构？</h3><ul><li>B+树/B树是一种多路平衡树，它的高度相比其他二叉树，会矮很多</li><li>因为数据库数据是存在磁盘上的，而磁盘IO效率很低（尤其是随机磁盘IO），所以树的高度能够决定磁盘IO的次数，磁盘IO次数越少，性能提升就越大</li></ul><h3 id="3、为什么索引用B-树，而不用B树？"><a href="#3、为什么索引用B-树，而不用B树？" class="headerlink" title="3、为什么索引用B+树，而不用B树？"></a>3、为什么索引用B+树，而不用B树？</h3><ul><li><strong>存储数量更多</strong>：B+树非叶子节点不存在数据，所以每一层能存储的索引数量会更多，意味着B+树在层高相同的情况下存储的数据量要比B要多，从而使磁盘IO次数更少</li><li><strong>范围查询更快</strong>：MySQL范围查询是一个频繁操作，而B+树的所有数据都存在叶子节点，用双向链表关联，意味着只需差两个节点进行遍历即可，而B树需要遍历所有节点</li><li><strong>查询稳定</strong>：因为B+树数据都是存在叶子节点，所以IO次数会更加稳定</li><li><strong>全局扫描能力更强</strong>：因为B+树数据都是存在叶子节点，只需要扫描叶子节点的双向链表，而B树需要遍历整个树</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2023/07/03/mysql/mysql-shi-wu/"/>
      <url>/2023/07/03/mysql/mysql-shi-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL的事务隔离级别"><a href="#一、MySQL的事务隔离级别" class="headerlink" title="一、MySQL的事务隔离级别"></a>一、MySQL的事务隔离级别</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>为了解决多个并行事务竞争导致的数据安全问题的一个规范<br>可能会出现的现象：脏读、不可重复读、幻读</p><h3 id="2、脏读"><a href="#2、脏读" class="headerlink" title="2、脏读"></a>2、脏读</h3><p><strong>问题</strong>：两个事务T1/T2同时执行，T1可能会读到T2未提交的数据，但是T2可能会回滚，导致T1读到了错误的数据，产生<font color="red">脏读</font>的现象<br><strong>解决方案</strong>：用<font color="red">读已提交</font>的隔离级别，但还是存在<font color="red">不可重复读</font>和<font color="red">幻读</font><br><img src="/images/mysql/mysql%E8%84%8F%E8%AF%BB.png" alt="mysql脏读"></p><h3 id="3、不可重复读"><a href="#3、不可重复读" class="headerlink" title="3、不可重复读"></a>3、不可重复读</h3><p><strong>问题</strong>：两个事务T1/T2同时执行，T1在不同时刻（比如T2提交前和提交后）读到的数据不一致，导致<font color="red">不可重复读</font>的问题<br><strong>解决方案</strong>：用<font color="red">可重复读</font>的隔离级别，但还是存在<font color="red">幻读</font><br><img src="/images/mysql/mysql%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="mysql不可重复读"></p><h3 id="4、幻读"><a href="#4、幻读" class="headerlink" title="4、幻读"></a>4、幻读</h3><p><strong>问题</strong>：两个事务T1/T2同时执行，T1执行返回查询/范围修改时，T2插入了T1查询范围内的数据并且提交了，T1再次查询/修改时，发现数据多出来一条/没修改成功，看起来像出现了幻觉，即为<font color="red">幻读</font><br><strong>解决方案</strong>：用<font color="red">串行化</font>的隔离级别，但是性能是最低的</p><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul><li><strong>读未提交</strong>：可能会出现脏读、不可重复读、幻读</li><li><strong>读已提交</strong>：可能会出现不可重复读、幻读</li><li><strong>可重复读</strong>：可能会出现幻读（<font color="red">InnoDB不可能</font>），是InnoDB引擎默认的隔离级别，保证了事务ACID特性中的<font color="red">隔离性</font>特征</li><li><strong>串行化</strong>：多个并行事务串行化执行，不会出现安全性问题，但是性能是最低的</li></ul><h2 id="二、MySQL事务特性（ACID）"><a href="#二、MySQL事务特性（ACID）" class="headerlink" title="二、MySQL事务特性（ACID）"></a>二、MySQL事务特性（ACID）</h2><p>参考链接：<a href="https://juejin.cn/post/7153626309338333220">https://juejin.cn/post/7153626309338333220</a></p><ul><li>A（Atomicity）<strong>原子性</strong>：指事务是一个不可分割的工作单位，也就是事务中的操作要么都发生，要么都不发送</li><li>C（Consistency）<strong>一致性</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li>I（Isolation）<strong>隔离性</strong>：事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务的操作及使用的数据对并发的其他事务是隔离的（并发执行的各个事务之间不能相互干扰）</li><li>D（Durability）<strong>持久性</strong>：指一个事务一旦提交，它对数据库的改变就是永久的，不会因为其他操作和数据库故障而有影响</li></ul><p>比如A和B各有1000元，A给B转账500元，对应的语句应该是：<br>update table set A.amount = 500 where name = ‘A’;<br>update table set B.amount = 1500 where name = ‘B’;</p><ul><li>A：要么两个sql都执行，要么都不执行</li><li>C：A和B加起来有2000元，A给B转账500元后，加起来还是2000元，保持一致</li><li>I：A给B转账时，B进行了消费操作，这时候需要等转账事务执行成功或失败后，消费事务才能执行，保证两事务互不干扰</li><li>D：A给B转账成功后，不能再回滚到事务开始前，除非再执行一遍B转账给A</li></ul><p><strong>实现原理</strong>：</p><ul><li>A：<font color="red">undo log日志实现</font>，用于撤销回滚，存储了数据库更新之前的数据</li><li>C：<font color="red">redo log日志实现</font>，用于灾难恢复，存储了修改但未提交的数据，当发生断电等异常灾难时，会通过redo log日志做一个提交恢复</li><li>I：<font color="red">MVCC实现</font>，主要由索引的隐藏列和undo log日志实现，其中索引的隐藏列包含了该行数据的版本号、删除时间、指向undo log的指针等。当读取数据时，mysql根据隐藏列判断是否需要回滚并找到回滚需要的undo log，从而实现MVCC</li><li>D：一致性是事务的最终目标（由前面的A、C、I实现）</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVCC笔记</title>
      <link href="/2023/07/01/mysql/mvcc-bi-ji/"/>
      <url>/2023/07/01/mysql/mvcc-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><ul><li>MVCC机制，全程（Multi-Version Concurrency Control）多版本并发控制，是确保在高并发下，多个事务读取数据时不加锁也可以多次读取相同的值</li><li>MVCC在RC（读已提交）、RR（可重复读）的事务隔离级别下才生效</li><li>MVCC在RR（可重复读）的事务隔离级别下，可以解决脏读、不可重复读等问题</li></ul><h2 id="二、实现原理"><a href="#二、实现原理" class="headerlink" title="二、实现原理"></a>二、实现原理</h2><p>MVCC的实现原理主要依赖于记录中的几个属性实现的：</p><ul><li>三个隐藏字段（即除了我们自定义的字段外，数据库默认的隐式定义字段，也就是存在但无感知）：<ul><li>DB_TRX_ID：即最近修改事务id，<font color="red">记录创建这条记录或最后一次修改该记录的事务id</font> </li><li>DB_ROLL_PTR：即回滚指针，指向这条记录的上一个版本，与undo log配合使用</li><li>DB_ROW_ID：即隐藏主键，如果MySQL表没有主键，那么InnoDB就会自动生成一个row_id</li></ul></li><li>undo log：即回滚日志，记录了数据的历史版本</li><li>read view：即读视图，是<font color="red">事务进行快照读操作时候产生的读视图</font>，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id（事务id是递增的）<ul><li><strong>作用</strong>：当作条件来判断当前事务能够看到哪个版本的数据，有可能是最新的数据，也有可能是当前行记录的undo log中某个版本的数据</li></ul></li></ul><h2 id="三、Read-View详解"><a href="#三、Read-View详解" class="headerlink" title="三、Read View详解"></a>三、Read View详解</h2><h3 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h3><p>Read View包含三个全局属性：</p><ul><li>m_ids：当前活跃的事务编号集合</li><li>min_trx_id：最小活跃事务编号</li><li>max_trx_id：预分配事务编号（当前最大事务编号+1）</li><li>creator_trx_id：ReadView创建者的事务编号</li></ul><h3 id="2、可见性判断规则"><a href="#2、可见性判断规则" class="headerlink" title="2、可见性判断规则"></a>2、可见性判断规则</h3><ul><li>a、首先判断<code>DB_TRX_ID</code>&lt;<code>min_trx_id</code><ul><li><strong>如果成立</strong>：说明当前事务可以看到<code>DB_TRX_ID</code>所在的记录</li><li><strong>如果不成立</strong>：则走下一个判断</li></ul></li><li>b、然后判断<code>DB_TRX_ID</code>&gt;=<code>max_trx_id</code><ul><li><strong>如果成立</strong>：说明当前事务不可以看到<code>DB_TRX_ID</code>所在的记录（因为<code>DB_TRX_ID</code>所在的记录是在Read View生成后才出现的，所以不可见） </li><li><strong>如果不成立</strong>：则走下一个判断</li></ul></li><li>c、最后判断<code>DB_TRX_ID</code>存在于<code>m_ids</code><ul><li><strong>如果成立</strong>：说明当前事务不可以看到<code>DB_TRX_ID</code>所在的记录（因为Read View生成时刻，<font color="red">该事务还是活跃状态，没有commit</font>，所以修改的数据，当前事务是不可见的）</li><li><strong>如果不成立</strong>：说明当前事务可以看到<code>DB_TRX_ID</code>所在的记录（因为该事务在Read View生成之前就已经commit，所以修改的数据，当前事务是可见的）</li></ul></li></ul><h3 id="3、RC、RR级别下的InnoDB快照读有什么不同？"><a href="#3、RC、RR级别下的InnoDB快照读有什么不同？" class="headerlink" title="3、RC、RR级别下的InnoDB快照读有什么不同？"></a>3、RC、RR级别下的InnoDB快照读有什么不同？</h3><p>生成时机不同：</p><ul><li>RC是每次进行快照读都会生成一个新的Read View</li><li>RR是只有第一次进行快照读才会生成一个新的Read View（后续快照读都是同一个，所以解决了<font color="red">不可重复读</font>的问题）</li></ul><h3 id="4、快照读和当前读有什么区别？"><a href="#4、快照读和当前读有什么区别？" class="headerlink" title="4、快照读和当前读有什么区别？"></a>4、快照读和当前读有什么区别？</h3><ul><li><strong>快照读</strong>：select</li><li><strong>当前读</strong>：insert、update、delete、select … for update、select … lock in share mode</li></ul><h2 id="四、undo-log详解"><a href="#四、undo-log详解" class="headerlink" title="四、undo log详解"></a>四、undo log详解</h2><h3 id="1、如果undo-log被删除了，版本链不就断了吗？"><a href="#1、如果undo-log被删除了，版本链不就断了吗？" class="headerlink" title="1、如果undo log被删除了，版本链不就断了吗？"></a>1、如果undo log被删除了，版本链不就断了吗？</h3><p>undo log版本链不是立即删除，MySQL确保版本链数据不再被<font color="red">引用</font>后再进行删除</p><p>//TODO</p><h2 id="五、问题"><a href="#五、问题" class="headerlink" title="五、问题"></a>五、问题</h2><h3 id="1、RR隔离级别下使用MVCC能避免幻读吗？"><a href="#1、RR隔离级别下使用MVCC能避免幻读吗？" class="headerlink" title="1、RR隔离级别下使用MVCC能避免幻读吗？"></a>1、RR隔离级别下使用MVCC能避免幻读吗？</h3><p>能，但不完全能。RR用的是快照读，仅第一次生成，后面使用的ReadView会复用第一次的<br><strong>特例</strong>：当两次<font color="red">快照读</font>之间存在<font color="red">当前读</font>，ReadView会重新生成，从而产生幻读</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL日志篇</title>
      <link href="/2023/06/27/mysql/mysql-ri-zhi-pian/"/>
      <url>/2023/06/27/mysql/mysql-ri-zhi-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="一、常见的日志类型"><a href="#一、常见的日志类型" class="headerlink" title="一、常见的日志类型"></a>一、常见的日志类型</h2><ul><li>错误日志(error log)：对MySQL的启动、运行和关闭进行了记录</li><li><strong>二进制文件</strong>(binary log/binlog)：记录了更改数据库数据的SQL语句（不包括select、show等查询语句）</li><li>一般查询日志(general query log)：记录客户端发送给MySQL服务器的所有SQL语句（因为量很大，所以默认不开启，也不建议开启）</li><li>慢日志查询(slow query log)：执行时间超过<code>long_query_time</code>的语句（一般排查慢查询问题的时候用到）</li><li><strong>事务日志</strong>(redo log和undo log)：redo log是重做日志，undo log是回滚日志</li><li>中继日志(relay log)：relay log是复制过程中的日志，跟binary log猜不到，不过relay log针对的是主从复制中的从库</li><li>DDL日志(metadata log)：DDL语句执行的与数据操作</li></ul><h2 id="二、binlog介绍"><a href="#二、binlog介绍" class="headerlink" title="二、binlog介绍"></a>二、binlog介绍</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p><strong>定义</strong>：binlog（即binary log，二进制日志文件），记录了对MySQL数据库执行了更改的所有操作（所有DDL和DML语句）</p><ul><li>DDL（即数据定义语句）：包括create、alter、drop等</li><li>DML（即数据修改语句）：包括insert、update、delete等</li></ul><p><strong>模式</strong>：</p><ul><li><strong>Statement模式</strong>：只记录DML语句（MySQL 5.7.7之前默认使用）</li><li><strong>Row模式</strong>：记录DDL+DML语句（MySQL 5.7.7之后默认使用）</li><li><strong>Mixed模式</strong>：Statement模式+Row模式组合（默认使用Statement模式，少数情况下自动切到Row模式）</li><li>如何查看使用的模式：<code>show variables like </code>%binlog_format%<code>;</code></li><li>*场景<strong>：</strong>主从复制**，<font color="red">依赖binlog去同步数据，保证数据一致性</font></li></ul><h3 id="2、主从复制"><a href="#2、主从复制" class="headerlink" title="2、主从复制"></a>2、主从复制</h3><p><strong>参考文档</strong>：<a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html">https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html</a><br><strong>原理图</strong>：<br> <img src="/images/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png"><br><strong>步骤</strong>：</p><ol><li>主库将数据变化写入binlog</li><li>从库连接主库</li><li>从库创建一个I/O线程请求主库的binlog</li><li>主库创建一个binlog dump线程来发送binlog，从库的I/O线程负责接收</li><li>从库的I/O线程把接收到的binlog写入到relay log</li><li>从库的SQL线程读取relay log数据到本地（也就是再执行一遍SQL）</li></ol><h3 id="3、binlog什么时候写入？"><a href="#3、binlog什么时候写入？" class="headerlink" title="3、binlog什么时候写入？"></a>3、binlog什么时候写入？</h3><ul><li>对于InnoDB存储而言，在执行一个事务时，会把日志写到binlog cache，等事务完成了再把binlog cache的日志持久化到binlog中，这样做也是为了考虑性能</li><li><strong>为什么要有binlog cache呢？</strong>因为一个事务的binlog不能被拆开，无论这个事务多大，都要保证一次性写入，所以才会有binlog cache的存在，我们可以通过设置<code>binlog_cache_size</code>来控制单个线程binlog cache的大小（如果超过改大小，就要<font color="red">暂存到磁盘中</font>）</li><li><strong>binlog是什么时候刷新到磁盘中的？</strong>可以通过sync_binlog来控制binlog的刷盘时机：<code>show variables like 'sync_binlog'</code><ul><li>sync_binlog=0：不强制要求，由系统自行判断刷盘时机（MySQL5.7之前的默认值）</li><li>sync_binlog=1：每次提交事务的时候都会刷盘（MySQL5.7之后的默认值）</li><li>sync_binlog=N：每N个事务，才会刷盘</li><li>设置建议：不建议设置为0，如果对性能要求比较高/出现I/O瓶颈的画，可以适当增大sync_binlog，不过这样会增加数据丢失的可能（因为间隔变久了）</li></ul></li></ul><h3 id="4、什么时候会重新生成binlog？"><a href="#4、什么时候会重新生成binlog？" class="headerlink" title="4、什么时候会重新生成binlog？"></a>4、什么时候会重新生成binlog？</h3><p>下面这几个情况，MySQL会重新生成新的binlog，并且序号递增：</p><ul><li>MySQL停止或重启</li><li>使用<code>flush logs</code>命令后</li><li>binlog文件大小超过<code>max_binlog_size</code>变量的阈值后</li></ul><h2 id="三、redo-log介绍"><a href="#三、redo-log介绍" class="headerlink" title="三、redo log介绍"></a>三、redo log介绍</h2><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><ul><li>InnoDB引擎是以页（数据页）为单位来存储数据的，也就是我们往MySQL插入的所有数据最终都会写入到这个页中</li><li>为了减少IO开销，中间会有一个Buffer Pool的区域存在内存中，如果Buffer Pool中没有我们想要的数据，MySQL就会把页中的数据缓存到Buffer Pool中，这样我们就直接操作缓存即可，<font color="red">大大提高了读写性能</font></li></ul><h3 id="2、Buffer-Pool存在带来的问题"><a href="#2、Buffer-Pool存在带来的问题" class="headerlink" title="2、Buffer Pool存在带来的问题"></a>2、Buffer Pool存在带来的问题</h3><p>如果一个事务提交了，在Buffer Pool没来得及刷新（即持久化）回磁盘，MySQL就突然宕机了，这时候这个事务就消失了呢？结论是不会的，这样就违反了事务的持久性。<font color="red">MySQL InnoDB引擎用redo log来保证事务的持久性</font></p><h3 id="3、redo-log是什么？"><a href="#3、redo-log是什么？" class="headerlink" title="3、redo log是什么？"></a>3、redo log是什么？</h3><ul><li><font color="red">redo log是InnoDB引擎独有的，用来保证事务的持久性</font></li><li>主要是记录页的修改，比如哪个页某个偏移量处修改了几个字节的值以及具体被修改的值是什么</li><li>redo log的每一条记录包括：<ul><li>表空间号</li><li>数据页号</li><li>偏移量</li><li>具体修改的数据</li></ul></li></ul><h3 id="4、redo-log有什么用？"><a href="#4、redo-log有什么用？" class="headerlink" title="4、redo log有什么用？"></a>4、redo log有什么用？</h3><p>在事务提交时，我们会将redo log按照刷盘策略刷到磁盘上去，这样即使MySQL宕机了，重启之后也能恢复没有写入磁盘的数据，从而保证数据的持久性</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分页插件PageHelper的使用</title>
      <link href="/2022/10/19/fen-ye-cha-jian-pagehelper-de-shi-yong/"/>
      <url>/2022/10/19/fen-ye-cha-jian-pagehelper-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>插件地址：<a href="https://github.com/pagehelper/Mybatis-PageHelper/">https://github.com/pagehelper/Mybatis-PageHelper/</a><br><strong>//TODO</strong></p><h2 id="二、怎么使用？"><a href="#二、怎么使用？" class="headerlink" title="二、怎么使用？"></a>二、怎么使用？</h2><h3 id="1-引入依赖-maven"><a href="#1-引入依赖-maven" class="headerlink" title="1.引入依赖(maven)"></a>1.引入依赖(maven)</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>{pagehelper.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是springboot项目，则改成引入</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>pagehelper-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>{springbootPagehelperVersion}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-参数介绍"><a href="#2-参数介绍" class="headerlink" title="2.参数介绍"></a>2.参数介绍</h3><p><strong>//TODO</strong></p><h3 id="3-如何在代码中使用"><a href="#3-如何在代码中使用" class="headerlink" title="3.如何在代码中使用"></a>3.如何在代码中使用</h3><p><strong>//TODO</strong></p><h2 id="三、Q-amp-A"><a href="#三、Q-amp-A" class="headerlink" title="三、Q&amp;A"></a>三、Q&amp;A</h2><h3 id="1-springboot使用PageHelper分页不生效怎么办？"><a href="#1-springboot使用PageHelper分页不生效怎么办？" class="headerlink" title="1.springboot使用PageHelper分页不生效怎么办？"></a>1.springboot使用PageHelper分页不生效怎么办？</h3><p>正常分页使用</p><pre class="line-numbers language-none"><code class="language-none">PageHelper.startPage(pageNo,pageSize)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>排查后发现pom依赖错了，springboot环境下要用</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>pagehelper-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>{springbootPageHelper.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而不是原来的</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>{pageHelper.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为上面的依赖缺少了</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.pagehelper<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>pagehelper-spring-boot-autoconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、Mybatis-Plus如何使用分页插件？"><a href="#四、Mybatis-Plus如何使用分页插件？" class="headerlink" title="四、Mybatis-Plus如何使用分页插件？"></a>四、Mybatis-Plus如何使用分页插件？</h2><p><strong>//TODO</strong></p>]]></content>
      
      
      <categories>
          
          <category> PageHelper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> PageHelper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo使用笔记</title>
      <link href="/2022/10/16/dubbo-shi-yong-bi-ji/"/>
      <url>/2022/10/16/dubbo-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1-项目启动时出现循环依赖-A依赖B，B依赖A-，哪一方启动都会报错找不到消费者，如何解决？"><a href="#1-项目启动时出现循环依赖-A依赖B，B依赖A-，哪一方启动都会报错找不到消费者，如何解决？" class="headerlink" title="1.项目启动时出现循环依赖(A依赖B，B依赖A)，哪一方启动都会报错找不到消费者，如何解决？"></a>1.项目启动时出现循环依赖(A依赖B，B依赖A)，哪一方启动都会报错找不到消费者，如何解决？</h3><p><strong>分析</strong>：Dubbo默认会在启动时检查依赖的服务是否可用，不可用时会抛出异常(No provider…)<br><strong>解决</strong>：关闭启动时依赖检查</p><ul><li><strong>方案a：配置spring配置文件</strong><ul><li>关闭某个服务的启动时检查(没有提供者时报错)<br><code>&lt;dubbo:reference interface="com.demo.UserService" check="false" /&gt;</code></li><li>关闭所有服务的启动时检查(没有提供者时报错)<br><code>&lt;dubbo:consumer check="false" /&gt;</code></li><li>关闭注册中心启动时检查(注册订阅失败时报错)<br><code>&lt;dubbo:registry check="false" /&gt;</code></li></ul></li><li><strong>方案b：配置dubbo.properties</strong><pre class="line-numbers language-none"><code class="language-none">dubbo.reference.com.demo.UserService.check=falsedubbo.reference.check=falsedubbo.consumer.check=falsedubbo.registry.check=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>方案c：配置<code>-D</code>参数</strong><pre class="line-numbers language-none"><code class="language-none">java -Ddubbo.reference.com.demo.UserService.check=falsejava -Ddubbo.reference.check=falsejava -Ddubbo.consumer.check=false java -Ddubbo.registry.check=false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java工具类</title>
      <link href="/2022/10/16/java-gong-ju-lei/"/>
      <url>/2022/10/16/java-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="一、Q-amp-A"><a href="#一、Q-amp-A" class="headerlink" title="一、Q&amp;A"></a>一、Q&amp;A</h2><h3 id="1-http接口想返回自定义格式字符串-原Date类型-，如输出”2022-10-16-20-00-00”"><a href="#1-http接口想返回自定义格式字符串-原Date类型-，如输出”2022-10-16-20-00-00”" class="headerlink" title="1.http接口想返回自定义格式字符串(原Date类型)，如输出”2022-10-16 20:00:00”"></a>1.http接口想返回自定义格式字符串(原Date类型)，如输出”2022-10-16 20:00:00”</h3><ul><li><strong>方法</strong>：添加注解<code>@JsonFormat</code></li><li><strong>用途</strong>：将Date转换成String，一般是后台传值给前台<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@JsonFormat</span><span class="token punctuation">(</span>pattern <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">,</span> timezone<span class="token operator">=</span><span class="token string">"GMT+8"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> startTime<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="2-http接口想接收自定义格式字符串-新Date类型-，如输入”2022-10-16-20-00-00”"><a href="#2-http接口想接收自定义格式字符串-新Date类型-，如输入”2022-10-16-20-00-00”" class="headerlink" title="2.http接口想接收自定义格式字符串(新Date类型)，如输入”2022-10-16 20:00:00”"></a>2.http接口想接收自定义格式字符串(新Date类型)，如输入”2022-10-16 20:00:00”</h3><ul><li><strong>方法</strong>：添加注解<code>@DateTimeFormat</code></li><li><strong>用途</strong>：将String转换成Date，一般是前台传值给后台<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@DateTimeFormat</span><span class="token punctuation">(</span>pattern <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> startTime<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
            <tag> Java </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2022/03/17/algorithm/suan-fa/"/>
      <url>/2022/03/17/algorithm/suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E9%93%BE%E8%A1%A8/">点此跳转</a></li><li><strong>总结</strong>：<ul><li>1.善用<code>遍历</code></li></ul></li></ul><h2 id="二、深度优先搜索"><a href="#二、深度优先搜索" class="headerlink" title="二、深度优先搜索"></a>二、深度优先搜索</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">点此跳转</a></li><li><strong>经典例子</strong>：<a href="../../../../../2021/12/22/algorithm/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">从前序与中序遍历序列构造二叉树</a></li><li><strong>步骤</strong>：<ul><li>1.定义一个<code>深度优先搜索</code>的函数<code>dfs()</code></li><li>2.判断结束条件：<code>边界</code>和逻辑中止(如遇到当前值为1中止)</li><li>3.执行搜索逻辑：如更新当前值等</li><li>4.蔓延：前后左右执行<code>dfs()</code></li></ul></li><li><strong>总结</strong>：<ul><li>1.看到题干有<code>蔓延</code>等同义词优先考虑<code>深度优先搜索</code></li><li>2.注意<code>边界</code>处理</li></ul></li></ul><h2 id="三、移动窗口"><a href="#三、移动窗口" class="headerlink" title="三、移动窗口"></a>三、移动窗口</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3/">点此跳转</a></li><li><strong>总结</strong>：<ul><li>1.该类型做得少，需要<code>重做</code>/<code>多做</code></li><li>2.注意<code>边界</code>处理</li></ul></li></ul><h2 id="四、双指针"><a href="#四、双指针" class="headerlink" title="四、双指针"></a>四、双指针</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%8F%8C%E6%8C%87%E9%92%88/">点此跳转</a></li><li><strong>思路</strong>：一个指针遍历，一个指针指向某个值(比如需要交换的值)</li><li><strong>总结</strong>：<ul><li>1.该类型做得少，需要<code>重做</code>/<code>多做</code></li></ul></li></ul><h2 id="五、二分查找"><a href="#五、二分查找" class="headerlink" title="五、二分查找"></a>五、二分查找</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">点此跳转</a></li><li><strong>思路</strong>：<ul><li>1.定义头尾指针<code>left</code>和<code>right</code></li><li>2.while循环每次取中间值<code>middle</code>=<code>left</code>+(<code>right</code>-<code>left</code>)/2</li><li>3.直到<code>middle</code>等于结果值则结束</li></ul></li><li><strong>总结</strong>： <ul><li>1.定义好二分查找的<code>left</code>、<code>right</code>、<code>middle</code>变量即可</li></ul></li></ul><h2 id="六、回溯算法"><a href="#六、回溯算法" class="headerlink" title="六、回溯算法"></a>六、回溯算法</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">点此跳转</a></li><li><strong>经典例子</strong>：<a href="../../../../../2021/12/24/algorithm/%E5%85%A8%E6%8E%92%E5%88%97/">全排列</a></li><li><strong>思路</strong>：<ul><li>1.定义<code>path</code>记录路径，<code>result</code>记录结果，<code>selected</code>记录选择列表</li><li>2.<strong>结束条件</strong>：到达决策数底层，无法再做选择</li><li>3.通过做选择和撤销选择实现决策树的回溯</li></ul></li><li><strong>总结</strong>： <ul><li>1.题干有<code>结束条件</code>的一般要想到<code>回溯</code></li><li>2.该类型做得少，需要<code>重做</code>/<code>多做</code></li></ul></li></ul><h2 id="七、前缀和"><a href="#七、前缀和" class="headerlink" title="七、前缀和"></a>七、前缀和</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%89%8D%E7%BC%80%E5%92%8C/">点此跳转</a></li><li><strong>经典例子</strong>：<a href="../../../../../2021/12/26/algorithm/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/">和为K的子数组</a></li><li><strong>总结</strong>： <ul><li>1.用来解决双重遍历时间复杂度很高的问题，引入<code>前缀和</code>，可以避免多次不必要的计算</li></ul></li></ul><h2 id="八、排序"><a href="#八、排序" class="headerlink" title="八、排序"></a>八、排序</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E6%8E%92%E5%BA%8F/">点此跳转</a></li></ul><h2 id="九、动态规划"><a href="#九、动态规划" class="headerlink" title="九、动态规划"></a>九、动态规划</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">点此跳转</a></li><li><strong>思路</strong>：todo</li></ul><h2 id="十、单调栈"><a href="#十、单调栈" class="headerlink" title="十、单调栈"></a>十、单调栈</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%8D%95%E8%B0%83%E6%A0%88/">点此跳转</a></li></ul><h2 id="十一、分治算法"><a href="#十一、分治算法" class="headerlink" title="十一、分治算法"></a>十一、分治算法</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/">点此跳转</a></li><li><strong>思路</strong>：todo</li><li><strong>经典例子</strong>：<a href="../../../../../2021/12/22/algorithm/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">从前序与中序遍历序列构造二叉树</a></li></ul><h2 id="十二、广度优先搜索"><a href="#十二、广度优先搜索" class="headerlink" title="十二、广度优先搜索"></a>十二、广度优先搜索</h2><ul><li><strong>链接</strong>：<a href="../../../../../tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">点此跳转</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 目录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目创建方式</title>
      <link href="/2022/03/02/vue-xiang-mu-chuang-jian-fang-shi/"/>
      <url>/2022/03/02/vue-xiang-mu-chuang-jian-fang-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关链接"><a href="#一、相关链接" class="headerlink" title="一、相关链接"></a>一、相关链接</h2><p>参考链接：<a href="https://blog.csdn.net/ccf19881030/article/details/105358242">https://blog.csdn.net/ccf19881030/article/details/105358242</a></p><h2 id="二、创建步骤"><a href="#二、创建步骤" class="headerlink" title="二、创建步骤"></a>二、创建步骤</h2><h3 id="1-全局安装vue-cli脚手架"><a href="#1-全局安装vue-cli脚手架" class="headerlink" title="1.全局安装vue-cli脚手架"></a>1.全局安装vue-cli脚手架</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install vue-cli -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-开始创建项目"><a href="#2-开始创建项目" class="headerlink" title="2.开始创建项目"></a>2.开始创建项目</h3><ul><li><p>使用vue初始化基于webpack的新项目</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vue init webpack test-project<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建过程中会提示是否安装eslint，可以跳过不安装(否则项目编译过程中会出现各种代码格式的问题)</p></li><li><p>创建完成后，安装基础模块</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd test-projectnpm install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>安装完成后，可在开发模式下运行项目并预览项目效果</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><img src="/images/Vue%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F1.png" alt="运行成功"></p><ul><li>访问<a href="http://localhost:8080/">http://localhost:8080</a><br><img src="/images/Vue%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2.png" alt="项目效果"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB使用笔记</title>
      <link href="/2022/02/21/mongodb-shi-yong-bi-ji/"/>
      <url>/2022/02/21/mongodb-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><a href="https://www.runoob.com/mongodb/mongodb-window-install.html">https://www.runoob.com/mongodb/mongodb-window-install.html</a></p><h2 id="二、可视化工具"><a href="#二、可视化工具" class="headerlink" title="二、可视化工具"></a>二、可视化工具</h2><p>下载链接：<a href="https://robomongo.org/download">https://robomongo.org/download</a><br>使用指引：<a href="https://blog.csdn.net/wangmx1993328/article/details/82628805">https://blog.csdn.net/wangmx1993328/article/details/82628805</a></p><h2 id="三、常见指令-随用随更新"><a href="#三、常见指令-随用随更新" class="headerlink" title="三、常见指令(随用随更新)"></a>三、常见指令(随用随更新)</h2><h3 id="1-查询文档"><a href="#1-查询文档" class="headerlink" title="1.查询文档"></a>1.查询文档</h3><p>如查询collection为user的uid为123456的文档，则<br>完整：<code>db.getCollection("user").find({"user":123456})</code><br>简化：<code>db.user.find({"user":123456})</code></p><h2 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h2><h3 id="1-linux如何连接mongo？"><a href="#1-linux如何连接mongo？" class="headerlink" title="1.linux如何连接mongo？"></a>1.linux如何连接mongo？</h3><ul><li>a.下载mongo指令<br><code>wget https://fastdl.mongodb.org/linux/mongodb-shell-linux-x86_64-ubuntu1604-4.0.28.tgz</code></li><li>b.解压<br><code>tar zxvf mongodb-shell-linux-x86_64-ubuntu1604-4.0.28.tgz</code></li><li>c.跳转到指令目录<br><code>cd mongodb-linux-x86_64-ubuntu1604-4.0.28/bin</code></li><li>d.连接<br><code>mongo --host ${host} --port ${port} -u ${username} -p ${password}" </code></li></ul><h3 id="2-linux如何导出mongo数据？"><a href="#2-linux如何导出mongo数据？" class="headerlink" title="2.linux如何导出mongo数据？"></a>2.linux如何导出mongo数据？</h3><ul><li>a.下载mongoexport指令<br><code>wget https://fastdl.mongodb.org/tools/db/mongodb-database-tools-rhel70-x86_64-100.3.1.tgz</code></li><li>b.解压<br><code>tar zxvf mongodb-database-tools-rhel70-x86_64-100.3.1.tgz</code></li><li>c.跳转到指令目录<br><code>cd mongodb-database-tools-rhel70-x86_64-100.3.1/bin</code></li><li>d.导出数据<br><code>mongoexport -d ${database} -c ${collection} -q ${queryJson} --out ${exportFilePath}</code><ul><li><strong>导出类型</strong>：<code>--type</code>默认是<code>json</code>，对应的<code>--out</code>需要是<code>.json</code>后缀，<code>--type</code>也可以是<code>csv</code>，对应的<code>--out</code>需要是<code>.csv</code>后缀.csv类型必须指定导出字段<code>--fields</code></li><li><strong>查询语句</strong>：必须是json语句，且外层用单引号，如<code>-q '{"uid":123456}''</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206. 反转链表</title>
      <link href="/2022/01/09/algorithm/fan-zhuan-lian-biao/"/>
      <url>/2022/01/09/algorithm/fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你单链表的头节点<code>head</code>，请你反转链表，并返回反转后的链表。</p><p><strong>示例一</strong>：<br><img src="/images/algorithm/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A81.png"></p><blockquote><p><strong>输入</strong>：head = [1,2,3,4,5]<br><strong>输出</strong>：[5,4,3,2,1]</p></blockquote><p><strong>示例二</strong>：<br><img src="/images/algorithm/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82.png"></p><blockquote><p><strong>输入</strong>：head = [1,2]<br><strong>输出</strong>：[2,1]</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>：head = []<br><strong>输出</strong>：[]</p></blockquote><p><strong>提示</strong>：</p><ul><li>链表中节点的数目范围是<code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode-solution-d1k2/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：链表</li><li><strong>思路</strong>：遍历链表，并同时将当前的结点反转</li><li><strong>步骤</strong>：以1-&gt;2-&gt;3-&gt;4-&gt;5为例<ul><li>1.定义<code>tail</code>作为反转后链表的最后一个结点</li><li>2.遍历<code>head</code>直到null<ul><li>a.局部变量<code>next</code>存放<code>head</code>的下一个结点<code>head.next</code></li><li>b.<code>head</code>指向反转链表的头结点<code>tail</code></li><li>c.重置<code>tail</code>为<code>head</code></li><li>d.重置<code>head</code>为<code>next</code>(a步骤)</li></ul></li><li>3.输出<code>tail</code></li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//思路：拿到下一个结点后反转当前结点(最后指向tail)</span>    <span class="token class-name">ListNode</span> tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//例子：1-&gt;2-&gt;3-&gt;4-&gt;5</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//获取head后面的结点(如1-&gt;2)</span>      <span class="token class-name">ListNode</span> next  <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token comment">//重置head的next(反转，1-&gt;null)</span>      head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>      <span class="token comment">//重置tail的位置(为上一句head)</span>      tail <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token comment">//重置head为后面的结点(如1-&gt;2)</span>      head <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tail<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、执行结果"><a href="#五、执行结果" class="headerlink" title="五、执行结果"></a>五、执行结果</h2><p><strong>执行结果</strong>：<code>通过</code><br><strong>执行用时</strong>：<code>0 ms</code>, 在所有<code>Java</code>提交中击败了<code>100.00%</code>的用户<br><strong>内存消耗</strong>：<code>38.4 MB</code>, 在所有<code>Java</code>提交中击败了<code>20.41%</code>的用户<br><strong>通过测试用例</strong>：<code>28/28</code></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li><strong>难度</strong>：简单</li><li><strong>总结</strong>：典型的链表算法，相关next操作比较容易混，建议画图（一开始没画图导致有些许步骤混淆，有必要记录）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 简单难度 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>695. 岛屿的最大面积</title>
      <link href="/2022/01/07/algorithm/dao-yu-de-zui-da-mian-ji/"/>
      <url>/2022/01/07/algorithm/dao-yu-de-zui-da-mian-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695.岛屿的最大面积"></a>695.岛屿的最大面积</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个大小为<code>m x n</code>的二进制矩阵<code>grid</code>。</p><p><strong>岛屿</strong>是由一些相邻的<code>1</code>(代表土地)构成的组合，这里的「相邻」要求两个<code>1</code>必须在<strong>水平或者竖直的四个方向上</strong>相邻。你可以假设<code>grid</code>的四个边缘都被<code>0</code>（代表水）包围着。</p><p>岛屿的面积是岛上值为<code>1</code>的单元格的数目。</p><p>计算并返回<code>grid</code>中最大的岛屿面积。如果没有岛屿，则返回面积为<code>0</code>。</p><p><strong>示例一</strong>：<br><img src="/images/algorithm/%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF.png"></p><blockquote><p><strong>输入</strong>：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br><strong>输出</strong>：6<br><strong>解释</strong>：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：grid = [[0,0,0,0,0,0,0,0]]<br><strong>输出</strong>：0</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 50</code></li><li><code>grid[i][j]</code>为<code>0</code>或<code>1</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/max-area-of-island/">https://leetcode-cn.com/problems/max-area-of-island/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/max-area-of-island/solution/biao-zhun-javadong-tai-gui-hua-jie-fa-100-by-mark-/">https://leetcode-cn.com/problems/max-area-of-island/solution/biao-zhun-javadong-tai-gui-hua-jie-fa-100-by-mark-/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：深度优先遍历</li><li><strong>思路</strong>：<ul><li>参考<a href="https://garyleeeee.github.io/2022/01/06/algorithm/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/">733.图像渲染</a></li><li>遍历数组，每次进行dfs，返回值判断最大值</li><li>岛屿相连的为1则是同一个岛屿，需要+1，并把该岛屿置为0(防止重复计算)</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxAreaOfIsland</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxArea <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//遍历m x n，遇到1的就遍历四个方向，遍历过的就重置为0，防止重新遍历到</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>m<span class="token operator">&lt;</span>grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>m<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>n<span class="token operator">&lt;</span>grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//每遍历一次就判断是不是更大的岛屿</span>                maxArea <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxArea<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>m<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxArea<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> grid<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> area <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> y<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> x<span class="token operator">&gt;</span>grid<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> y<span class="token operator">&gt;</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//该位置不是岛屿，返回0</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//计算岛屿面积，并重置grid</span>        area<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>        grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//看看有没有(上下左右)连接的岛屿</span>        area <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        area <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        area <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        area <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> area<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、执行结果"><a href="#五、执行结果" class="headerlink" title="五、执行结果"></a>五、执行结果</h2><p><strong>执行结果</strong>：<code>通过</code><br><strong>执行用时</strong>：<code>2 ms</code>, 在所有<code>Java</code>提交中击败了<code>99.78%</code>的用户<br><strong>内存消耗</strong>：<code>38.9 MB</code>, 在所有<code>Java</code>提交中击败了<code>52.10%</code>的用户<br><strong>通过测试用例</strong>：<code>728/728</code></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li><strong>难度</strong>：简单，看一眼题解发现跟之前题目相似思路和解法</li><li><strong>总结</strong>：跟<a href="https://garyleeeee.github.io/2022/01/06/algorithm/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/">733.图像渲染</a>思路一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>733. 图像渲染</title>
      <link href="/2022/01/06/algorithm/tu-xiang-xuan-ran/"/>
      <url>/2022/01/06/algorithm/tu-xiang-xuan-ran/</url>
      
        <content type="html"><![CDATA[<h1 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733.图像渲染"></a>733.图像渲染</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p><p>给你一个坐标<code>(sr, sc)</code>表示图像渲染开始的像素值（行 ，列）和一个新的颜色值<code>newColor</code>，让你重新上色这幅图像。</p><p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p><p>最后返回经过上色渲染后的图像。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>:<br>image = [[1,1,1],[1,1,0],[1,0,1]]<br>sr = 1, sc = 1, newColor = 2<br><strong>输出</strong>: [[2,2,2],[2,2,0],[2,0,1]]<br><strong>解析</strong>:<br>在图像的正中间，(坐标(sr,sc)=(1,1)),<br>在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，<br>因为它不是在上下左右四个方向上与初始点相连的像素点。</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>image</code>和<code>image[0]</code>的长度在范围<code>[1, 50]</code>内。</li><li>给出的初始点将满足<code>0 &lt;= sr &lt; image.length</code>和<code>0 &lt;= sc &lt; image[0].length</code>。</li><li><code>image[i][j]</code>和<code>newColor</code>表示的颜色值在范围<code>[0, 65535]</code>内。</li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/flood-fill/">https://leetcode-cn.com/problems/flood-fill/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/">https://leetcode-cn.com/problems/flood-fill/solution/tu-xiang-xuan-ran-by-leetcode-solution/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：深度优先遍历</li><li><strong>思路</strong>：看到蔓延就想到是广度/深度优先遍历，因为蔓延上下左右都是同理的</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">floodFill</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> image<span class="token punctuation">,</span> <span class="token keyword">int</span> sr<span class="token punctuation">,</span> <span class="token keyword">int</span> sc<span class="token punctuation">,</span> <span class="token keyword">int</span> newColor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//渲染前的颜色(不会变)</span>    <span class="token keyword">int</span> needFillOldColor <span class="token operator">=</span> image<span class="token punctuation">[</span>sr<span class="token punctuation">]</span><span class="token punctuation">[</span>sc<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>needFillOldColor <span class="token operator">==</span> newColor<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//前后颜色相同，不用蔓延了</span>      <span class="token keyword">return</span> image<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span>sr<span class="token punctuation">,</span>sc<span class="token punctuation">,</span>newColor<span class="token punctuation">,</span>needFillOldColor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> image<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> image<span class="token punctuation">,</span> <span class="token keyword">int</span> sr<span class="token punctuation">,</span> <span class="token keyword">int</span> sc<span class="token punctuation">,</span> <span class="token keyword">int</span> newColor<span class="token punctuation">,</span> <span class="token keyword">int</span> needFillOldColor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//边界判断</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>sr <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> sc <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> sr <span class="token operator">&gt;</span> image<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> sc <span class="token operator">&gt;</span> image<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> needFillOldColor <span class="token operator">!=</span> image<span class="token punctuation">[</span>sr<span class="token punctuation">]</span><span class="token punctuation">[</span>sc<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//不再蔓延</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">//染色</span>    image<span class="token punctuation">[</span>sr<span class="token punctuation">]</span><span class="token punctuation">[</span>sc<span class="token punctuation">]</span> <span class="token operator">=</span> newColor<span class="token punctuation">;</span>    <span class="token comment">//蔓延</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span>sr<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>sc<span class="token punctuation">,</span>newColor<span class="token punctuation">,</span>needFillOldColor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//左</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span>sr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>sc<span class="token punctuation">,</span>newColor<span class="token punctuation">,</span>needFillOldColor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//右</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span>sr<span class="token punctuation">,</span>sc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>newColor<span class="token punctuation">,</span>needFillOldColor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//下</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span>sr<span class="token punctuation">,</span>sc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>newColor<span class="token punctuation">,</span>needFillOldColor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、执行结果"><a href="#五、执行结果" class="headerlink" title="五、执行结果"></a>五、执行结果</h2><p><strong>执行结果</strong>：<code>通过</code><br><strong>执行用时</strong>：<code>0 ms</code>, 在所有<code>Java</code>提交中击败了<code>100%</code>的用户<br><strong>内存消耗</strong>：<code>39.2 MB</code>, 在所有<code>Java</code>提交中击败了<code>64.99%</code>的用户<br><strong>通过测试用例</strong>：<code>277/277</code></p><h2 id="六、测试用例不通过记录"><a href="#六、测试用例不通过记录" class="headerlink" title="六、测试用例不通过记录"></a>六、测试用例不通过记录</h2><h3 id="1-没有对特殊情况做判断-边界"><a href="#1-没有对特殊情况做判断-边界" class="headerlink" title="1.没有对特殊情况做判断(边界)"></a>1.没有对特殊情况做判断(边界)</h3><p><strong>失败用例</strong>： <code>image = [[0,0,0],[0,1,1]], sr = 1, sc = 1, newColor = 1</code><br><strong>错误结果</strong>: <code>java.lang.StackOverflowError</code><br><strong>预期结果</strong>: <code>[[0,0,0],[0,1,1]]</code><br><strong>修改前</strong>：无<br><strong>修改后</strong>：</p><pre class="line-numbers language-none"><code class="language-none">if(needFillOldColor == newColor) {  //前后颜色相同，不用蔓延了  return image;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ul><li><strong>难度</strong>：简单</li><li><strong>总结</strong>：需要注意处理边界值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 简单难度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>567. 字符串的排列</title>
      <link href="/2022/01/05/algorithm/zi-fu-chuan-de-pai-lie/"/>
      <url>/2022/01/05/algorithm/zi-fu-chuan-de-pai-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567.字符串的排列"></a>567.字符串的排列</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你两个字符串<code>s1</code>和<code>s2</code>，写一个函数来判断<code>s2</code>是否包含<code>s1</code>的排列。如果是，返回<code>true</code>；否则，返回<code>false</code>。</p><p>换句话说，<code>s1</code>的排列之一是<code>s2</code>的<strong>子串</strong>。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：s1 = “ab” s2 = “eidbaooo”<br><strong>输出</strong>：true<br><strong>解释</strong>：s2 包含 s1 的排列之一 (“ba”).</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：s1= “ab” s2 = “eidboaoo”<br><strong>输出</strong>：false</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 10^4</code></li><li><code>s1</code>和<code>s2</code>仅包含小写字母</li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/permutation-in-string/">https://leetcode-cn.com/problems/permutation-in-string/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/permutation-in-string/solution/zhu-shi-chao-xiang-xi-de-hua-dong-chuang-rc7d/">https://leetcode-cn.com/problems/permutation-in-string/solution/zhu-shi-chao-xiang-xi-de-hua-dong-chuang-rc7d/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：哈希表+移动窗口</li><li><strong>思路</strong>：<ul><li>1.移动窗口放在s2中，且长度等于s1</li><li>2.<strong>s1排列之一</strong> = <strong>长度相等</strong> + <strong>每个字符数量一致</strong></li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkInclusion</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//用哈希表存s1中每个字符出现的次数</span>        <span class="token comment">//因为判断s2是否包含s1的某一个排列，所以只需要s2中某个连续子串的字符跟次数跟s1对应则为true</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> s1Map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token operator">:</span>s1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//记录每个字符出现次数，get的时候不存在则默认为0</span>            s1Map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>s1Map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//s2的移动窗口(与s1长度一致)</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&lt;</span>s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果有某个窗口为true，则说明s1的排列之一是s2的子串，return true</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isTheSameCharacterCount</span><span class="token punctuation">(</span>s1Map<span class="token punctuation">,</span>s2<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//窗口向右滑动</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>            right<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * str中字符所包含的数量是否与targetMap一致     * ps.    str长度=targetMap中value总和     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isTheSameCharacterCount</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> targetMap<span class="token punctuation">,</span> <span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> resultMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">//查询获取s1中c的数量</span>            <span class="token keyword">int</span> targetCount <span class="token operator">=</span> targetMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>targetCount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//targetMap不存在c字符，故结果不一致</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//查询s2中滑动窗口c的数量</span>            <span class="token keyword">int</span> count <span class="token operator">=</span> resultMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">&gt;=</span> targetCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//str包含比targetMap多的字符，故结果不一致</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//记录str的c字符数量+1</span>            resultMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、执行结果"><a href="#五、执行结果" class="headerlink" title="五、执行结果"></a>五、执行结果</h2><p><strong>执行结果</strong>：<code>通过</code><br><strong>执行用时</strong>：<code>731 ms</code>, 在所有<code>Java</code>提交中击败了<code>7.56%</code>的用户<br><strong>内存消耗</strong>：<code>39.2 MB</code>, 在所有<code>Java</code>提交中击败了<code>5.12%</code>的用户<br><strong>通过测试用例</strong>：<code>106/106</code></p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><ul><li><strong>难度</strong>：较难，思路没想到，过程也复杂</li><li><strong>总结</strong>：<ul><li>1.移动窗口题型比较少接触，需要多做</li><li>2.没有使用题解的解法，而是用了比较容易理解的哈希表（缺点：慢+内存消耗大）</li><li>3.解题耗时长，需要重做，培养解题思路</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 移动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/2022/01/05/algorithm/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
      <url>/2022/01/05/algorithm/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给定一个字符串<code>s</code>，请你找出其中不含有重复字符的<strong>最长子串</strong>的长度。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>: s = “abcabcbb”<br><strong>输出</strong>: 3<br><strong>解释</strong>: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>: s = “bbbbb”<br><strong>输出</strong>: 1<br><strong>解释</strong>: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>: s = “pwwkew”<br><strong>输出</strong>: 3<br><strong>解释</strong>: 因为无重复字符的最长子串是&nbsp;“wke”，所以其长度为 3。<br>    请注意，你的答案必须是 子串 的长度，”pwke”&nbsp;是一个子序列，不是子串。</p></blockquote><p><strong>示例四</strong>：</p><blockquote><p><strong>输入</strong>: s = “”<br><strong>输出</strong>: 0</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li><li><code>s</code>由英文字母、数字、符号和空格组成</li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/hua-jie-suan-fa-3-wu-zhong-fu-zi-fu-de-zui-chang-z/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：哈希表+移动窗口</li><li><strong>思路</strong>：从左到右用end遍历字符串并存起来(字符+下标)，遇到重复的字符的话就重置start，并计算长度length=end-start+1</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//用哈希表基表每个字符的下标，然后遇到有重复的就去掉上一个重复的的</span>        <span class="token comment">//如abca去掉上一个重复的a就是bca就是无重复字符的子串</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>end<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">// start = map.get(c) + 1;</span>                <span class="token comment">// 需要加这个字段防止定位到不连续的下标去(比如abba)</span>                start <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            result <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> end<span class="token operator">-</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：中等</li><li><strong>总结</strong>：移动窗口题型没做过，需要多做，做熟悉</li></ul><h2 id="六、测试用例不通过记录"><a href="#六、测试用例不通过记录" class="headerlink" title="六、测试用例不通过记录"></a>六、测试用例不通过记录</h2><h3 id="1-没有对特殊情况做判断-边界"><a href="#1-没有对特殊情况做判断-边界" class="headerlink" title="1.没有对特殊情况做判断(边界)"></a>1.没有对特殊情况做判断(边界)</h3><p><strong>失败用例</strong>：”abba”<br><strong>错误结果</strong>: 3<br><strong>预期结果</strong>: 2<br><strong>修改前</strong>：<code>start = map.get(c) + 1;</code><br><strong>修改后</strong>：<code>start = Math.max(map.get(c)+1, start);</code><br><strong>解释</strong>：</p><ul><li>遍历完第三个字符b的时候，start=2,end=2</li><li>遍历到第四个字符a的时候，<code>start=map.get(3)+1=1</code>，但是此时<code>start=end=2</code>（并没有包含了下标为0的a），所以我们不能执行start=1</li><li><code>start = Math.max(map.get(c)+1, start);</code>执行这个的理由是判断<code>map.get(c)</code>是否包含在<code>start</code>-&gt;<code>end</code>中<ul><li>包含：<code>start = map.get(c) + 1</code></li><li>不包含（不处理）：<code>start = start</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 移动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977. 有序数组的平方</title>
      <link href="/2021/12/31/algorithm/you-xu-shu-zu-de-ping-fang/"/>
      <url>/2021/12/31/algorithm/you-xu-shu-zu-de-ping-fang/</url>
      
        <content type="html"><![CDATA[<h1 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个按<strong>非递减顺序</strong>排序的整数数组<code>nums</code>，返回<strong>每个数字的平方</strong>组成的新数组，要求也按<strong>非递减顺序</strong>排序。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：nums = [-4,-1,0,3,10]<br><strong>输出</strong>：[0,1,9,16,100]<br><strong>解释</strong>：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：nums = [-7,-3,2,3,11]<br><strong>输出</strong>：[4,9,9,49,121]</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按<strong>非递减顺序</strong>排序</li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/">https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：双指针</li><li><strong>思路</strong>：<ul><li>1.负数的话越小平方的数越大，正数的话越大平方的数越大</li><li>2.用双指针两端往中间遍历直到重合，比较大的就放在结果集后面</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortedSquares</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//前提：负数的话越小平方的数越大，正数的话越大平方的数越大</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> result<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//result从右往左排</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>                index<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单(没想到有题解这种操作)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 简单难度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. 移动零</title>
      <link href="/2021/12/31/algorithm/yi-dong-ling/"/>
      <url>/2021/12/31/algorithm/yi-dong-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给定一个数组<code>nums</code>，编写一个函数将所有<code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例</strong>：</p><blockquote><p><strong>输入</strong>: [0,1,0,3,12]<br><strong>输出</strong>: [1,3,12,0,0]</p></blockquote><p><strong>说明</strong>：</p><ul><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/">https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：双指针</li><li><strong>思路</strong>：用两个指针，一个遍历数组，一个指向第一个0下标(用于交换数)</li><li><strong>步骤</strong>：<ul><li>1.定义移动指针i=0，指向第一个0的下标j=0</li><li>2.i从0遍历到nums末尾，当nums[i]不为0时，与nums[j]（第一个0）交换，同时j右移</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//指向第一个0的下标</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//游动指针从头到尾</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//如果当前数为0，就i+1，j不变</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//调换i和j位置的数</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token comment">//j+1（第一个0的下标）</span>        j<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：中等(没有这个思路/思维，需要重做)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 简单难度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>278. 第一个错误的版本</title>
      <link href="/2021/12/30/algorithm/di-yi-ge-cuo-wu-de-ban-ben/"/>
      <url>/2021/12/30/algorithm/di-yi-ge-cuo-wu-de-ban-ben/</url>
      
        <content type="html"><![CDATA[<h1 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有<code>n</code>个版本<code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用<code>bool isBadVersion(version)</code>接口来判断版本号<code>version</code>是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：n = 5, bad = 4<br><strong>输出</strong>：4<br><strong>解释</strong>：<br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br>所以，4 是第一个错误的版本。</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：n = 1, bad = 1<br><strong>输出</strong>：1</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= bad &lt;= n &lt;= 231 - 1</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/first-bad-version/">https://leetcode-cn.com/problems/first-bad-version/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/">https://leetcode-cn.com/problems/first-bad-version/solution/di-yi-ge-cuo-wu-de-ban-ben-by-leetcode-s-pf8h/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：二分查找</li><li><strong>思路</strong>：true的左边全是true，false的右边全是false，所以可以理解为有序数组</li><li><strong>步骤</strong>：<ul><li>1.正常定义二分查找需要的变量：left、right、middle</li><li>2.判断middle的正确性<ul><li>2.1 正确 -&gt; left移动到middle+1</li><li>2.2 错误 -&gt; right移动到middle（不减1是因为最终返回的是第一个right而不是第一个left）</li></ul></li><li>3.while循环到最后left会与right重合，这就是最终结果</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* The isBadVersion API is defined in the parent class VersionControl.      boolean isBadVersion(int version); */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token keyword">extends</span> <span class="token class-name">VersionControl</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstBadVersion</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> middle <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token comment">//二分查找，中间点如果是true的，那么左边都为true</span>      <span class="token comment">//如果中间点是false的，那么右边都为false</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isBadVersion</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//如果是false，那么result在左边（包含middle），因为结果是要输出第一个false的version</span>        right<span class="token operator">=</span>middle<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token comment">//如果是true，那么result在右边（不包含middle）</span>        left<span class="token operator">=</span>middle<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> right<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单</li></ul><h2 id="六、测试用例不通过记录"><a href="#六、测试用例不通过记录" class="headerlink" title="六、测试用例不通过记录"></a>六、测试用例不通过记录</h2><h3 id="1-AC时超过时间限制"><a href="#1-AC时超过时间限制" class="headerlink" title="1.AC时超过时间限制"></a>1.AC时超过时间限制</h3><p><strong>失败用例</strong>：n = 2126753390, bad = 1702766719<br><strong>修改前</strong>：<code>int middle = left + right / 2;</code><br><strong>修改后</strong>：<code>int middle = left + (right - left) / 2;</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 简单难度 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>79. 单词搜索</title>
      <link href="/2021/12/28/algorithm/dan-ci-sou-suo/"/>
      <url>/2021/12/28/algorithm/dan-ci-sou-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.单词搜索</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给定一个<code>m x n</code>二维字符网格<code>board</code>和一个字符串单词<code>word</code>。如果<code>word</code>存在于网格中，返回<code>true</code>；否则，返回<code>false</code>。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例一</strong>：<br><img src="/images/algorithm/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A21.png"></p><blockquote><p><strong>输入</strong>：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED”<br><strong>输出</strong>：true</p></blockquote><p><strong>示例二</strong>：<br><img src="/images/algorithm/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A22.png"></p><blockquote><p><strong>输入</strong>：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “SEE”<br><strong>输出</strong>：true</p></blockquote><p><strong>示例三</strong>：<br><img src="/images/algorithm/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A23.png"></p><blockquote><p><strong>输入</strong>：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCB”<br><strong>输出</strong>：false</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code>和<code>word</code>仅由大小写英文字母组成</li></ul><p><strong>进阶</strong>：你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？</p><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/word-search/">https://leetcode-cn.com/problems/word-search/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/word-search/solution/su-kan-dfsjian-dan-yi-dong-by-rain-ru-xnwe/">https://leetcode-cn.com/problems/word-search/solution/su-kan-dfsjian-dan-yi-dong-by-rain-ru-xnwe/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：回溯算法</li><li><strong>思路</strong>：理解为三叉树即可，然后参考全排列</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordSearch</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">exist</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//这种有结束条件的一般都要想到回溯</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//找到第一个字符</span>        <span class="token keyword">char</span> first <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> board<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//找到起点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">//还是得设置一个boolean数组</span>                    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> isUsed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>board<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">boolean</span> isExist <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> words<span class="token punctuation">,</span> isUsed<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//只要有一条路径符合即可</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>isExist<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//words存放路径</span>    <span class="token comment">//board记录走过的(设置0即可)</span>    <span class="token comment">//word存放需要走的单词</span>    <span class="token comment">/**     * 回溯算法     * @param board 二维字符网络(条件给的，不变)     * @param words 路径     * @param isUsed 网络字符使用情况(路径走过置为true)     * @param x     * @param y     * @param wordsSize     * @param word     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> isUsed<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> wordsSize<span class="token punctuation">,</span> <span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//判断是否在便捷了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> x <span class="token operator">&gt;</span> isUsed<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">&gt;</span> isUsed<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//使用过也返回false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isUsed<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//判断是否可以连上</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>wordsSize<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            words<span class="token punctuation">[</span>wordsSize<span class="token punctuation">]</span> <span class="token operator">=</span> board<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>            wordsSize<span class="token operator">++</span><span class="token punctuation">;</span>            isUsed<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wordsSize <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//前后左右看</span>        <span class="token keyword">boolean</span> left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> words<span class="token punctuation">,</span> isUsed<span class="token punctuation">,</span> x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> wordsSize<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> words<span class="token punctuation">,</span> isUsed<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> wordsSize<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> up <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> words<span class="token punctuation">,</span> isUsed<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> wordsSize<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> down <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> words<span class="token punctuation">,</span> isUsed<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> wordsSize<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//回溯算法关键，需要往回回滚数据</span>        isUsed<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">//只要有一个有true即可</span>        <span class="token keyword">return</span> left <span class="token operator">||</span> right <span class="token operator">||</span> up <span class="token operator">||</span> down<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"     输出：true     * @param args     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> board <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'S'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'S'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> word <span class="token operator">=</span> <span class="token string">"ABCCED"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WordSearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exist</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：思路很清晰，就是步骤(主要是判断)会比较多</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="/2021/12/28/algorithm/san-shu-zhi-he/"/>
      <url>/2021/12/28/algorithm/san-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？请你找出所有和为<code>0</code>且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：nums = [-1,0,1,2,-1,-4]<br><strong>输出</strong>：[[-1,-1,2],[-1,0,1]]</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：nums = []<br><strong>输出</strong>：[]</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>：nums = [0]<br><strong>输出</strong>：[]</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/">https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：双指针</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreeSum</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//少于3个直接返回(不存在符合要求结果)</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//可以直接暴力遍历，但是会有很多次无效判断，所以看看能不能尽可能跳过这无效判断</span>    <span class="token comment">//排序数组</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//双指针</span>    <span class="token keyword">int</span> left<span class="token punctuation">;</span>    <span class="token keyword">int</span> right<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//注意边界处理</span>      <span class="token comment">//如果nums[i]==nums[i-1]，则不用处理(去重)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      left <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      right <span class="token operator">=</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">//循环到左右指针相遇即可停</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment">//符合要求，存起来</span>          <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//左移右移不能等于当前值(结果要去重) 不能越界</span>          <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          left<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token keyword">while</span><span class="token punctuation">(</span>right<span class="token operator">&gt;</span>left <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          left<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>sum<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：nums = [-1,0,1,2,-1,-4]   *  输出：[[-1,-1,2],[-1,0,1]]   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreeSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">threeSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：一般</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>494. 目标和</title>
      <link href="/2021/12/26/algorithm/mu-biao-he/"/>
      <url>/2021/12/26/algorithm/mu-biao-he/</url>
      
        <content type="html"><![CDATA[<h1 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个整数数组<code>nums</code>和一个整数<code>target</code>。</p><p>向数组中的每个整数前添加<code>'+'</code>或<code>'-'</code>，然后串联起所有整数，可以构造一个<strong>表达式</strong>：</p><p>例如，<code>nums = [2, 1]</code>，可以在<code>2</code>之前添加<code>'+'</code>，在<code>1</code>之前添加<code>'-'</code>，然后串联起来得到表达式<code>"+2-1"</code>。<br>返回可以通过上述方法构造的、运算结果等于<code>target</code>的不同<strong>表达式</strong>的数目。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：nums = [1,1,1,1,1], target = 3<br><strong>输出</strong>：5<br><strong>解释</strong>：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：nums = [1], target = 1<br><strong>输出</strong>：1</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 20</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li><li><code>-1000 &lt;= target &lt;= 1000</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/">https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：数组+回溯</li><li><strong>思路</strong>：把对于后面一个数的+-当做左右子树，然后通过回溯算法即可遍历所有情况</li><li><strong>注意</strong>：每一个数都可以+-(包括第一个数)</li><li><strong>步骤</strong>：<ul><li>1.设置层级level(达到最后一个数就可判断sum)</li><li>2.当前数操作下一个数(具体见代码注释)</li><li>3.循环2 下一个数操作下下一个数。。。(见代码注释)</li><li>4.到达最后一个数(level=length)，判断sum==target(true则size++)</li><li>5.返回size</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TargetSum</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findTargetSumWays</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意这里不是0开始</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 解法：数组+回溯   * 思路：把对于后面一个数的+-当做左右子树，然后通过回溯算法即可遍历所有情况   * 注意：每一个数都可以+-(包括第一个数)   * 步骤：   *  1.设置层级level(达到最后一个数就可判断sum)   *  2.当前数操作下一个数   *         1   *      +/  \-   *      1   1   *      2.1 当前数+下一个数   *      2.2 当前数-下一个数   *  3.循环2 下一个数操作下下一个数。。。   *          1   *      +/    \-   *      1      1   *   +/  \- +/  \-   *   1   1  1    1   *  4.到达最后一个数(level=length)，判断sum==target(true则size++)   *  5.返回size   * @param nums   * @param target   * @param level 结束条件level==nums.length   * @param sum 截止当前位置表达式总和   */</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> level<span class="token punctuation">,</span> <span class="token keyword">int</span> sum<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//结束条件判断(到达最后一个数)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//判断最终表达式是否等于target</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//要注意，第一层也是有+-的。。。</span>    <span class="token comment">//+</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sum <span class="token operator">+</span> nums<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//-</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sum <span class="token operator">-</span> nums<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：nums = [1,1,1,1,1], target = 3   *  输出：3   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TargetSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findTargetSumWays</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：还好，知道可以用回溯算法后醍醐灌顶(还是得重做多做，一开始没这思路)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>560. 和为K的子数组</title>
      <link href="/2021/12/26/algorithm/he-wei-k-de-zi-shu-zu/"/>
      <url>/2021/12/26/algorithm/he-wei-k-de-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560.和为K的子数组"></a>560.和为K的子数组</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个整数数组<code>nums</code>和一个整数<code>k</code>，请你统计并返回该数组中和为<code>k</code>的连续子数组的个数。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：nums = [1,1,1], k = 2<br><strong>输出</strong>：2</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：nums = [1,2,3], k = 3<br><strong>输出</strong>：2</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/">https://leetcode-cn.com/problems/subarray-sum-equals-k/solution/he-wei-kde-zi-shu-zu-by-leetcode-solution/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：前缀和+数组+哈希表</li><li><strong>思路</strong>：如果双重遍历时间复杂度会很高，所以在这基础上引入前缀和和哈希表，可以避免多次不必要的计算</li><li><strong>步骤</strong>：<ul><li>1.提供数组nums=[1 2 3 5 8]、k=8</li><li>2.<br>  A:——– &lt;—k—&gt;<br>  B:——————<br>如AB所示，我们要计算有k长度的连续数组，完全可以通过B-A，其中A、B都是当前位置的前缀和(*)</li><li>3.由2我们可列出前缀和[1 3 6 11 19]</li><li>4.由2和3我们知道3就是对应2的B，因为A+k=B，所以我们只要找A=B-k的A是否存在(B和k已知)</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubarraySumEqualsK</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * @param nums 提供的整数数组   * @param k 连续子数组和   * @return   */</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//结果</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//当前和</span>    <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//key是和，value是次数</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//是为了那种从0-i下标就是符合连续子数组和的</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//计算前缀和</span>      pre <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">//如果存在前缀和</span>      <span class="token keyword">int</span> num <span class="token operator">=</span> pre <span class="token operator">-</span> k<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//意思就是连上之前的情况也可以有对应count</span>        <span class="token comment">//比如nums=[3,-3,2,-2,0,3]、k=0</span>        <span class="token comment">//对应的前缀和为sums=[3,0,2,0,0,3]</span>        <span class="token comment">//所以符合条件的连续子数组会有[3,-3][2,-2][0]由于连上的情况就可以有[3,-3,2,-2][3,-3,2,-2,0][2,-2,0[</span>        count <span class="token operator">+=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment">//如果没存在过，就初始化1，存在就加1(给上边提供count+=)</span>      map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：[1,1,1]   *  输出：2   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SubarraySumEqualsK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subarraySum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：没思路，看了很久题解也不是很会做</li><li><strong>备注</strong>：前缀和，需要重做</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. 删除链表的倒数第N个结点</title>
      <link href="/2021/12/24/algorithm/shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/"/>
      <url>/2021/12/24/algorithm/shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19.删除链表的倒数第N个结点"></a>19.删除链表的倒数第N个结点</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个链表，删除链表的倒数第<code>n</code>个结点，并且返回链表的头结点。</p><p><strong>示例一</strong>：<br><img src="/images/algorithm/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9.png"></p><blockquote><p><strong>输入</strong>：head = [1,2,3,4,5], n = 2<br><strong>输出</strong>：[1,2,3,5]</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：head = [1], n = 1<br><strong>输出</strong>：[]</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>：head = [1,2], n = 1<br><strong>输出</strong>：[1]</p></blockquote><p><strong>提示</strong>：</p><ul><li>链表中结点的数目为<code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></li><li><strong>参考题解</strong>：无</li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：双指针</li><li><strong>思路</strong>：<ul><li>1.用快慢指针，起点相隔n，当快指针到终点时，慢指针刚好在倒数第n个结点</li><li>2.由于是删除操作，所以需要目标结点的pre节点(由于链表结构里面没有，需要我们自定义)</li></ul></li><li><strong>步骤</strong>：<ul><li>1.定义一个新的头结点newHead(指向next为head)</li><li>2.定义快慢指针fast、slow</li><li>3.fast先走n+1步(由于我们是要找到目标结点的pre结点，所以+1)</li><li>4.快慢指针同时遍历，直到fast为null</li><li>5.此时slow.next为目标结点，执行删除操作(见代码)</li><li>6.返回第一步定义newHead的next(因为实际是要返回head)</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RemoveNthNodeFromEndOfList</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//定义head的pre结点(方便输出结果)</span>    <span class="token class-name">ListNode</span> newHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    newHead<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">//定义快慢指针</span>    <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> newHead<span class="token punctuation">;</span>    <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> newHead<span class="token punctuation">;</span>    <span class="token comment">//双指针，一个先到达终点，另一个就是倒数第n个结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//这里是为了下面另一个指向倒数第n个结点前一个结点(方便删除)</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//当fast到达终点null时，slow到达倒数第n个结点前一个结点</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//fast指针到终点，slow指针是倒数第n个结点上</span>    <span class="token class-name">ListNode</span> next <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    slow<span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token comment">//返回head</span>    <span class="token keyword">return</span> newHead<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：head = [1,2,3,4,5], n = 2   *  输出：[1,2,3,5]   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">ListNode</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RemoveNthNodeFromEndOfList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeNthFromEnd</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：会解法</li><li><strong>备注</strong>：有部分case没通过，需要注意</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="/2021/12/24/algorithm/quan-pai-lie/"/>
      <url>/2021/12/24/algorithm/quan-pai-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给定一个不含重复数字的数组<code>nums</code>，返回其<strong>所有可能的全排列</strong>。你可以<strong>按任意顺序</strong>返回答案。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：nums = [1,2,3]<br><strong>输出</strong>：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：nums = [0,1]<br><strong>输出</strong>：[[0,1],[1,0]]</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>：nums = [1]<br><strong>输出</strong>：[[1]]</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code>中的所有整数<strong>互不相同</strong></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：回溯算法</li><li><strong>步骤</strong>：<ul><li>1.通过变量path记录路径，result记录结果，nums记录选择列表</li><li>2.结束条件：到达决策树底层，无法再做选择的条件(本题是到叶子结点视为结束)</li><li>3.通过做选择和撤销选择实现决策树的回溯</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Permutations</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">permute</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">backtrack</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 回溯算法   * 结束条件，path.size()=nums.length(到达叶子结点)   * @param path 路径   * @param nums 选择列表   * @param result 结果集   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>          <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path<span class="token punctuation">,</span>          <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span>          <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result  <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//触发结束的条件</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//这里是path不是result</span>      result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//!!!!这里需要new，否则会动到原数据</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//去重</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">continue</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment">//做选择</span>      path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//进入下一层决策树</span>      <span class="token function">backtrack</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//撤销选择</span>      path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：nums = [1,2,3]   *  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Permutations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permute</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：难，不熟练</li><li><strong>备注</strong>：经典，需多练</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="/2021/12/24/algorithm/he-bing-qu-jian/"/>
      <url>/2021/12/24/algorithm/he-bing-qu-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>以数组<code>intervals</code>表示若干个区间的集合，其中单个区间为<code>intervals[i] = [starti, endi]</code>。<br>请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：intervals = [[1,3],[2,6],[8,10],[15,18]]<br><strong>输出</strong>：[[1,6],[8,10],[15,18]]<br><strong>解释</strong>：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：intervals = [[1,4],[4,5]]<br><strong>输出</strong>：[[1,5]]<br><strong>解释</strong>：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p></blockquote><p><strong>提示</strong>：</p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/">https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：排序+数组</li><li><strong>思路</strong>：先排序区间，遍历区间数组将重叠部分合到一起</li><li><strong>步骤</strong>：<ul><li>1.根据区间左值排序</li><li>2.遍历判断entry的左值与结果值前面一个pre的右值对比，如果大于则新增add，其他情况则修改pre的右值</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeIntervals</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> intervals<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//获取区间左右值</span>            <span class="token keyword">int</span> left <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> right <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//获取前一个区间(第一个不用)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>left<span class="token punctuation">,</span> right<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//前后区间重叠则整合，不重叠则新增</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>left<span class="token punctuation">,</span> right<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment">//如果重合则修改原区间</span>                pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> pre<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 例子：     *  输入：[[1,3],[2,6],[8,10],[15,18]]     *  输出：[[1,6],[8,10],[15,18]]     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intervals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>                <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MergeIntervals</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>intervals<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> i <span class="token operator">:</span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单看题解后可完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 最长回文子串</title>
      <link href="/2021/12/23/algorithm/zui-chang-hui-wen-zi-chuan/"/>
      <url>/2021/12/23/algorithm/zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个字符串 <code>s</code>，找到<code>s</code>中最长的回文子串。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：s = “babad”<br><strong>输出</strong>：”bab”<br><strong>解释</strong>：”aba” 同样是符合题意的答案。</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：s = “cbbd”<br><strong>输出</strong>：”bb”</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>：s = “a”<br><strong>输出</strong>：”a”</p></blockquote><p><strong>示例四</strong>：</p><blockquote><p><strong>输入</strong>：s = “ac”<br><strong>输出</strong>：”a”</p></blockquote><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：动态规划</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongestPalindromicSubstring</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//小于2的必是回文</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cs <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//字符串长度</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> cs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//最长回文子串最长长度</span>        <span class="token keyword">int</span> maxLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxHead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//遍历存放是否回文子串状态</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//只有一个字符必是回文串，先初始化</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//遍历其他</span>        <span class="token comment">//i是开始，j是结束</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//这里注意是=i，而不是=0</span>                <span class="token comment">//如果j比i大，那么是非法的</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment">//只是跳出内层for，以后内层后面的也都是一样结果</span>                <span class="token punctuation">}</span>                <span class="token comment">//如果当前头尾相等，则取里面的值</span>                <span class="token comment">//比如bcacb是回文，那么cac、a也是回文</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>cs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token comment">//前提是3位及以上，因为单个就肯定是回文</span>                    <span class="token comment">//同时如果是两位的话就不需要往内取了</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">//如果是true则判断max</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">int</span> curLen <span class="token operator">=</span> j<span class="token operator">-</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>curLen<span class="token operator">&gt;</span>maxLen<span class="token punctuation">)</span><span class="token punctuation">{</span>                        maxLen <span class="token operator">=</span> curLen<span class="token punctuation">;</span>                        maxHead <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//这里需要注意substring是(beginIndex,endIndex)</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>maxHead<span class="token punctuation">,</span>maxLen<span class="token operator">+</span>maxHead<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 例子：     *  输入：[73,74,75,71,69,72,76,73]     *  输出：[1,1,4,2,1,1,0,0]     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"babad"</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LongestPalindromicSubstring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">longestPalindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单看题解后可完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300. 最长递增子序列</title>
      <link href="/2021/12/23/algorithm/zui-chang-di-zeng-zi-xu-lie/"/>
      <url>/2021/12/23/algorithm/zui-chang-di-zeng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个整数数组<code>nums</code>，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：nums = [10,9,2,5,3,7,101,18]<br><strong>输出</strong>：4<br><strong>解释</strong>：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：nums = [0,1,0,3,2,3]<br><strong>输出</strong>：4</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p><strong>输入</strong>：nums = [7,7,7,7,7,7,7]<br><strong>输出</strong>：1</p></blockquote><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：动态规划+回溯算法</li><li><strong>思路</strong>：遍历数组从左到右，用dp[]数组存储截止当前位置的max值</li><li><strong>步骤</strong>：<ul><li> 1.遍历数组，判断当前数和之前数大小</li><li> 2.如果之前数没有比当前数大的，则当前位置dp[i]=1(代表最长子序列长度为1)</li><li> 3.如果之前数有比当前数大的，就判断之前数dp[i]=Math.max(dp[pre],dp[i])</li><li> 4.每遍历一次数组，就更新max=Math.max(max,dp[i])</li><li> 5.返回max</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongestIncreasingSubsequence</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//遍历数组，用dp数组存截止某个位置的最长递增子序列长度即可</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//结果(最长递增子序列)</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//判断前面是否有比当前数小的递增子序列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//如果之前数比当前数小，说明加上当前数是一个递增子序列，记录大小</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//加上当前位置</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 例子：     *  输入：nums = [10,9,2,5,3,7,101,18]     *  输出：4     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LongestIncreasingSubsequence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单看题解会思路即可做(可以再重做)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>198. 打家劫舍</title>
      <link href="/2021/12/22/algorithm/da-jia-jie-she/"/>
      <url>/2021/12/22/algorithm/da-jia-jie-she/</url>
      
        <content type="html"><![CDATA[<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><p><strong>示例一</strong>：</p><blockquote><p><strong>输入</strong>：[1,2,3,1]<br><strong>输出</strong>：4<br><strong>解释</strong>：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>偷窃到的最高金额 = 1 + 3 = 4 。</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p><strong>输入</strong>：[2,7,9,3,1]<br><strong>输出</strong>：12<br><strong>解释</strong>：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p></blockquote><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></li><li><strong>参考题解</strong>：无</li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：动态规划</li><li><strong>思路</strong>：遍历数组每一步存当前最大值即可</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HouseRobber</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">rob</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//应该是截止最大值</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//注意这两步不能颠倒(不然比如2,0,0,2就会有问题)</span>            max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 例子：     *  输入：[1,2,3,1]     *  输出：4     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HouseRobber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739. 每日温度</title>
      <link href="/2021/12/22/algorithm/mei-ri-wen-du/"/>
      <url>/2021/12/22/algorithm/mei-ri-wen-du/</url>
      
        <content type="html"><![CDATA[<h1 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p><strong>示例一</strong>：</p><blockquote><p>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p></blockquote><p><strong>示例二</strong>：</p><blockquote><p>输入: temperatures = [30,40,50,60]<br>输出: [1,1,1,0]</p></blockquote><p><strong>示例三</strong>：</p><blockquote><p>输入: temperatures = [30,60,90]<br>输出: [1,1,0]</p></blockquote><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/daily-temperatures/">https://leetcode-cn.com/problems/daily-temperatures/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：单调栈</li><li><strong>思路</strong>：将每一天的温度(存下标)压入栈，后面压入的时候把前面低于的取出来计算天数(保证栈底到栈顶是递增的)</li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DailyTemperatures</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">dailyTemperatures</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temperatures<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//可以参考左视图，如果一个温度把之前的温度的盖住了，说明比他高，就可以赋值了，并移除状态</span>    <span class="token comment">//存下标吧，存value有问题</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//初始化个结果吧，默认值是0(不要直接操作原数组，会多一个for操作)</span>    <span class="token keyword">int</span> result<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>temperatures<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>temperatures<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">//当栈不为空时，从上取比当前数小的取出并设置result</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span>temperatures<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&gt;</span>temperatures<span class="token punctuation">[</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//计算相隔天数并写入result</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> index<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：[73,74,75,71,69,72,76,73]   *  输出：[1,1,4,2,1,1,0,0]   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">73</span><span class="token punctuation">,</span><span class="token number">74</span><span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">,</span><span class="token number">71</span><span class="token punctuation">,</span><span class="token number">69</span><span class="token punctuation">,</span><span class="token number">72</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">73</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DailyTemperatures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dailyTemperatures</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">:</span>result<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单看题解后可完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="/2021/12/22/algorithm/sheng-zui-duo-shui-de-rong-qi/"/>
      <url>/2021/12/22/algorithm/sheng-zui-duo-shui-de-rong-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点(i,ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i,ai) 和 (i, 0) 。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：双指针</li><li><strong>思路</strong>： 遍历数组得到所有情况(这里通过双指针可减少遍历)，得到最大值</li><li><strong>步骤</strong>：<ul><li>1.定义头尾的双指针</li><li>2.开始往中间遍历(直到重合)，小的往大的推进</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ContainerWithMosWater</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * 左右指针   * 一个从头一个从尾，哪个比较小就移动(每次移动都判断当前是否最大值)   *  1.定义头尾的双指针   *  2.开始往中间遍历(直到重合)，小的往大的推进*   * @param height   * @return   */</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//结果值(最大值)</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//左指针</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//右指针</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//判断当前能装多少水</span>      <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment">//以最大值为目标，小的就往大的靠拢</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cur <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        cur <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>        right<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单看题解后可完成</li><li><strong>备注</strong>：一开始不清楚有这种解法，后面看到可以这么解就会了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105. 从前序与中序遍历序列构造二叉树</title>
      <link href="/2021/12/22/algorithm/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu/"/>
      <url>/2021/12/22/algorithm/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给定一棵树的前序遍历 preorder 与中序遍历  inorder。请构造二叉树并返回其根节点。</p><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：递归+深度优先算法</li><li><strong>思路</strong>： <ul><li>1.遍历构建左右子树</li><li>2.先序遍历的第一个结点必是头结点，第二个结点是左子树头结点(如有，递归的前提1)</li><li>3.中序遍历头结点在中间，左边是左子树，右边是右子树(遍历的前提2)</li></ul></li><li><strong>步骤</strong>：<ul><li>1.获取先序遍历第一个结点(即树头结点head)</li><li>2.根据head去中序遍历找到下标inIndex</li><li>3.根据inIndex去计算左右子树的范围(各自的左右下标)</li><li>4.根据第3步计算的左右子树长度去先序遍历找到左右子树</li><li>5.遍历1234</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstructBinaryTreeFromPreorderAndInorderTraversal</span> <span class="token punctuation">{</span>  <span class="token comment">//用户存中序遍历每个数的下标</span>  <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/**   * @param preorder 先序遍历   * @param inorder 中序遍历   * @return 树   */</span>  <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//也可以用indexOf找到，用哈希表其实是空间换时间的思路</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> preorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//理论上先序和后续</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   *   * @param preorder 先序遍历   * @param preLeft 当前结点的左子树左下标   * @param preRight 当前结点的左子树右下标   * @param inLeft 当前结点的右子树左下标   * @param inRight 当前结点的右子树右下标   * @return   */</span>  <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span> preLeft<span class="token punctuation">,</span> <span class="token keyword">int</span> preRight<span class="token punctuation">,</span> <span class="token keyword">int</span> inLeft<span class="token punctuation">,</span> <span class="token keyword">int</span> inRight<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//最多等于的时候说明左/右子树只有一个结点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>preLeft <span class="token operator">&gt;</span> preRight<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//先序遍历第一位就是头结点,获得其值</span>    <span class="token keyword">int</span> head <span class="token operator">=</span> preorder<span class="token punctuation">[</span>preLeft<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">TreeNode</span> treeNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//中序遍历的头结点下标</span>    <span class="token keyword">int</span> inIndex <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//递归左子树</span>    treeNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> preLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inIndex <span class="token operator">-</span> inLeft <span class="token operator">+</span> preLeft<span class="token punctuation">,</span> inLeft<span class="token punctuation">,</span> inIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//递归右子树</span>    treeNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inIndex <span class="token operator">-</span> inLeft <span class="token operator">+</span> preLeft <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> preRight<span class="token punctuation">,</span> inIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> treeNode<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">/**   * 例子：   *  输入：[3,9,20,15,7]   *  输出：[9,3,15,20,7]   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> preorder<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> inorder<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//不做打印要求，可debug看树结构</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConstructBinaryTreeFromPreorderAndInorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：没思路，看了很久题解才勉强会做</li><li><strong>备注</strong>：解题思路比较经典，需要反复学习</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102.二叉树的层级遍历</title>
      <link href="/2021/12/21/algorithm/er-cha-shu-de-ceng-ji-bian-li/"/>
      <url>/2021/12/21/algorithm/er-cha-shu-de-ceng-ji-bian-li/</url>
      
        <content type="html"><![CDATA[<h1 id="102-二叉树的层级遍历"><a href="#102-二叉树的层级遍历" class="headerlink" title="102.二叉树的层级遍历"></a>102.二叉树的层级遍历</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><h2 id="二、相关链接"><a href="#二、相关链接" class="headerlink" title="二、相关链接"></a>二、相关链接</h2><ul><li><strong>题目链接</strong>：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></li><li><strong>参考题解</strong>：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/</a></li></ul><h2 id="三、解题思路"><a href="#三、解题思路" class="headerlink" title="三、解题思路"></a>三、解题思路</h2><ul><li><strong>解法</strong>：广度优先搜索</li><li><strong>思路</strong>： <ul><li>1.先把第一层的结点放到队列<code>queue</code>中</li><li>2.依次取出并存到结果集<code>result</code>中</li><li>3.把2中取出结点的左右结点放入队列<code>queue</code>中</li><li>4.重复123直到<code>queue</code>为空</li></ul></li></ul><h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTreeLevelOrderTraversal</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * 解法：广度优先搜索     *     * @param root     * @return     */</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//定义队列，使每次都取同一层的出来(见下面ps1)</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//每次while遍历时queue都是新的一层</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//存放全一层的node</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> level <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//需要单独声明，不然queue size会变化</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//ps1 当前while循环只取当前层数的，然后存下一层的</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                level<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 例子：     *  输入：[3,9,20,null,null,15,7]     *  输出：[     [3],     [9,20],     [15,7]     ]     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">TreeNode</span> treeNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        treeNode<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BinaryTreeLevelOrderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">levelOrder</span><span class="token punctuation">(</span>treeNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul><li><strong>难度</strong>：简单看题解后可完成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 中等难度 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式：单例模式</title>
      <link href="/2021/12/12/she-ji-mo-shi-dan-li-mo-shi/"/>
      <url>/2021/12/12/she-ji-mo-shi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式：单例模式"><a href="#设计模式：单例模式" class="headerlink" title="设计模式：单例模式"></a>设计模式：单例模式</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p><strong>单例模式</strong>：一个类只允许创建一个对象(或者叫实例)，那么这个类就是一个单例类，这种设计模式就叫作<code>单例设计模式</code></p><h2 id="二、实现-例子：ID生成器"><a href="#二、实现-例子：ID生成器" class="headerlink" title="二、实现(例子：ID生成器)"></a>二、实现(例子：ID生成器)</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ul><li><strong>定义</strong>：通过静态变量在类加载的时候就创建并初始化好instance</li><li><strong>优点</strong>：线程安全(类加载初始化)</li><li><strong>缺点</strong>：不支持延迟加载(需要使用时才初始化)</li><li><strong>总结</strong>：如果初始化耗时长，推荐在程序启动的时候会就初始化好(而不是在使用时才初始化，会影响性能)，同时程序启动的时候还能暴露出资源可能不够的错误(而不是在使用时才报错，会影响系统可用性)</li><li><strong>代码示例</strong>：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//静态实例创建并初始化好</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">IdGenerator</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//private的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">//public的get方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li><strong>定义</strong>：在需要使用的时候才初始化</li><li><strong>优点</strong>：支持延迟加载(需要使用时才初始化)</li><li><strong>缺点</strong>：<code>getInstance()</code>方法加了<code>synchronized</code>关键字，导致这个函数的病发度很低(不适合频繁调用的场景)</li><li><strong>总结</strong>：可以延迟加载，但如果频繁调用，会导致性能瓶颈</li><li><strong>代码示例</strong>：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//静态实例只声明不初始化</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> instance<span class="token punctuation">;</span>    <span class="token comment">//private的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment">//public的get方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">IdGenerator</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h3><ul><li><strong>定义</strong>：相比<code>懒汉式</code>，<code>instance</code>不为空的时候将不再会加锁(而是初始化的时候才会加锁)</li><li><strong>优点</strong>：<code>instance</code>为null的时候才会加锁(初始化)</li><li><strong>缺点</strong>：可能由于<code>指令重排序</code>导致new完<code>IdGenerator</code>之后，赋值给<code>instance</code>之后还没来得及初始化(new了但还没执行构造函数代码，这时候其他线程拿到的instance就不是null了)</li><li><strong>总结</strong>：判断<code>instance</code>为空才加锁，同时还可以给<code>instance</code>加<code>volatile</code>关键字(防止<code>指令重排序</code>)</li><li><strong>代码示例</strong>：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//静态实例只声明不初始化</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> instance<span class="token punctuation">;</span>    <span class="token comment">//private的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//instance不为空才加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">IdGenerator</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul><li><strong>定义</strong>：利用Java的静态内部类，类似饿汉式的同时，又能做到延迟加载</li><li><strong>原理</strong>：初始化<code>IdGenerator</code>的时候并不会创建<code>SingletonHolder</code>（只会等调用<code>getInstance()</code>方法才会加载<code>SingletonHolder</code>并创建<code>instance</code>）。保证<code>instance</code>的唯一性、保证创建过程的线程安全性(JVM实现)</li><li><strong>优点</strong>：既保证了线程安全，又能做到延迟加载</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IdGenerator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//private的构造方法</span>    <span class="token keyword">private</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment">//静态内部类</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">IdGenerator</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">IdGenerator</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li><strong>定义</strong>：基于枚举类型的单例实现(通过Java枚举类型本身的特性)</li><li><strong>优点</strong>：简单，保证了实例创建的线程安全性和实例的唯一性</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">IdGenertor</span> <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">AtomicLong</span> id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、单例存在哪些问题？"><a href="#三、单例存在哪些问题？" class="headerlink" title="三、单例存在哪些问题？"></a>三、单例存在哪些问题？</h2><ul><li><p>单例对OOP特性的支持不友好</p><ul><li>违背<code>抽象</code>特性（因为直接获取了单例对象，而不是面向接口编程）</li><li>对<code>继承</code>、<code>多态</code>特性的支持不友好</li></ul></li><li><p>单例会隐藏类之间的依赖关系</p><ul><li><strong>单例类</strong>：无需显示创建、无需依赖参数传递</li><li><strong>非单例类</strong>：可通过构造函数、参数传递等方式看出类之间的依赖</li></ul></li><li><p>单例对代码的扩展性不友好</p><ul><li><strong>背景</strong>：单例类只能有一个对象实例</li><li><strong>问题</strong>：如果有场景需要创建多个实例，那么对代码会有较大改动</li><li><strong>场景</strong>：数据库连接池、线程池等资源池（可能要分开处理）</li><li><strong>总结</strong>：单例类在某些场景下会影响代码的扩展性、灵活性</li></ul></li><li><p>单例对代码的可测试性不友好</p><ul><li>可能依赖比较重的外部资源（如DB），导致写单测的时候无法通过mock方式替换掉</li><li>单例类的成员变量（如IdGenerator的id变量）相当于全局变量，测试时可能会收到其他地方的修改</li></ul></li><li><p>单例不支持有参数的构造函数</p><ul><li><p><strong>例子</strong>：比如创建一个连接池的单例对象，就无法通过参数来指定连接池的大小</p></li><li><p><strong>解决方案</strong>：</p><ul><li><p>1.通过init函数去初始化单例对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//自定义参数A</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> paramA<span class="token punctuation">;</span>  <span class="token comment">//自定义参数B</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> paramB<span class="token punctuation">;</span>  <span class="token comment">//带参构造函数</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> paramA<span class="token punctuation">,</span> <span class="token keyword">int</span> paramB<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paramA <span class="token operator">=</span> paramA<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paramB <span class="token operator">=</span> paramB<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//实例外部get方法</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"run init() first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//初始化函数(带参数)</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> init <span class="token punctuation">(</span><span class="token keyword">int</span> paramA<span class="token punctuation">,</span> <span class="token keyword">int</span> paramB<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"duplicate init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>paramA<span class="token punctuation">,</span> paramB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//调用例子</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//先init</span>    <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//再使用</span>    <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2.参数放到getInstance()方法(问题：多次调用后续传的参数无效，只取初始化的参数使用)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//自定义参数A</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> paramA<span class="token punctuation">;</span>  <span class="token comment">//自定义参数B</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> paramB<span class="token punctuation">;</span>    <span class="token comment">//有参构造函数</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> paramA<span class="token punctuation">,</span> <span class="token keyword">int</span> paramB<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>paramA <span class="token operator">=</span> paramA<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>paramB <span class="token operator">=</span> paramB<span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment">//带参数的外部get方法</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token keyword">int</span> paramA<span class="token punctuation">,</span> <span class="token keyword">int</span> paramB<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sinleton</span><span class="token punctuation">(</span>paramA<span class="token punctuation">,</span> paramB<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//初始化</span>    <span class="token class-name">Singleton</span> singleton <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//无效，Singleton只初始化一次(10,20)，所以singleton2取出还是(10,20)</span>    <span class="token class-name">Singleton</span> singleton2 <span class="token operator">=</span> <span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>3.(推荐使用)将参数放在配置文件(全局变量)中，在类实例化时加载</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Config</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PARAM_A <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PARAM_B <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> paramA<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> paramB<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paramA <span class="token operator">=</span> <span class="token class-name">Config</span><span class="token punctuation">.</span>PARAM_A<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>paramB <span class="token operator">=</span> <span class="token class-name">Config</span><span class="token punctuation">.</span>PARAM_B<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul><h3 id="四、单例有什么替代解决方案？"><a href="#四、单例有什么替代解决方案？" class="headerlink" title="四、单例有什么替代解决方案？"></a>四、单例有什么替代解决方案？</h3><ul><li>使用工厂模式</li><li>使用IOC容器</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之美学习笔记</title>
      <link href="/2021/12/11/she-ji-mo-shi-zhi-mei-xue-xi-bi-ji/"/>
      <url>/2021/12/11/she-ji-mo-shi-zhi-mei-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式之美学习笔记"><a href="#设计模式之美学习笔记" class="headerlink" title="设计模式之美学习笔记"></a>设计模式之美学习笔记</h1><h2 id="设计原则与思想：面向对象"><a href="#设计原则与思想：面向对象" class="headerlink" title="设计原则与思想：面向对象"></a>设计原则与思想：面向对象</h2><ul><li><a href="https://garyleeeee.github.io/2021/11/13/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">跳转查看《设计原则与思想：面向对象》学习笔记</a></li></ul><h2 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h2><ul><li><a href="https://garyleeeee.github.io/2021/11/26/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3%EF%BC%9A%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">跳转查看《设计原则与思想：设计原则》学习笔记</a></li></ul><h2 id="设计原则与思想：规范与重构"><a href="#设计原则与思想：规范与重构" class="headerlink" title="设计原则与思想：规范与重构"></a>设计原则与思想：规范与重构</h2><ul><li><a href="https://garyleeeee.github.io/2021/12/03/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%80%9D%E6%83%B3%EF%BC%9A%E8%A7%84%E8%8C%83%E4%B8%8E%E9%87%8D%E6%9E%84/">跳转查看《设计原则与思想：规范与重构》学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速改善代码质量的20条编程规范</title>
      <link href="/2021/12/06/kuai-su-gai-shan-dai-ma-zhi-liang-de-20-tiao-bian-cheng-gui-fan/"/>
      <url>/2021/12/06/kuai-su-gai-shan-dai-ma-zhi-liang-de-20-tiao-bian-cheng-gui-fan/</url>
      
        <content type="html"><![CDATA[<h1 id="快速改善代码质量的20条编程规范"><a href="#快速改善代码质量的20条编程规范" class="headerlink" title="快速改善代码质量的20条编程规范"></a>快速改善代码质量的20条编程规范</h1><h2 id="1-关于命名"><a href="#1-关于命名" class="headerlink" title="1.关于命名"></a>1.关于命名</h2><ul><li>命名的关键是能准确达意（不要刻意选择一些缩写命名 不好理解）</li><li>借助类的信息来简化属性、函数命名<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//优化前</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userPassword<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> userAge<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//优化后</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>命名要可读、可搜索<ul><li>比如查询方法统一用<code>getxxx()</code>方便输入.get的时候联想搜索</li><li>统一规范，比如统一用<code>addxxx()</code>而不是<code>insertxxx()</code>来表示插入一条数据</li></ul></li><li>接口和抽象类特殊命名<ul><li><strong>接口</strong>：一种是在接口中带前缀”I”，另一种是在接口的实现类中带后缀”Impl”</li><li><strong>抽象类</strong>：可以加上”abstract”前缀<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//接口命名1</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IUserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token keyword">implements</span> <span class="token class-name">IUserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//接口命名2</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="2-关于注释"><a href="#2-关于注释" class="headerlink" title="2.关于注释"></a>2.关于注释</h2><ul><li>注释需要写什么内容？<ul><li>做什么</li><li>为什么</li><li>怎么做</li><li>如何用(针对较复杂的类和接口)</li></ul></li><li>注释是不是越多越好？<ul><li>注释太多，会影响代码的阅读</li><li>注释太多，会影响后期的维护成本（改代码需要同步修改注释，否则会对不上）</li></ul></li><li>哪里写注释比较好？<ul><li>类和函数一定要写注释（尽可能全面、详细）</li><li>函数内部注释相对少一点（依赖好的命名、提炼函数等提高代码可读性）</li></ul></li></ul><h2 id="3-函数、类多大才合适？"><a href="#3-函数、类多大才合适？" class="headerlink" title="3.函数、类多大才合适？"></a>3.函数、类多大才合适？</h2><ul><li><strong>尽量</strong>不要超过一个屏幕大小</li></ul><h2 id="4-一行代码多长最合适？"><a href="#4-一行代码多长最合适？" class="headerlink" title="4.一行代码多长最合适？"></a>4.一行代码多长最合适？</h2><ul><li><strong>尽量</strong>不要超过IDE显示的宽度(否则得左右拉不方便看)</li><li>也不要太短，不然一句代码容易被拆成多长，也不利于阅读(也不整洁)</li></ul><h2 id="5-善用空行分割单元块"><a href="#5-善用空行分割单元块" class="headerlink" title="5.善用空行分割单元块"></a>5.善用空行分割单元块</h2><ul><li>长函数里不同独立逻辑的代码块可以用空行分割(简洁、清晰，方便阅读也方便后续维护)</li><li>其他场景也可加空行分割<ul><li>类的成员变量和函数之间</li><li>类的静态成员变量和普通成员变量之间</li><li>类的各函数之间</li><li>类的各个成员变量之间<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> <span class="token class-name">NoticeService</span> noticeService<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//获取用户信息</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//登陆成功下发消息</span>    <span class="token keyword">boolean</span> result <span class="token operator">=</span> noticeService<span class="token punctuation">.</span><span class="token function">sendLoginSuccess</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="6-四格缩进还是两格缩进？"><a href="#6-四格缩进还是两格缩进？" class="headerlink" title="6.四格缩进还是两格缩进？"></a>6.四格缩进还是两格缩进？</h2><ul><li><strong>推荐</strong>用两格缩进(节省空间，Java倾向于两格)</li><li>取决个人喜好/团队统一即可</li></ul><h2 id="7-大括号是否要另起一行？"><a href="#7-大括号是否要另起一行？" class="headerlink" title="7.大括号是否要另起一行？"></a>7.大括号是否要另起一行？</h2><ul><li><strong>不另起一行</strong>：节省代码行数(<strong>推荐</strong>)</li><li><strong>另起一行</strong>： 左右括号可以垂直对齐(代码块一目了然)</li></ul><h2 id="8-类中成员的排列顺序"><a href="#8-类中成员的排列顺序" class="headerlink" title="8.类中成员的排列顺序"></a>8.类中成员的排列顺序</h2><ul><li><strong>类</strong>：成员变量-&gt;函数</li><li><strong>成员变量/函数</strong>：静态成员变量/函数-&gt;普通函数/函数</li><li><strong>个人习惯</strong>：比较喜欢把成员变量放前面，函数放后面(每个public和依赖的private方法放一起)</li></ul><h2 id="9-把代码分割成更小的单元快"><a href="#9-把代码分割成更小的单元快" class="headerlink" title="9.把代码分割成更小的单元快"></a>9.把代码分割成更小的单元快</h2><ul><li><strong>背景</strong>：我们一般看某个函数都是先看这个函数整体是什么功能，再看步骤(如果一行行看容易浪费时间而且不一定看得懂)</li><li><strong>建议</strong>：拆分成多个独立功能的小函数</li><li><strong>优点</strong>：方便阅读、易扩展<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//优化前</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bigMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//逻辑1 第一行</span>    <span class="token comment">//逻辑1 第二行</span>    <span class="token comment">//逻辑1 第三行</span>    <span class="token comment">//逻辑1 第四行</span>    <span class="token comment">//逻辑2 第一行</span>    <span class="token comment">//逻辑2 第二行</span>    <span class="token comment">//逻辑2 第三行</span>    <span class="token comment">//逻辑3 第一行 </span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//优化后</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bigMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">smallMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">smallMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">smallMethod3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">smallMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//逻辑1 第一行</span>    <span class="token comment">//逻辑1 第二行</span>    <span class="token comment">//逻辑1 第三行</span>    <span class="token comment">//逻辑1 第四行</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">smallMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//逻辑2 第一行</span>    <span class="token comment">//逻辑2 第二行</span>    <span class="token comment">//逻辑2 第三行</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">smallMethod3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//逻辑3 第一行 </span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="10-避免函数参数过多"><a href="#10-避免函数参数过多" class="headerlink" title="*10.避免函数参数过多"></a>*10.避免函数参数过多</h2><ul><li><p>根据不同逻辑拆分多个函数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//优化前</span>  <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> phone<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//优化后</span>  <span class="token class-name">User</span> <span class="token function">getUserByUsername</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">User</span> <span class="token function">getUserByPhone</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将函数参数封装成对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//优化前</span>  <span class="token keyword">boolean</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span><span class="token class-name">String</span> password<span class="token punctuation">,</span><span class="token keyword">int</span> sex<span class="token punctuation">,</span><span class="token class-name">String</span> phone<span class="token punctuation">,</span><span class="token class-name">String</span> email<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//优化后</span>  <span class="token keyword">boolean</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> sex<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> phone<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="11-勿用函数参数来控制逻辑"><a href="#11-勿用函数参数来控制逻辑" class="headerlink" title="11.勿用函数参数来控制逻辑"></a>11.勿用函数参数来控制逻辑</h2><ul><li>不要用boolean值控制内部逻辑(true走一个逻辑、false走另一个逻辑)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//例子：根据男女生做不同逻辑处理(分场景，不一定适用其他场景)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//优化前</span>  <span class="token keyword">void</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token keyword">boolean</span> isMale<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//优化后</span>  <span class="token keyword">void</span> <span class="token function">loginForMale</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">loginForFemale</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="12-移除过深的嵌套层次"><a href="#12-移除过深的嵌套层次" class="headerlink" title="12.移除过深的嵌套层次"></a>12.移除过深的嵌套层次</h2><ul><li>去掉多余的if/else语句</li><li>使用continue、break、return等提前退出嵌套</li><li>调整执行顺序来减少嵌套(如提前判空再执行正常逻辑)</li><li>for循环独立逻辑可抽出为一个个函数(参考自<code>《重构改善既有代码的设计》</code>)</li></ul><h2 id="13-学会使用解释性变量"><a href="#13-学会使用解释性变量" class="headerlink" title="13.学会使用解释性变量"></a>13.学会使用解释性变量</h2><ul><li><p>常量取代魔法数字</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//计算不同单位的毫秒值</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> ONE_DAY <span class="token operator">=</span> <span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> ONE_HOUR <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> ONE_MINUTE <span class="token operator">=</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用解释性变量来解释复杂表达式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//比如该例子的isToday就是解释性变量</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//判断是否当天</span>    <span class="token keyword">boolean</span> isToday <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Time</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBefore</span><span class="token punctuation">(</span><span class="token keyword">int</span> hour<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAfter</span><span class="token punctuation">(</span><span class="token keyword">int</span> hour<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码优化 </tag>
            
            <tag> 编程规范 </tag>
            
            <tag> 重构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原则与思想：规范与重构</title>
      <link href="/2021/12/03/she-ji-yuan-ze-yu-si-xiang-gui-fan-yu-chong-gou/"/>
      <url>/2021/12/03/she-ji-yuan-ze-yu-si-xiang-gui-fan-yu-chong-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="设计原则与思想：规则与重构"><a href="#设计原则与思想：规则与重构" class="headerlink" title="设计原则与思想：规则与重构"></a>设计原则与思想：规则与重构</h1><h2 id="理论一：重构的why、what、when、how"><a href="#理论一：重构的why、what、when、how" class="headerlink" title="理论一：重构的why、what、when、how"></a>理论一：重构的why、what、when、how</h2><h3 id="重构的目的：为什么重构（why）？"><a href="#重构的目的：为什么重构（why）？" class="headerlink" title="重构的目的：为什么重构（why）？"></a>重构的目的：为什么重构（why）？</h3><ul><li>对于项目而言，重构可以保持代码质量持续处于一个可控状态，不至于太糟糕(无可救药)</li><li>对于个人而言，重构非常锻炼一个人的代码能力(很有成就感)</li></ul><h3 id="重构的对象：重构什么（what）？"><a href="#重构的对象：重构什么（what）？" class="headerlink" title="重构的对象：重构什么（what）？"></a>重构的对象：重构什么（what）？</h3><ul><li><p>大规模高层次的重构</p><ul><li>代码分层</li><li>模块化</li><li>解耦</li><li>梳理类之间的交互关系</li><li>抽象复用组件</li><li>…</li></ul></li><li><p>小规模低层次的重构</p><ul><li>规范命名</li><li>注释</li><li>修正函数参数过多</li><li>消除超大类</li><li>提取重复代码</li><li>…</li></ul></li></ul><h3 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h3><ul><li>建立持续<code>重构</code>意识</li><li><code>重构</code>要融入日常开发中</li><li>而非等到代码出现大问题才<code>重构</code></li></ul><h3 id="重构的方法：如何重构（how）？"><a href="#重构的方法：如何重构（how）？" class="headerlink" title="重构的方法：如何重构（how）？"></a>重构的方法：如何重构（how）？</h3><ul><li>大规模高层次的重构<ul><li>有组织、有计划地进行</li><li>分阶段地小步快跑</li><li>时刻让代码处于一个可运行的状态</li></ul></li><li>小规模低层次的重构<ul><li>随时随地</li></ul></li></ul><h2 id="理论二：单元测试-保证重构不出错的技术手段"><a href="#理论二：单元测试-保证重构不出错的技术手段" class="headerlink" title="理论二：单元测试(保证重构不出错的技术手段)"></a>理论二：单元测试(保证重构不出错的技术手段)</h2><ul><li><strong>What</strong>：<ul><li>代码层面的测试，用来测试编写代码逻辑的正确性</li><li><strong>单元</strong>一般是类或函数，而不是模块或者系统</li></ul></li><li><strong>Why</strong>：<ul><li>写<code>单元测试</code>的过程本身就是代码Code Review和重构的过程，能有效发现代码中的BUG和代码设计上的问题</li><li><code>单元测试</code>是<code>集成测试</code>的有力补充</li><li>能帮助我们快速熟悉代码</li></ul></li><li><strong>How</strong>：<ul><li>针对代码设计各种测试用例，以覆盖各种输入、异常、边界情况，并翻译成代码</li><li><code>单元测试</code>不要依赖被测代码的具体实现逻辑</li><li>难以编写<code>单元测试</code>，往往是代码的可测试性不好(说明要重构了)</li></ul></li><li><strong>Example</strong>：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span><span class="token class-name">SpringRunner</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SppringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//测试getUserById接口是否正常</span>    <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token number">111L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//user不为空断言(如果为空会报错)</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="理论三：代码的可测试性"><a href="#理论三：代码的可测试性" class="headerlink" title="理论三：代码的可测试性"></a>理论三：代码的可测试性</h2><ul><li><strong>What</strong>：代码的可测试性，就是针对代码编写单元测试的难易程度。</li><li><strong>How</strong>：<code>依赖注入</code>是编写可测试性代码的最有效手段。(减少不必要的rpc耗时+自定义返回内容)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 一个电商系统的交易类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span>  <span class="token comment">//依赖的外部rpc接口(可能耗时长，不便于单测)</span>  <span class="token keyword">private</span> <span class="token class-name">WalletRpcService</span> walletRpcService<span class="token punctuation">;</span>  <span class="token comment">//通过外部set方法实现依赖注入(传递参数)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWalletRpcService</span><span class="token punctuation">(</span><span class="token class-name">WalletRpcService</span> walletRpcService<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>walletRpcService <span class="token operator">=</span> walletRpcService<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//交易方法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      walletRpcService<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * mock的rpc */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockWalletRpcService</span> <span class="token keyword">extends</span> <span class="token class-name">WalletRpcService</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span class="token comment">/** * 单元测试 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testExecute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Transaction</span> transaction <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//这里执行我们mock的类(可以自定义返回内容，而非调用实际的WalletRpcService返回不可控的内容以及不可控的耗时)</span>    transaction<span class="token punctuation">.</span><span class="token function">setWalletRpcService</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MockWalletRpcService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> result <span class="token operator">=</span> transaction<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//断言，如果result不为true则报错</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="常见的Anti-Patterns-反面模式"><a href="#常见的Anti-Patterns-反面模式" class="headerlink" title="常见的Anti-Patterns(反面模式)"></a>常见的Anti-Patterns(反面模式)</h3><ul><li><p>1.代码中包含未决行为逻辑(代码return是随机/不确定的)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * 计算入参早于当前时间多少天   * @param dueTime   * @return 每天返回的值不同   */</span>  <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">calculateDelayDays</span><span class="token punctuation">(</span><span class="token class-name">Date</span> dueTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> currentTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dueTime<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">long</span> delayTime <span class="token operator">=</span> currentTime <span class="token operator">-</span> dueTime<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> delayDays <span class="token operator">=</span> delayTime <span class="token operator">/</span> <span class="token number">86400</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> delayDays<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2.滥用可变全局变量(容易影响其他测试用例)<br>如果单元测试方法testAdd()和testReduce()是并发执行的，那么可能在assertEquals执行之前value就执行了一次add()和一次reduce()，那么结果就跟我们预期的不一样了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 简易计算器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//加法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> addValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token comment">//减法</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">int</span> reduceValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 单元测试 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CounterTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Counter</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    counter<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Counter</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    counter<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> counter<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>3.滥用静态方法(跟<code>2.滥用可变全局变量</code>类似)</p></li><li><p>4.使用复杂的继承关系(如果父类需要mock某个依赖对象，那么子类、子类的子类…都需要mock这个依赖对象，会很复杂)</p></li><li><p>5.高耦合代码(如果一个类依赖几十个外部对象，那我们编写单元测试的时候就可能需要mock几十个外部对象，复杂且不合理)</p></li></ul><h2 id="理论四：代码解耦"><a href="#理论四：代码解耦" class="headerlink" title="理论四：代码解耦"></a>理论四：代码解耦</h2><ul><li><strong>为什么要解耦？</strong><ul><li>过于复杂的代码往往可读性、可维护性不友好(解耦可以保证代码质量)</li><li>保证代码松耦合、高内聚(能有效控制代码复杂度)</li></ul></li><li><strong>怎么看是否需要解耦？</strong><ul><li>直接的衡量标准是把模块与模块、类与类自己的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构</li></ul></li><li><strong>怎么重构？</strong><ul><li>封装与抽象</li><li>中间层(如mq)</li><li>模块化</li><li>一些设计思想与原则<ul><li>单一职责原则</li><li>基于接口而非实现编程</li><li>依赖注入</li><li>多用组合少用继承</li><li>迪米特法则(不是很懂。。。。)</li></ul></li><li>设计模式(如观察者模式)</li></ul></li></ul><h2 id="理论五：快速改善代码质量的20条编程规范"><a href="#理论五：快速改善代码质量的20条编程规范" class="headerlink" title="理论五：快速改善代码质量的20条编程规范"></a>理论五：快速改善代码质量的20条编程规范</h2><p><a href="https://garyleeeee.github.io/2021/12/06/%E5%BF%AB%E9%80%9F%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%8420%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/">跳转查看：《快速改善代码质量的20条编程规范》</a></p><h2 id="实战一：如何发现代码质量问题"><a href="#实战一：如何发现代码质量问题" class="headerlink" title="实战一：如何发现代码质量问题"></a>实战一：如何发现代码质量问题</h2><p><img src="/images/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98-%E5%B8%B8%E8%A7%84checklist.png" alt="常规checklist"><br><img src="/images/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E9%97%AE%E9%A2%98-%E4%B8%9A%E5%8A%A1checklist.png" alt="业务checklist"></p><h2 id="实战二：如何处理程序出错的返回"><a href="#实战二：如何处理程序出错的返回" class="headerlink" title="实战二：如何处理程序出错的返回"></a>实战二：如何处理程序出错的返回</h2><ul><li><strong>1.返回错误码</strong><ul><li>是C语言最常用的出错处理方式</li><li>Java语言极少会用到错误码(异常)</li></ul></li><li><strong>2.返回NULL值</strong><ul><li>用来表示”不存在”这种语义</li><li>对于查找函数(如getxxx、queryxxx)来说，数据不存在是一种正常行为(并非异常情况)，所以返回NULL值更加合理</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//如果用户不存在，则返回null</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>3.返回空对象</strong><ul><li>针对<code>2.返回NULL值</code>的弊端：调用方容易不做判空导致出现NPE异常</li><li>对于字符串类型或者集合类型时，我们可以用空字符串或空集合替代NULL值(表示不存在)</li></ul></li><li><strong>4.抛出异常对象</strong><ul><li>直接吞掉(原地catch并打印错误日志)</li><li>直接往上抛出(当前方法不处理)</li><li>包裹成新的异常抛出(包装成通用的异常返回，不暴露实现细节)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原则与思想：设计原则</title>
      <link href="/2021/11/26/she-ji-yuan-ze-yu-si-xiang-she-ji-yuan-ze/"/>
      <url>/2021/11/26/she-ji-yuan-ze-yu-si-xiang-she-ji-yuan-ze/</url>
      
        <content type="html"><![CDATA[<h1 id="设计原则与思想：设计原则"><a href="#设计原则与思想：设计原则" class="headerlink" title="设计原则与思想：设计原则"></a>设计原则与思想：设计原则</h1><h2 id="理论一：单一职责原则"><a href="#理论一：单一职责原则" class="headerlink" title="理论一：单一职责原则"></a>理论一：单一职责原则</h2><ul><li><p><strong>1.如何理解单一职责原则？</strong></p><ul><li><strong>What</strong>：一个类只负责完成一个职责或者功能</li><li><strong>How</strong>：不要设计大而全的类-&gt;要设计粒度小、功能单一的类</li><li><strong>Why</strong>：实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性</li></ul></li><li><p><strong>2.如何判断类的职责是否足够单一？</strong><br>不同场景的判断标准不同，下面这些情况就有可能说明这类的设计不满足单一职责原则(不是绝对的)：</p><ul><li>类中代码行数过多、函数或者属性过多</li><li>类依赖或被依赖的其他类的过多</li><li>私有(<code>private</code>)方法过多-&gt;考虑抽取私有方法到新的类中并设置为public方法</li><li>类难命名(如只能命名为一些笼统的词语如Manager、Context等)</li><li>类大量方法都是集中操作类中的某几个属性(如用户信息UserInfo表中大部分在操作地址address信息则可以考虑抽出来)<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserInfo</span> <span class="token punctuation">{</span>    <span class="token comment">//用户基础信息</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> uid<span class="token punctuation">;</span><span class="token comment">//用户唯一id</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span><span class="token comment">//用户昵称</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token comment">//用户年龄</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span><span class="token comment">//用户注册时间</span>    <span class="token keyword">private</span> <span class="token class-name">Date</span> lastLoginTime<span class="token punctuation">;</span><span class="token comment">//用户最后登陆时间</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> avatarUrl<span class="token punctuation">;</span><span class="token comment">//用户头像</span>        <span class="token comment">//地址相关信息</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> provinceOfAddress<span class="token punctuation">;</span><span class="token comment">//省</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> cityOfAdddress<span class="token punctuation">;</span><span class="token comment">//市</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> regionOfAddress<span class="token punctuation">;</span><span class="token comment">//区</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> detailedAddress<span class="token punctuation">;</span><span class="token comment">//详细地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>3.类的职责是否设计得越单一越好？</strong><br>如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性</p></li></ul><h2 id="理论二：开闭原则-对扩展开放、修改关闭"><a href="#理论二：开闭原则-对扩展开放、修改关闭" class="headerlink" title="理论二：开闭原则(对扩展开放、修改关闭)"></a>理论二：开闭原则(对扩展开放、修改关闭)</h2><ul><li><p><strong>1.如何理解”对扩展开放、修改关闭”？</strong><br>添加一个新的功能，<br>应该是通过在已有代码基础上扩展代码(新增模块、类、方法、属性等)， //<code>对扩展开发</code><br>而非修改已有代码(修改模块、类、方法、属性)                   //<code>对修改关闭</code></p></li><li><p><strong>2.如何做到”对扩展开发、修改关闭”？</strong></p><ul><li>时刻具备扩展意识、抽象意识、封装意识</li><li>写代码时候思考未来可能有哪些需求变更</li><li>思考如何设计代码结构，事先留好扩展点</li><li>保证在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，插入新的代码</li></ul></li><li><p><strong>3.常见的提高代码扩展性的方法</strong></p><ul><li>多态</li><li>依赖注入(DI)</li><li>基础接口而非实现编程</li><li>大部分的设计模式(如装饰、策略、模板、责任连、状态)</li></ul></li></ul><h2 id="理论三：里式替换原则-LSP"><a href="#理论三：里式替换原则-LSP" class="headerlink" title="理论三：里式替换原则(LSP)"></a>理论三：里式替换原则(LSP)</h2><ul><li><strong>What</strong>：<code>里式替换原则</code>是用来指导，继承关系中子类该如何设计的一个原则。(design by contract,按照协议来设计)</li><li><strong>How</strong>：父类定义了函数的”约定”(或者叫协议)，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的”约定”。这里的约定包括：<ul><li>函数声明要实现的功能  //比如父类中提供了<code>sortOrdersByAmount()</code>订单排序函数是按照金额从小到大排序的，而如果子类重写该函数是按照日期(而非原本的金额)来排序，那么就是违背<code>里式替换原则</code></li><li>对输入、输出、异常的约定 //比如父类约定运行出错返回null，而子类运行出错抛异常，那么就是违背<code>里式替换原则</code></li><li>注释罗列的任何特殊说明 //比如父类<code>withdraw()</code>提醒函数写了注释”用户提现金额不得超过账户余额”，而子类重写该函数后针对VIP账号实现了透支提现的功能(也就是提醒金额可以大于账户金额)，那么就是违背<code>里式替换原则</code></li></ul></li><li><strong>Why</strong>：<code>里式替换原则</code>是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</li></ul><h2 id="理论四：接口隔离原则-ISP"><a href="#理论四：接口隔离原则-ISP" class="headerlink" title="理论四：接口隔离原则(ISP)"></a>理论四：接口隔离原则(ISP)</h2><ul><li><strong>What</strong>：<code>接口隔离原则</code>即”Interface Segregation Principle”(缩写为ISP)。直白来说，就是客户端不应该强迫依赖它不需要的接口。</li><li><strong>Why</strong>：<ul><li>防止误操作(如误删用户)</li><li>更细粒度，会更加灵活、易扩展、易复用</li><li>调用方无需引用+理解没必要的接口</li></ul></li><li><strong>Example</strong>：<ul><li>不使用ISP时<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//注册</span>  <span class="token keyword">boolean</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//登陆</span>  <span class="token keyword">boolean</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//查询用户</span>  <span class="token class-name">User</span> <span class="token function">getUserByUid</span><span class="token punctuation">(</span><span class="token keyword">long</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//删除(敏感操作，理论上只能在后台操作)</span>  <span class="token keyword">boolean</span> <span class="token function">deleteUserByUid</span><span class="token punctuation">(</span><span class="token keyword">long</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用ISP时<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token comment">//注册</span>  <span class="token keyword">boolean</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//登陆</span>  <span class="token keyword">boolean</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//查询用户</span>  <span class="token class-name">User</span> <span class="token function">getUserByUid</span><span class="token punctuation">(</span><span class="token keyword">long</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//为了防止误操作，我们应该把用户操作的API和后台操作的API隔离开(为了防止调用UserService的误使用deleteUserByUid引起安全隐患)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AdminUserService</span> <span class="token punctuation">{</span>  <span class="token comment">//删除(敏感操作，理论上只能在后台操作)</span>  <span class="token keyword">boolean</span> <span class="token function">deleteUserByUid</span><span class="token punctuation">(</span><span class="token keyword">long</span> uid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span><span class="token punctuation">,</span><span class="token class-name">AdminUserService</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="理论五：依赖反转原则-DIP"><a href="#理论五：依赖反转原则-DIP" class="headerlink" title="理论五：依赖反转原则(DIP)"></a>理论五：依赖反转原则(DIP)</h2><h3 id="1-控制反转-IOC"><a href="#1-控制反转-IOC" class="headerlink" title="1.控制反转(IOC)"></a>1.控制反转(IOC)</h3><ul><li><p><strong>控制</strong>：指的是对程序执行流程的控制</p></li><li><p><strong>反转</strong></p><ul><li><p><strong>没使用框架前</strong>：程序员自己控制整个程序的执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">doTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">doTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用框架后</strong>：整个程序的执行流程通过框架来控制(流程的控制权从程序员<code>反转</code>给了框架)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">TestCase</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">doTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">doTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//我们只需要在框架预留的扩展点(也就是TestCase类中的doTest()抽象函数中填充具体测试代码就能模拟单元测试了)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceTest</span> <span class="token keyword">extends</span> <span class="token class-name">TestCase</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">doTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//抽象出来的框架</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JUnitApplication</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestCase</span><span class="token punctuation">&gt;</span></span> testCases <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">TestCase</span> testCase<span class="token punctuation">)</span> <span class="token punctuation">{</span>    testCases<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>testCase<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//添加需要测试的类</span>    <span class="token class-name">JUnitApplication</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserServiceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//控制反转式"测试"</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TestCase</span> testCase <span class="token operator">:</span> testCases<span class="token punctuation">)</span> <span class="token punctuation">{</span>      testCase<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="2-依赖注入-DI"><a href="#2-依赖注入-DI" class="headerlink" title="2.依赖注入(DI)"></a>2.依赖注入(DI)</h3><ul><li><p><strong>What</strong>：不通过<code>new</code>的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好，通过构造函数等方式传递(或注入)给类使用</p></li><li><p><strong>How</strong>：通过一个邮箱系统来讲解</p><ul><li><p><strong>不使用DI</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//邮箱</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MailBox</span> <span class="token punctuation">{</span>  <span class="token comment">//发送邮件的工具</span>  <span class="token class-name">MailSender</span> mailSender<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">MailBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mailSender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MailSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestApplication</span> <span class="token punctuation">{</span>  <span class="token comment">//构造MailBox的时候内部会自己new一个MailSender</span>  <span class="token class-name">MailBox</span> mailBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MailBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>使用DI</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//邮箱</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MailBox</span> <span class="token punctuation">{</span>  <span class="token comment">//发送邮件的工具</span>  <span class="token class-name">MailSender</span> mailSender<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">MailBox</span><span class="token punctuation">(</span><span class="token class-name">MailSender</span> mailSender<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>mailSender <span class="token operator">=</span> mailSender<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestApplication</span> <span class="token punctuation">{</span>  <span class="token comment">//先初始化内部依赖的对象</span>  <span class="token class-name">MailSender</span> mailSender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MailSender</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//再通过构造方法传递</span>  <span class="token class-name">MailBox</span> mailBox <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MailBox</span><span class="token punctuation">(</span>mailSender<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="3-依赖注入框架-DI-Framework"><a href="#3-依赖注入框架-DI-Framework" class="headerlink" title="3.依赖注入框架(DI Framework)"></a>3.依赖注入框架(DI Framework)</h3><ul><li>简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现如下内容(原本需要程序员做的事情)<ul><li>由框架来自动创建对象</li><li>由框架来管理对象的生命周期</li><li>由框架来管理对象的依赖注入</li></ul></li></ul><h3 id="4-依赖反转原则-DIP"><a href="#4-依赖反转原则-DIP" class="headerlink" title="4.依赖反转原则(DIP)"></a>4.依赖反转原则(DIP)</h3><ul><li><strong>What</strong>：<ul><li><code>依赖反转原则</code>也叫做<code>依赖倒置原则</code></li><li>用来指导框架层面的设计</li></ul></li><li><strong>How</strong>：<ul><li>高层模块不依赖低层模块，它们共同依赖同一个抽象</li><li>抽象不要依赖具体实现细节，具体实现细节依赖对象</li></ul></li><li><strong>Example</strong>：<ul><li>Tomcat是运行Java Web应用程序的容器</li><li>应用程序可以部署在Tomcat容器上，便可被Tomcat容器调用执行</li><li>Tomcat是高层模块，应用程序是低层模块</li><li>Tomcat和应用程序代码之间没有直接的依赖关系，两者都依赖同一个”抽象”(也就是Servlet规范)</li><li>Servlet规范不依赖具体的Tomcat容器和应用程序的实现细节，而Tomcat容器和应用程序依赖Servlet规范</li></ul></li></ul><h2 id="先跳过"><a href="#先跳过" class="headerlink" title="先跳过"></a>先跳过</h2><h3 id="理论六：KISS、YAGNI原则"><a href="#理论六：KISS、YAGNI原则" class="headerlink" title="理论六：KISS、YAGNI原则"></a>理论六：KISS、YAGNI原则</h3><h3 id="理论七：DRY原则"><a href="#理论七：DRY原则" class="headerlink" title="理论七：DRY原则"></a>理论七：DRY原则</h3><h3 id="理论八：LOD原则"><a href="#理论八：LOD原则" class="headerlink" title="理论八：LOD原则"></a>理论八：LOD原则</h3><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计原则与思想：面向对象</title>
      <link href="/2021/11/13/she-ji-yuan-ze-yu-si-xiang-mian-xiang-dui-xiang/"/>
      <url>/2021/11/13/she-ji-yuan-ze-yu-si-xiang-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="设计原则与思想：面向对象"><a href="#设计原则与思想：面向对象" class="headerlink" title="设计原则与思想：面向对象"></a>设计原则与思想：面向对象</h1><h2 id="理论一：面向对象"><a href="#理论一：面向对象" class="headerlink" title="理论一：面向对象"></a>理论一：面向对象</h2><p>概念：面向对象编程是一种编程范式或编程风格，它以类或对象作为组织代码的基本单元<br>特性：封装、抽象、继承、多态<br>区别：<strong>面向对象分析</strong>就是要搞清楚做什么，<strong>面向对象设计</strong>就是要搞清楚怎么做，<strong>面向对象编程</strong>就是将<strong>分析</strong>和<strong>设计</strong>的结果翻译成代码的过程</p><h2 id="理论二：封装、抽象、继承、多态"><a href="#理论二：封装、抽象、继承、多态" class="headerlink" title="理论二：封装、抽象、继承、多态"></a>理论二：封装、抽象、继承、多态</h2><ul><li><strong>封装</strong><ul><li><strong>What</strong>：隐藏信息，保护数据访问(如private)</li><li><strong>How</strong>：暴露有限接口和属性，需要编程语音提供访问控制的语法(如Jva提供private/protected/public等)</li><li><strong>Why</strong>：提高代码可维护性，降低接口复杂度，提高类的易用性</li><li><strong>白话总结</strong>：可通过暴露出来的方法来访问数据(如public)，而屏蔽其不可修改的属性(如private)</li></ul></li><li><strong>抽象</strong><ul><li><strong>What</strong>：隐藏具体实现，使用者只需关心功能，无需关心实现</li><li><strong>How</strong>：通过接口类(interface)或者抽象类(abstract)实现，特殊语法机制非必需</li><li><strong>Why</strong>：提高代码的扩展性、维护性，降低复杂度，减少细节负担</li><li><strong>白话总结</strong>：使用者只需关心功能，无需关心实现</li></ul></li><li><strong>继承</strong><ul><li><strong>What</strong>：表示<code>is-a</code>关系(指的是类的父子继承关系)，分为单继承(如Java)和多继承(如C++)</li><li><strong>How</strong>：需要编程语言提供特殊语法机制(如Java的<code>extend</code>，C++的<code>:</code>)</li><li><strong>Why</strong>：解决代码复用问题</li><li><strong>白话总结</strong>：比如Cat继承自Animal，父类(Animal)有动物的共同特性(如吃饭睡觉)，子类(Cat)可有单独的特性(如卖萌)</li></ul></li><li><strong>多态</strong><ul><li><strong>What</strong>：子类替换父类，在运行时调用子类的实现</li><li><strong>How</strong>：需要编程语言提供特殊语法技术(如支持继承、支持父类引用子类、支持子类重写父类方法等)</li><li><strong>Why</strong>：提高代码扩展性和复用性</li><li><strong>白话总结</strong>：如<code>Animal animal = new Cat();</code>，调用animal的方法反映的是Cat的特性<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//叫声</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"default"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//不同子类会有自己的name(多态)</span>  <span class="token keyword">return</span> <span class="token string">"猫"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//不同子类会有自己的叫声(多态)</span>  <span class="token keyword">return</span> <span class="token string">"喵"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="理论三：面向对象相比面向过程有哪些优势？"><a href="#理论三：面向对象相比面向过程有哪些优势？" class="headerlink" title="理论三：面向对象相比面向过程有哪些优势？"></a>理论三：面向对象相比面向过程有哪些优势？</h2><ul><li><p>概念</p><ul><li><code>面向对象编程</code>以类为组织代码的基本单元</li><li><code>面向过程编程</code>以过程/方法作为租住代码的基本单元</li></ul></li><li><p><code>面向对象编程</code>比起<code>面向过程编程</code>的优势</p><ul><li>更能应对复杂类型的程序开发(对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结果)</li><li>编写的代码更加易扩展、易复用、易维护(具有丰富的特性如封装、抽象、继承、多态)</li><li>更加人性化、更加高级、更加智能(从编程语言与机器打交道的方式演进规律总结)</li></ul></li><li><p>代码区别例子</p><ul><li><code>面向过程编程</code>(如C语言)<pre class="line-numbers language-none"><code class="language-none">struct User {  char name[64];  int age;  char gender[16];};struct User parse_to_user(char* text) {  // 将text(“小王&amp;28&amp;男”)解析成结构体struct User}char* format_to_text(struct User user) {  // 将结构体struct User格式化成文本（"小王\t28\t男"）}void sort_users_by_age(struct User users[]) {  // 按照年龄从小到大排序users}void format_user_file(char* origin_file_path, char* new_file_path) {  // open files...  struct User users[1024]; // 假设最大1024个用户  int count = 0;  while(1) { // read until the file is empty    struct User user = parse_to_user(line);    users[count++] = user;  }    sort_users_by_age(users);    for (int i = 0; i &lt; count; ++i) {    char* formatted_user_text = format_to_text(users[i]);    // write to new file...  }  // close files...}int main(char** args, int argv) {  format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><code>面向对象编程</code>(Java语言)<pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> gender<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> gender<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>gender <span class="token operator">=</span> gender<span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">User</span> <span class="token function">praseFrom</span><span class="token punctuation">(</span><span class="token class-name">String</span> userInfoText<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将text(“小王&amp;28&amp;男”)解析成类User</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">formatToText</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 将类User格式化成文本（"小王\t28\t男"）</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserFileFormatter</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token class-name">String</span> userFile<span class="token punctuation">,</span> <span class="token class-name">String</span> formattedUserFile<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// Open files...</span>    <span class="token class-name">List</span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// read until file is empty </span>      <span class="token comment">// read from file into userText...</span>      <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token function">parseFrom</span><span class="token punctuation">(</span>userText<span class="token punctuation">)</span><span class="token punctuation">;</span>      users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// sort users by age...</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> users<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">String</span> formattedUserText <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">formatToText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// write to new file...</span>    <span class="token punctuation">}</span>    <span class="token comment">// close files...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainApplication</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">UserFileFormatter</span> userFileFormatter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserFileFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userFileFormatter<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"/home/zheng/users.txt"</span><span class="token punctuation">,</span> <span class="token string">"/home/zheng/formatted_users.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="理论四：反面向对象编程风格的代码"><a href="#理论四：反面向对象编程风格的代码" class="headerlink" title="理论四：反面向对象编程风格的代码"></a>理论四：反面向对象编程风格的代码</h2><h3 id="1-滥用getter、setter方法"><a href="#1-滥用getter、setter方法" class="headerlink" title="1.滥用getter、setter方法"></a>1.滥用getter、setter方法</h3><p><strong>背景/现象</strong>：大部分情况为了快速开发，都会给类所有属性都加上getter、setter方法(或者使用Lombok注解)<br><strong>优化</strong>：设计实现类的时候，非必要的时候尽量不要给属性定义setter方法(避免乱修改)，同时如果getter返回的是集合容器也需防范集合内部数据被修改的风险(如List可以取到其中的对象修改属性如name)<br><strong>优点</strong>：尽可能保证数据安全<br><strong>优化前的例子</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 购物车 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShoppingCar</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">double</span> totalPrice<span class="token punctuation">;</span><span class="token comment">//总金额</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> itemCount<span class="token punctuation">;</span><span class="token comment">//商品数量</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingItem</span><span class="token punctuation">&gt;</span></span> items<span class="token punctuation">;</span><span class="token comment">//商品列表</span>  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> totalPrice<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//虽然totalPrice属性定义了private，但是却提供了public的set方法，导致totalPrice可以被随意修改(不符合逻辑)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTotalPrice</span><span class="token punctuation">(</span><span class="token keyword">double</span> totalPrice<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>totalPrice <span class="token operator">=</span> totalPrice<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getItemCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> itemCount<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//虽然itemCount属性定义了private，但是却提供了public的set方法，导致itemCount可以被随意修改(不符合逻辑)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setItemCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> itemCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>itemCount <span class="token operator">=</span> itemCount<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingItem</span><span class="token punctuation">&gt;</span></span> <span class="token function">getItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//返回一个不可修改的集合容器(防止外部直接操作容器如add、clear等)</span>    <span class="token keyword">return</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableList</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//虽然items属性定义了private，但是却提供了public的set方法，导致items可以被随意修改(不符合逻辑)</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setItems</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingItem</span><span class="token punctuation">&gt;</span></span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> items<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化后的例子</strong>： </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 购物车 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShoppingCar</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">double</span> totalPrice<span class="token punctuation">;</span><span class="token comment">//总金额</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> itemCount<span class="token punctuation">;</span><span class="token comment">//商品数量</span>  <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingItem</span><span class="token punctuation">&gt;</span></span> items<span class="token punctuation">;</span><span class="token comment">//商品列表</span>  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> totalPrice<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getItemCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> itemCount<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ShoppingItem</span><span class="token punctuation">&gt;</span></span> <span class="token function">getItems</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> items<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addItem</span><span class="token punctuation">(</span><span class="token class-name">ShoppingItem</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>      itemCount<span class="token operator">++</span><span class="token punctuation">;</span>      totalAmount<span class="token operator">+=</span>item<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment">//...省略其他代码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Constants类、Utils类的设计问题"><a href="#2-Constants类、Utils类的设计问题" class="headerlink" title="2.Constants类、Utils类的设计问题"></a>2.Constants类、Utils类的设计问题</h3><p><strong>背景/现象</strong>：平时为了统一管理常量，我们会定义一个大而全的<code>Constants</code>类、<code>Utils</code>类<br><strong>优化</strong>：定义细化的小类，如<code>RedisConstants</code>类、<code>FileUtils</code>类，一个类只负责一个/多个同场景的功能<br><strong>优点</strong>：尽量做到职责单一，提高类的内聚性和代码的可复用性<br><strong>优化前的例子</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Constants</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * mysql相关常量   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_ADDRESS <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_PORT <span class="token operator">=</span> <span class="token string">"8086"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_USERNAME <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_PASSWORD <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">;</span>  <span class="token comment">/**   * rabbitmq相关常量   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RABBITMQ_QUEUE <span class="token operator">=</span> <span class="token string">"rabbitmq_queue"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RABBITMQ_EXCHANGE <span class="token operator">=</span> <span class="token string">"rabbitmq_exchange"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RABBITMQ_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"rabbitmq_routing_key"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化后的代码</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MysqlConstants</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * mysql相关常量   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_ADDRESS <span class="token operator">=</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_PORT <span class="token operator">=</span> <span class="token string">"8086"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_USERNAME <span class="token operator">=</span> <span class="token string">"root"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> MYSQL_PASSWORD <span class="token operator">=</span> <span class="token string">"admin"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitmqConstants</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * rabbitmq相关常量   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RABBITMQ_QUEUE <span class="token operator">=</span> <span class="token string">"rabbitmq_queue"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RABBITMQ_EXCHANGE <span class="token operator">=</span> <span class="token string">"rabbitmq_exchange"</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> RABBITMQ_ROUTING_KEY <span class="token operator">=</span> <span class="token string">"rabbitmq_routing_key"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-基于贫血模型的开发模式"><a href="#3-基于贫血模型的开发模式" class="headerlink" title="3.基于贫血模型的开发模式"></a>3.基于贫血模型的开发模式</h3><p><strong>背景/现象</strong>：定义数据和方法分离的类(常见的就是MVC模式)<br><strong>优化</strong>：暂不优化<br><strong>优点</strong>：代码解耦、提高扩展性和可读性<br><strong>例子</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 实体类 */</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * Service */</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 控制层 */</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@AutoWired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>        <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/getUser"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="理论五：接口和抽象类的区别"><a href="#理论五：接口和抽象类的区别" class="headerlink" title="理论五：接口和抽象类的区别"></a>理论五：接口和抽象类的区别</h2><ul><li><p><strong>接口</strong></p><ul><li>定义：如java中的interface类，也叫做协议contract</li><li>存在意义：是一种<code>has-a</code>关系，是为了解决代码解耦问题(表示具有某一组行为特性，隔离接口和具体的实现，提高代码的扩展性)</li><li>不能包含属性，只能声明方法(不能包含代码实现)</li><li>类实现(implements)<code>接口</code>的时候，必须实现<code>接口</code>中声明的所有方法</li></ul></li><li><p><strong>抽象类</strong></p><ul><li>定义：如java中的abstract类</li><li>存在意义：是一种<code>is-a</code>关系，是为了解决代码复用问题</li><li>可以包含属性和方法(可包含代码实现也可以不包含)</li><li>抽象方法：不包含代码实现的方法(关键字<code>abstract</code>，子类继承抽象类<strong>必须实现</strong>抽象类中的所有抽象方法)</li><li>不允许被实例化(new)，只能被继承(extends)</li></ul></li><li><p><strong>总结</strong></p><ul><li>使用场景： 如果要表示一种<code>is-a</code>的关系，并且是为了解决代码复用问题，就用<code>抽象类</code>；如果要表示一种<code>has-a</code>的关系，并且是为了解决代码复用问题，就用<code>接口</code></li><li>使用规则： <code>抽象类</code>只能单继承，<code>接口</code>可以多实现</li></ul></li></ul><h2 id="理论六：基于接口而非实现编程"><a href="#理论六：基于接口而非实现编程" class="headerlink" title="理论六：基于接口而非实现编程"></a>理论六：基于接口而非实现编程</h2><ul><li><strong>基于接口而非实现编程</strong>：也可叫做<strong>基于抽象而非实现编程</strong>。<ul><li>我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识</li><li>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性、扩展性、可维护性</li></ul></li><li>定义接口的规范<ul><li>命名要足够通用，不能包含跟具体实现相关的字眼</li><li>与特定实现有关的方法不要定义在接口中</li></ul></li><li>不仅可以指导非常细节的编程卡法，还能指导更加上层的架构设计、系统设计等。比如服务端与客户端之间的”接口”设计、类库的”接口”设计。</li><li>实战模拟：图片的上传与下载<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliyunImageStore</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * 根基accessKey/serectKey等生成access token   * @return   */</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">/**   * 上传图片到阿里云   * @param image   * @param bucketName   * @param accessToken   * @return 图片存储在阿里云上的地址   */</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">uploadToAliyun</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">,</span> <span class="token class-name">String</span> accessToken<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">/**   * 从阿里云下载图片   * @param url   * @param accessToken   * @return   */</span>  <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">downloadFromAliyun</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">,</span> <span class="token class-name">String</span> accessToken<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>上面的代码是一个简单的基于阿里云的图片上传与下载功能。<br>接口设计看起来并没有太大问题，但是软件开发中唯一不变的就是变化。<br>如果过了一段时间，我们自建了私有云，不再将图片存储到艾丽云，而是将图片存储到自建私有云上。</li></ul><p><strong>问题</strong>：原先的接口命名暴露了实现细节(aliyun)，如果复用的话需要修改命名，那么这样对于调用该代码的地方修改量会很大<br><strong>解决</strong>：阿里云和私有云存储图片基本一致(阿里云需要access token而私有云不需要)，所以我们可以考虑抽一个顶层接口类，来屏蔽特定实现细节(如access token)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ImageStore</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Image</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * 阿里云图片存储(需access token) */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliyunImageStore</span> <span class="token keyword">implements</span> <span class="token class-name">ImageStore</span> <span class="token punctuation">{</span>  <span class="token comment">/**   * 根基accessKey/serectKey等生成access token   * @return   */</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> accessToken <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> accessToken <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">generateAccessToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//...</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * 私有云图片存储(不需access token) */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrivateImageStore</span> <span class="token keyword">implements</span> <span class="token class-name">ImageStore</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token class-name">Image</span> image<span class="token punctuation">,</span> <span class="token class-name">String</span> bucketName<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token class-name">Image</span> <span class="token function">download</span><span class="token punctuation">(</span><span class="token class-name">String</span> url<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="理论七：多用组合少用继承？-ps-不是很明白组合是什么场景好用"><a href="#理论七：多用组合少用继承？-ps-不是很明白组合是什么场景好用" class="headerlink" title="理论七：多用组合少用继承？(ps.不是很明白组合是什么场景好用)"></a>理论七：多用组合少用继承？(ps.不是很明白组合是什么场景好用)</h2><h3 id="1-为什么不推荐使用继承？"><a href="#1-为什么不推荐使用继承？" class="headerlink" title="1.为什么不推荐使用继承？"></a>1.为什么不推荐使用继承？</h3><ul><li>虽然继承有诸多作用，但继承层次过深、过复杂</li><li>会影响代码的可维护性</li></ul><h3 id="2-组合相比继承有哪些优势？"><a href="#2-组合相比继承有哪些优势？" class="headerlink" title="2.组合相比继承有哪些优势？"></a>2.组合相比继承有哪些优势？</h3><ul><li><code>继承</code>主要有三个作用：<ul><li>表示<code>is-a</code>关系</li><li>支持多态特性</li><li>代码复用</li></ul></li><li><code>组合</code>优势<ul><li>可以通过和<strong>接口</strong>、<strong>委托</strong>三个技术手段来达成<code>继承</code>的三个作用(在上面)</li><li>可以解决层次过深、过复杂的继承关系影响代码可维护性的问题</li></ul></li></ul><h3 id="3-如何判断该用组合还是继承？"><a href="#3-如何判断该用组合还是继承？" class="headerlink" title="3.如何判断该用组合还是继承？"></a>3.如何判断该用组合还是继承？</h3><ul><li>使用<code>继承</code>的场景<ul><li>类之间的继承结构稳定</li><li>类之间的层次比较浅</li><li>类之间的关系不复杂</li></ul></li><li>使用<code>组合</code>的场景<ul><li>类之间的继承结构不稳定</li><li>类之间的层次比较深</li><li>类之间的关系复杂</li></ul></li></ul><h2 id="实战篇-暂时跳过"><a href="#实战篇-暂时跳过" class="headerlink" title="实战篇(暂时跳过)"></a>实战篇(暂时跳过)</h2><h3 id="实战一-上-：基于贫血模型的MVC架构违背OOP吗？"><a href="#实战一-上-：基于贫血模型的MVC架构违背OOP吗？" class="headerlink" title="实战一(上)：基于贫血模型的MVC架构违背OOP吗？"></a>实战一(上)：基于贫血模型的MVC架构违背OOP吗？</h3><h3 id="实战一-下-：利用利于充血模型的DDD开发一个虚拟钱包系统？"><a href="#实战一-下-：利用利于充血模型的DDD开发一个虚拟钱包系统？" class="headerlink" title="实战一(下)：利用利于充血模型的DDD开发一个虚拟钱包系统？"></a>实战一(下)：利用利于充血模型的DDD开发一个虚拟钱包系统？</h3><h3 id="实战二-上-：对接口鉴权做面向对象分析"><a href="#实战二-上-：对接口鉴权做面向对象分析" class="headerlink" title="实战二(上)：对接口鉴权做面向对象分析"></a>实战二(上)：对接口鉴权做面向对象分析</h3><h3 id="实战二-下-：利用面向对象设计和编程开发接口鉴权功能"><a href="#实战二-下-：利用面向对象设计和编程开发接口鉴权功能" class="headerlink" title="实战二(下)：利用面向对象设计和编程开发接口鉴权功能"></a>实战二(下)：利用面向对象设计和编程开发接口鉴权功能</h3>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-Plus使用笔记</title>
      <link href="/2021/11/09/mybatis-plus-shi-yong-bi-ji/"/>
      <url>/2021/11/09/mybatis-plus-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、官方文档"><a href="#一、官方文档" class="headerlink" title="一、官方文档"></a>一、官方文档</h2><p><a href="https://baomidou.com/">https://baomidou.com/</a></p><h2 id="二、怎么使用"><a href="#二、怎么使用" class="headerlink" title="二、怎么使用"></a>二、怎么使用</h2><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!-- MybatisPlus --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-添加配置"><a href="#2-添加配置" class="headerlink" title="2.添加配置"></a>2.添加配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Mybatis-plus</span><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token comment"># 放在resource目录 classpath:/mapper/*Mapper.xml</span>  <span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>/mybatis/mapper/<span class="token important">*Mapper.xml</span>  <span class="token comment"># 实体扫描，多个package用逗号或者分号分隔</span>  <span class="token key atrule">typeAliasesPackage</span><span class="token punctuation">:</span> com.yy.mobilevoice.svc.diversion.model.domain  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token comment"># 主键类型  0:"数据库ID自增", 1:"用户输入ID",2:"全局唯一ID (数字类型唯一ID)", 3:"全局唯一ID UUID";</span>    <span class="token key atrule">id-type</span><span class="token punctuation">:</span> <span class="token number">2</span>    <span class="token comment"># 字段策略 0:"忽略判断",1:"非 NULL 判断",2:"非空判断"</span>    <span class="token key atrule">field-strategy</span><span class="token punctuation">:</span> <span class="token number">2</span>    <span class="token comment"># 驼峰下划线转换</span>    <span class="token key atrule">db-column-underline</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token comment"># 刷新mapper 调试神器</span>    <span class="token key atrule">refresh-mapper</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token comment"># 数据库大写下划线转换</span>    <span class="token comment">#capital-mode: true</span>    <span class="token comment"># 逻辑删除配置（下面3个配置）</span>    <span class="token key atrule">logic-delete-value</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token key atrule">logic-not-delete-value</span><span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token comment"># SQL 解析缓存，开启后多租户 @SqlParser 注解生效</span>    <span class="token key atrule">sql-parser-cache</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">map-underscore-to-camel-case</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">cache-enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-常见注解-更多查看文档"><a href="#3-常见注解-更多查看文档" class="headerlink" title="3.常见注解(更多查看文档)"></a>3.常见注解(更多查看文档)</h3><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@MapperScan(“com.demo.mapper”)</td><td>扫描该目录下的mapper接口都会自动生成实现类(等同于一个个加@Mapper)</td></tr><tr><td>@TableName(“tableName”)</td><td>用于标识数据库表对应的实体类</td></tr></tbody></table><h3 id="4-如何使用多数据源？"><a href="#4-如何使用多数据源？" class="headerlink" title="4.如何使用多数据源？"></a>4.如何使用多数据源？</h3><h4 id="a-添加依赖"><a href="#a-添加依赖" class="headerlink" title="a.添加依赖"></a>a.添加依赖</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>dynamic-datasource-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="b-添加数据源"><a href="#b-添加数据源" class="headerlink" title="b.添加数据源"></a>b.添加数据源</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">dynamic</span><span class="token punctuation">:</span>      <span class="token key atrule">primary</span><span class="token punctuation">:</span> master <span class="token comment">#设置默认的数据源或者数据源组,默认值即为master</span>      <span class="token key atrule">strict</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment">#严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源</span>      <span class="token key atrule">datasource</span><span class="token punctuation">:</span>        <span class="token key atrule">master</span><span class="token punctuation">:</span>          <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//xx.xx.xx.xx<span class="token punctuation">:</span>3306/dynamic          <span class="token key atrule">username</span><span class="token punctuation">:</span> root          <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>          <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver <span class="token comment"># 3.2.0开始支持SPI可省略此配置</span>        <span class="token key atrule">slave_1</span><span class="token punctuation">:</span>          <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//xx.xx.xx.xx<span class="token punctuation">:</span>3307/dynamic          <span class="token key atrule">username</span><span class="token punctuation">:</span> root          <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>          <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver        <span class="token key atrule">slave_2</span><span class="token punctuation">:</span>          <span class="token key atrule">url</span><span class="token punctuation">:</span> ENC(xxxxx) <span class="token comment"># 内置加密,使用请查看详细文档</span>          <span class="token key atrule">username</span><span class="token punctuation">:</span> ENC(xxxxx)          <span class="token key atrule">password</span><span class="token punctuation">:</span> ENC(xxxxx)          <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver       <span class="token comment">#......省略</span>       <span class="token comment">#以上会配置一个默认库master，一个组slave下有两个子库slave_1,slave_2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 多主多从</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">dynamic</span><span class="token punctuation">:</span>      <span class="token key atrule">datasource</span><span class="token punctuation">:</span>        <span class="token key atrule">master_1</span><span class="token punctuation">:</span>        <span class="token key atrule">master_2</span><span class="token punctuation">:</span>        <span class="token key atrule">slave_1</span><span class="token punctuation">:</span>        <span class="token key atrule">slave_2</span><span class="token punctuation">:</span>        <span class="token key atrule">slave_3</span><span class="token punctuation">:</span>                                                                                      <span class="token comment"># 纯粹多库（记得设置primary）</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">dynamic</span><span class="token punctuation">:</span>      <span class="token key atrule">datasource</span><span class="token punctuation">:</span>        <span class="token key atrule">mysql</span><span class="token punctuation">:</span>         <span class="token key atrule">oracle</span><span class="token punctuation">:</span>        <span class="token key atrule">sqlserver</span><span class="token punctuation">:</span>        <span class="token key atrule">postgresql</span><span class="token punctuation">:</span>        <span class="token key atrule">h2</span><span class="token punctuation">:</span><span class="token comment"># 混合配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">dynamic</span><span class="token punctuation">:</span>      <span class="token key atrule">datasource</span><span class="token punctuation">:</span>        <span class="token key atrule">master</span><span class="token punctuation">:</span>        <span class="token key atrule">slave_1</span><span class="token punctuation">:</span>        <span class="token key atrule">slave_2</span><span class="token punctuation">:</span>        <span class="token key atrule">oracle_1</span><span class="token punctuation">:</span>        oracle_2<span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="c-使用-DS-切换数据源"><a href="#c-使用-DS-切换数据源" class="headerlink" title="c.使用 @DS 切换数据源"></a>c.使用 <strong>@DS</strong> 切换数据源</h4><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>没有@DS</td><td>默认数据源(即<code>spring.datasource.dynamic.primary</code>)</td></tr><tr><td>@DS(“name”)</td><td><code>name</code>可以为组别/某个库名(如<code>master</code>)</td></tr></tbody></table><p><strong>@DS 可以注释在方法上或类上，同时存在就近原则，即方法上注解优先于类上注解(如下面代码<code>selectByCondition()</code>函数优先使用<code>slave_1</code>数据源而不是<code>slave</code>数据源)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token annotation punctuation">@DS</span><span class="token punctuation">(</span><span class="token string">"slave"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> <span class="token class-name">JdbcTemplate</span> jdbcTemplate<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">List</span> <span class="token function">selectAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  jdbcTemplate<span class="token punctuation">.</span><span class="token function">queryForList</span><span class="token punctuation">(</span><span class="token string">"select * from user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>  <span class="token annotation punctuation">@DS</span><span class="token punctuation">(</span><span class="token string">"slave_1"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">List</span> <span class="token function">selectByCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span>  jdbcTemplate<span class="token punctuation">.</span><span class="token function">queryForList</span><span class="token punctuation">(</span><span class="token string">"select * from user where age &gt;10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、demo代码地址"><a href="#三、demo代码地址" class="headerlink" title="三、demo代码地址"></a>三、demo代码地址</h2><p><a href="https://github.com/GaryLeeeee/lee-code-repository/tree/master/lee-db-code/src/main/java/com/garylee/repository/mybatisplus">https://github.com/GaryLeeeee/lee-code-repository/tree/master/lee-db-code/src/main/java/com/garylee/repository/mybatisplus</a></p><h2 id="四、Q-amp-A"><a href="#四、Q-amp-A" class="headerlink" title="四、Q&amp;A"></a>四、Q&amp;A</h2><h3 id="1-如何在控制台打印sql语句？"><a href="#1-如何在控制台打印sql语句？" class="headerlink" title="1.如何在控制台打印sql语句？"></a>1.如何在控制台打印sql语句？</h3><ul><li><p>配置文件为<code>application.yml</code>时</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">log-impl</span><span class="token punctuation">:</span> org.apache.ibatis.logging.stdout.StdOutImpl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>配置文件为<code>application.properties</code>时</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">mybatis-plus.configuration.log-impl</span><span class="token punctuation">:</span> <span class="token attr-value">org.apache.ibatis.logging.stdout.StdOutImpl</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="五、如何分页查询？"><a href="#五、如何分页查询？" class="headerlink" title="五、如何分页查询？"></a>五、如何分页查询？</h2><p><strong>//TODO</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Mybatis </tag>
            
            <tag> Mybatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka使用笔记</title>
      <link href="/2021/11/07/kafka-shi-yong-bi-ji/"/>
      <url>/2021/11/07/kafka-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1-本地启动报错”Timeout-expired-while-fetching-topic-metadata”"><a href="#1-本地启动报错”Timeout-expired-while-fetching-topic-metadata”" class="headerlink" title="1.本地启动报错”Timeout expired while fetching topic metadata”"></a>1.本地启动报错”Timeout expired while fetching topic metadata”</h3><p>临时方案：如果不需要测试kafka可以临时注释掉listener的@Component或者@KafkaListener，使其不影响启动</p><h3 id="2-消费者的LAG-消费滞后量，越大说明堆积越严重-一直在增加"><a href="#2-消费者的LAG-消费滞后量，越大说明堆积越严重-一直在增加" class="headerlink" title="2.消费者的LAG(消费滞后量，越大说明堆积越严重)一直在增加"></a>2.消费者的LAG(消费滞后量，越大说明堆积越严重)一直在增加</h3><ul><li><strong>排查</strong>：<ul><li>配置中的<code>enable-auto-commit=false</code>代表消费者不会自动提交ack</li><li>配置中的<code>ack-mode=MANUAL_IMMEDIATE</code>代表每一条mq消费之后需要立即手动提交ack</li></ul></li><li><strong>解决</strong>：<ul><li><strong>方案1</strong>：配置<code>enable-auto-commit</code>改为<code>true</code></li><li><strong>方案2</strong>：消费入参引入<code>Acknowledgment ack</code>并在消费完mq后执行<code>ack.acknowledge()</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven使用笔记</title>
      <link href="/2021/11/07/maven-shi-yong-bi-ji/"/>
      <url>/2021/11/07/maven-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="长时间卡在”Resolving-Maven-dependencies”"><a href="#长时间卡在”Resolving-Maven-dependencies”" class="headerlink" title="长时间卡在”Resolving Maven dependencies”"></a>长时间卡在”Resolving Maven dependencies”</h3><p>解决方案：<code>Setting</code>-&gt;<code>Build,Execution,Deployment</code>-&gt;<code>Build Tools</code>-&gt;<code>Maven</code>-&gt;<code>Importing</code>-&gt;<code>VM options for importer</code>改为<code>-Xms1024m -Xmx2048m</code><br><img src="/images/maven%E9%95%BF%E6%97%B6%E9%97%B4%E5%8D%A1%E4%BD%8Fresolving.png" alt="maven长时间卡住resolving"></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ使用笔记</title>
      <link href="/2021/11/06/rabbitmq-shi-yong-bi-ji/"/>
      <url>/2021/11/06/rabbitmq-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、依赖"><a href="#一、依赖" class="headerlink" title="一、依赖"></a>一、依赖</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">lee-rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">addresses</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">5672</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> test_username    <span class="token key atrule">password</span><span class="token punctuation">:</span> test_password    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RabbitMqConstant</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> EXCHANGE <span class="token operator">=</span> <span class="token string">"LEE_EXCHANGE"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> ROUTING_KEY <span class="token operator">=</span> <span class="token string">"LEE_ROUTING_KEY"</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> QUEUE <span class="token operator">=</span> <span class="token string">"LEE_QUEUE"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"leeConnectionFactory"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ConnectionFactory</span> <span class="token function">leeConnectionFactory</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.lee-rabbitmq.addresses}"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> addresses<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.lee-rabbitmq.username}"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> username<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.lee-rabbitmq.password}"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span>            <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.lee-rabbitmq.virtual-host}"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> virtualHost    <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">CachingConnectionFactory</span> connectionFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CachingConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setAddresses</span><span class="token punctuation">(</span>addresses<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span>        connectionFactory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span>virtualHost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connectionFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"leeRabbitTemplate"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">RabbitTemplate</span> <span class="token function">leeRabbitTemplate</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"leeConnectionFactory"</span><span class="token punctuation">)</span> <span class="token class-name">ConnectionFactory</span> connectionFactory    <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">RabbitTemplate</span> rabbitTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RabbitTemplate</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"leeQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span> <span class="token function">leeQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConstant</span><span class="token punctuation">.</span>QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"leeExchange"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">TopicExchange</span> <span class="token function">leeExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TopicExchange</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConstant</span><span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token class-name">Binding</span> <span class="token function">binding</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"leeQueue"</span><span class="token punctuation">)</span> <span class="token class-name">Queue</span> leeQueue<span class="token punctuation">,</span> <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"leeExchange"</span><span class="token punctuation">)</span> <span class="token class-name">TopicExchange</span> leeExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">BindingBuilder</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>leeQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span>leeExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">with</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConstant</span><span class="token punctuation">.</span>ROUTING_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 消费者配置     */</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"leeFactory"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">SimpleRabbitListenerContainerFactory</span> <span class="token function">leeFactory</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span><span class="token string">"leeConnectionFactory"</span><span class="token punctuation">)</span> <span class="token class-name">ConnectionFactory</span> connectionFactory    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SimpleRabbitListenerContainerFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleRabbitListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、发送"><a href="#三、发送" class="headerlink" title="三、发送"></a>三、发送</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqProvider</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"leeRabbitTemplate"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">RabbitTemplate</span> rabbitTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token class-name">RabbitMqConstant</span><span class="token punctuation">.</span>EXCHANGE<span class="token punctuation">,</span> <span class="token class-name">RabbitMqConstant</span><span class="token punctuation">.</span>ROUTING_KEY<span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发送结果<br><img src="/images/RabbitMQ%E5%88%9B%E5%BB%BAExchange.png" alt="RabbitMQ创建Exchange"><br><img src="/images/RabbitMQ%E5%88%9B%E5%BB%BAQueue.png" alt="RabbitMQ创建Queue"></p><h2 id="四、接收"><a href="#四、接收" class="headerlink" title="四、接收"></a>四、接收</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RabbitMqConsumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token class-name">RabbitMqConstant</span><span class="token punctuation">.</span>QUEUE<span class="token punctuation">,</span> containerFactory <span class="token operator">=</span> <span class="token string">"leeFactory"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Message</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[消费MQ] message:{}"</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> messageVal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">defaultCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token class-name">JSONObject</span><span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>messageVal<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[消费MQ] user:{}"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"[消费MQ]消费异常"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            channel<span class="token punctuation">.</span><span class="token function">basicAck</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMessageProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeliveryTag</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"[消费MQ]ACK异常"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、相关代码地址"><a href="#五、相关代码地址" class="headerlink" title="五、相关代码地址"></a>五、相关代码地址</h2><p><a href="https://github.com/GaryLeeeee/lee-code-repository/tree/master/lee-mq-code/src/main/java/com/garylee/mq/rabbitmq">https://github.com/GaryLeeeee/lee-code-repository/tree/master/lee-mq-code/src/main/java/com/garylee/mq/rabbitmq</a></p><h2 id="六、遇到的问题"><a href="#六、遇到的问题" class="headerlink" title="六、遇到的问题"></a>六、遇到的问题</h2><h3 id="1-Caused-by-java-lang-ClassNotFoundException-com-fasterxml-jackson-databind-ObjectMapper"><a href="#1-Caused-by-java-lang-ClassNotFoundException-com-fasterxml-jackson-databind-ObjectMapper" class="headerlink" title="1.Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.databind.ObjectMapper"></a>1.Caused by: java.lang.ClassNotFoundException: com.fasterxml.jackson.databind.ObjectMapper</h3><p>解决方案：添加依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Caused-by-java-net-ConnectException-Connection-refused-connect"><a href="#2-Caused-by-java-net-ConnectException-Connection-refused-connect" class="headerlink" title="2.Caused by: java.net.ConnectException: Connection refused: connect"></a>2.Caused by: java.net.ConnectException: Connection refused: connect</h3><p>解决方案：本地RabbitMQ的连接端口默认是5672，不是15672(后台管理页面端口)</p><h3 id="3-Caused-by-com-rabbitmq-client-AuthenticationFailureException-ACCESS-REFUSED-Login-was-refused-using-authentication-mechanism-PLAIN-For-details-see-the-broker-logfile"><a href="#3-Caused-by-com-rabbitmq-client-AuthenticationFailureException-ACCESS-REFUSED-Login-was-refused-using-authentication-mechanism-PLAIN-For-details-see-the-broker-logfile" class="headerlink" title="3.Caused by: com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile."></a>3.Caused by: com.rabbitmq.client.AuthenticationFailureException: ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile.</h3><p>原因：guest账号出于安全考虑，不允许直接连接使用<br>解决方案：新增一个账号，并设置权限<br><img src="/images/RabbitMQ%E6%B7%BB%E5%8A%A0%E8%B4%A6%E5%8F%B7.png" alt="RabbitMQ添加账号"><br><img src="/images/RabbitMQ%E8%B4%A6%E5%8F%B7%E6%B7%BB%E5%8A%A0%E6%9D%83%E9%99%90.png" alt="RabbitMQ账号添加权限"></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ安装笔记</title>
      <link href="/2021/11/05/rabbitmq-an-zhuang-bi-ji/"/>
      <url>/2021/11/05/rabbitmq-an-zhuang-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="windows10安装"><a href="#windows10安装" class="headerlink" title="windows10安装"></a>windows10安装</h1><h2 id="下载并安装erlang"><a href="#下载并安装erlang" class="headerlink" title="下载并安装erlang"></a>下载并安装erlang</h2><ul><li>原因：RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是安装Erlang。</li><li>下载链接：<a href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></li></ul><p><img src="/images/erlang%E4%B8%8B%E8%BD%BD.png" alt="erlang下载"></p><ul><li>安装</li><li>配置环境变量<ul><li>第一步：此电脑-&gt;鼠标邮件”属性”-&gt;高级系统设置-&gt;环境变量-&gt;系统变量”新建”<ul><li>变量名：ERLANG_HOME</li><li>变量值：erlang安装目录(我的是<code>G:\software\erlang</code>)<br><img src="/images/erlang%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="erlang环境变量"></li></ul></li><li>第二步：系统变量双击”path”-&gt;新建-&gt;添加<code>%ERLANG_HOME%\bin</code><br><img src="/images/erlang%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" alt="erlang环境变量2"><br><img src="/images/erlang%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F3.png" alt="erlang环境变量3"></li></ul></li><li>win+R-&gt;输入cmd-&gt;输入erl，显示版本号就说明安装成功了<br><img src="/images/erlang%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC.png" alt="erlang查看版本"></li></ul><h2 id="下载并安装RabbitMQ"><a href="#下载并安装RabbitMQ" class="headerlink" title="下载并安装RabbitMQ"></a>下载并安装RabbitMQ</h2><ul><li>下载地址：<a href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a><br><img src="/images/RabbitMQ%E4%B8%8B%E8%BD%BD.png" alt="RabbitMQ下载"></li><li>win+R-&gt;输入cmd-&gt;cd到RabbitMQ的sbin目录-&gt;输入<code>rabbitmq-plugins enable rabbitmq_management</code><br><img src="/images/RabbitMQ%E5%AE%89%E8%A3%85.png" alt="RabbitMQ安装">  </li><li>打开sbin目录-&gt;双击<code>rabbitmq-server.bat</code><br><img src="/images/RabbitMQ%E5%90%AF%E5%8A%A8.png" alt="RabbitMQ启动"></li><li>过一会出现这个页面，说明启动成功了，这时候可访问<code>http://localhost:15672</code><br><img src="/images/RabbitMQ%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="RabbitMQ启动成功"></li><li>这是RabbitMQ的后台，username和password默认是<code>guest</code><br><img src="/images/RabbitMQ%E5%90%8E%E5%8F%B0.png" alt="RabbitMQ后台"></li><li>end</li></ul>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 工具安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s学习笔记</title>
      <link href="/2021/08/12/k8s-xue-xi-bi-ji/"/>
      <url>/2021/08/12/k8s-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="容器技术概念入门篇"><a href="#容器技术概念入门篇" class="headerlink" title="容器技术概念入门篇"></a>容器技术概念入门篇</h2><h3 id="05-白话容器基础（一）：从进程说开去"><a href="#05-白话容器基础（一）：从进程说开去" class="headerlink" title="05 | 白话容器基础（一）：从进程说开去"></a>05 | 白话容器基础（一）：从进程说开去</h3><ul><li><strong>容器其实是一种沙盒技术。</strong> 顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了<code>边界</code>而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。</li><li>容器本身没有价值，有价值的是”<strong>容器编排</strong>“</li><li><strong>镜像</strong>。比如我们要做一个加法程序，由于计算机只认识0和1，所以无论用哪种语音编写这段代码，最后都需要翻译成<code>二进制文件</code>，才能在计算机操作系统跑起来。为了让这些代码正常运行，还需要提供<code>数据</code>，比如这个加法程序，将<code>数据</code>和代码本身的<code>二进制文件</code>，放在磁盘上，就是平常我们所说的程序，也叫代码的<code>可执行镜像</code>  </li><li><strong>进程</strong>。对于进程来说，它的<code>静态表现</code>就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的综合，这就是它的<code>动态表现</code>。<ul><li>输入数据</li><li>寄存器的值变化</li><li>堆桟中的指令变化</li><li>被打开的文件</li><li>各种设备的状态信息变化  </li></ul></li><li><strong>容器技术的核心功能</strong>，就是通过约束和修改进程的<code>动态表现</code>，从而为其创造出一个<code>边界</code><ul><li><code>Ggroups技术</code>是用来制造约束的主要手段</li><li><code>Namespace技术</code>则是用来修改进程视图的主要方法  </li></ul></li><li>跟真实存在的<code>虚拟机</code>不同，在使用docker的时候并密友一个真正的”docker容器”运行在宿主机里面。docker项目帮助用户启动的还是原来的引用进程，只不过在创建这些进程时，docker为它们加上了各种各样的<code>Namespace</code>参数<ul><li>这时这些进程就会觉得自己是各自PID Namespace里的第1号进程</li><li>只能看到各自Mount Namespace里挂载的目录和文件</li><li>只能访问到各自Network Namespace里的网络设备</li><li>彷佛运行在一个个”容器”里面，与世隔绝</li></ul></li><li>小结<ul><li><strong>程序</strong>：静态状态是文件，动态状态是进程</li><li><code>Cgroups</code>限制资源，<code>Namespace</code>隔离资源</li><li><strong>容器</strong>：其实就是操作系统在启动进程时通过<strong>设置</strong>一些参数实现了<strong>隔离</strong>不相关资源后的一个特殊<strong>进程</strong><ul><li>实际上没有一个真正的容器运行在宿主机里面(只是Namespace造成了这一个个进程的错觉)</li></ul></li></ul></li></ul><h3 id="06-白话容器基础（二）：隔离与限制"><a href="#06-白话容器基础（二）：隔离与限制" class="headerlink" title="06 | 白话容器基础（二）：隔离与限制"></a>06 | 白话容器基础（二）：隔离与限制</h3><ul><li><code>Namespace</code>技术实际上修改了应用进程看待整个计算机”视图”，即它的”视线”被操作系统做了限制，只能”看到”某些指定的内容。</li><li><code>虚拟机</code>和<code>容器</code>的区别<ul><li>虚拟机是真实存在的(需要有一套完成的GuestOS造成资源消耗约如100~200MB)，而容器只是一个宿主机上的普通进程(占用资源忽略不计)</li><li>虚拟机对宿主机操作系统调用会有性能损耗(尤其是计算资源、网络和磁盘I/O)，而容器并不存在性能损耗</li></ul></li><li>既然容器是宿主机上一个特殊进程，那么多个容器之间用的是同一个宿主机的操作系统内核(共享内核导致隔离不彻底)</li><li><code>Cgroups</code>全称是<code>Control Group</code>，用来限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等</li><li>容器是一个”单进程”模型</li></ul><ul><li>小结<ul><li><code>虚拟机</code>需要借助<code>GuestOS</code>才能运行应用，<code>容器</code>实际上就是OS的进程，一组文件和运行环境，更加简单。</li><li>虚拟化较容器化有更大的资源损耗</li><li>容器相较于虚拟机最大的优势是<code>敏捷</code>和<code>高性能</code></li><li>多个容器共享内核导致隔离不彻底所以引入了<code>Cgroups</code>限制资源</li><li>具体<code>Cgroups</code>相关指令操作参考相关文档…</li><li>一个正在运行的docker容器，其实就是启用了多个<code>Namespace</code>的应用进程，而这个进程能够使用的资源量，则受Cgroups配置的限制</li><li><code>Cgroups</code>问题：如果在容器中执行top指令，将会显示宿主机的CPU和内存数据，而不是当前容器的数据(原因是/proc文件系统并不知道用户通过<code>Cgroups</code>对这个容器做了怎样的资源限制)<ul><li>lxcfs可解决该问题</li></ul></li></ul></li></ul><h3 id="07-白话容器基础（三）：深入理解容器镜像"><a href="#07-白话容器基础（三）：深入理解容器镜像" class="headerlink" title="07 | 白话容器基础（三）：深入理解容器镜像"></a>07 | 白话容器基础（三）：深入理解容器镜像</h3><blockquote><p>1.容器里的进程看到的文件系统是什么样子的呢？<br>2.用户希望每次创建一个新容器时都是看到一个独立的隔离环境</p></blockquote><ul><li><p>即使开启了<code>Mount Namespace</code>，容器进程看到的文件系统也跟宿主机完全一致</p><ul><li>原因：<code>Mount Namespace</code>修改的是容器进程对于文件系统”挂载点”的认知</li><li>所以：只有”挂载”后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点</li><li>修改前：继承宿主机的挂载点</li><li>修改后：可以修改挂载点</li></ul></li><li><p>可以在容器进程启动之前，让容器以<code>tmpfs(内存盘)</code>格式，重新挂载<code>/xxx</code>目录</p></li><li><p><code>Mount Namespace</code>只有挂载(mount)之后才能生效</p></li><li><p>我们一般会在容器的根目录下挂载一个完成操作系统的文件系统，比如<code>Ubuntu 16.04</code>的ISO。这样容器启动之后，我们在容器里通过执行<code>ls /</code>查看根目录下的内容，就是<code>Ubuntu 16.4</code>的所有目录和文件</p><ul><li><code>容器镜像</code>：挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统。也叫<code>rootfs</code>(根文件系统)</li><li><code>rootfs</code>只是一个操作系统包含的文件、配置和目录，并不包括操作系统内核(Linux中这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像)</li></ul></li><li><p>Docker项目最核心原理就是为待创建的用户进程</p><ul><li>1.启用<code>Linux Namespace</code>配置</li><li>2.设置指定的<code>Cgroups</code>参数</li><li>3.切换进程的根目录<code>chroot</code>(Change Root) //会优先使用<code>pivot_root</code>系统调用(如果不支持采用<code>chroot</code>)</li></ul></li><li><p>同一台机器上的所有容器，都共享宿主机操作系统的内核</p><ul><li>意味着是全局变量，牵一发而动全身</li><li>相比<code>虚拟机</code>的主要缺陷之一：<code>虚拟机</code>拥有一个完整的<code>Guest OS</code>(不存在影响其他应用)</li></ul></li><li><p>一致性</p><ul><li>镜像打包后，无论在本地、云端等地方，只要解压打包好的容器镜像，那么这个应用所需要的完整的执行环境就会被重现出来</li><li>打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟</li></ul></li></ul><blockquote><p>1.但是否每开发/升级一个应用，都需要重复制作一次rootfs吗<br>2.比如我在rootfs安装了Java环境来部署我的Java应用，这时候其他同事也需要部署Java应用，那显然希望是能直接用我安装了Java环境的rootfs，而不是重复这个流程</p></blockquote><ul><li><p>层(layer)</p><ul><li>用户制作镜像的每一步操作，都会生成一个层，也就是一个增量<code>rootfs</code></li><li><code>UnionFS</code>：目的是将多个不同位置的目录联合挂载(union mount)到同一个目录下。<br><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/before-union-mount.png" alt="挂载前"><br>执行<br><code>mkdir C</code><br><code>mount -t aufs -o dirs=./A:./B none ./C</code><br><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/after-union-mount.png" alt="挂载后"><br>可以发现原来A目录下有a、x，B目录下有b、x，合并后的C中只有a、b、x(x被去重合并了)</li><li>层分为<code>只读层</code>+<code>可读写层</code>+<code>Init层</code></li></ul></li><li><p>总结</p><ul><li><code>rootfs</code>是一个操作系统的所有文件和目录，并不包含内核。而传统虚拟机的镜像大多是一个磁盘的”快照”，磁盘有多大，镜像就至少有多大</li><li>通过结合<code>Mount Namespace</code>和<code>rootfs</code>，容器就能为进程构建一个完善的文件隔离环境(依赖<code>chroot</code>和<code>pivot_root</code>这两个系统调用切换根目录的能力)  </li><li>docker公司提出了使用多个增量<code>rootfs</code>联合挂载一个完整<code>rootfs</code>的方案，这就是容器镜像中“<code>层</code>”的概念<ul><li>共享层的存在，使得所有这些容器镜像需要的总空间，也比每个镜像的综合要小</li></ul></li><li><code>强一致性</code>：一旦一个镜像被发布，那么任何地方下载这个镜像得到的内容都完全一致，可以完全复现这个镜像制作者当初的完整环境</li><li>容器镜像将会变成未来软件的主流发布方式</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码库</title>
      <link href="/2021/08/07/dai-ma-ku/"/>
      <url>/2021/08/07/dai-ma-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程执行器"><a href="#多线程执行器" class="headerlink" title="多线程执行器"></a>多线程执行器</h2><p>1.具体代码<a href="https://github.com/GaryLeeeee/lee-code-repository/tree/master/lee-common-code/src/test/java/com/garylee/repository/thread">点此跳转</a><br>2.相关笔记<a href="https://garyleeeee.github.io/2021/07/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">点此跳转</a><br>3.代码介绍&amp;使用</p><ul><li>封装了一个可指定线程名的方法</li><li>可通过<code>ThreadExecutor.execute(()-&gt;{do sth.});</code>异步执行逻辑</li><li>可通过<code>Future&lt;V&gt; future=ThreadExecutor.submit(()-&gt;{do sth.});</code>提交可返回结果的执行，并通过<code>future.get()</code>获取返回结果(get会等待线程执行完逻辑)</li><li>特殊场景独立线程池可通过<code>ThreadExecutor.createThreadPoolExecutor</code>创建</li></ul><p>4.疑问点</p><ul><li>为什么线程池大小指定为2n(n为系统cpu数)？<ul><li>CPU密集型任务一般用CPU核心数+1</li><li>IO密集型任务一般用2*CPU核心数</li></ul></li></ul><h2 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h2><p>1.具体代码<a href="https://github.com/GaryLeeeee/lee-code-repository/tree/master/lee-db-code/src/main/java/com/garylee/repository/mybatisplus">点此跳转</a><br>2.使用步骤</p><ul><li>引入<code>mybatis-plus-boot-starter</code>依赖</li><li><code>application.yml</code>加<code>mybatis-plus</code>相关配置</li><li>实体类加<code>@TableName("xxx")</code>注解(对应mysql表名)</li><li><code>mapper</code>层继承<code>BaseMapper</code>接口用于提供db操作方法(CRUD)</li><li><code>service</code>层继承<code>ServiceImpl</code>类用于提供业务操作方法(CRUD、分页等)</li><li>具体CRUD可参考<code>1.具体代码</code></li></ul><p>3.优点</p><ul><li>不用写复杂xml文件，容易出错</li><li>封装了简易的API接口(如CRUD、分页等)</li></ul><h2 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h2><p>1.具体代码<a href="https://github.com/GaryLeeeee/lee-code-repository/blob/master/lee-common-code/src/test/java/com/garylee/repository/loadingcache/LoadingCacheServiceTest.java">点击跳转</a><br>2.代码介绍&amp;使用</p><ul><li><code>refreshAfterWrite</code>：第一次请求会load一遍缓存，并在设置时间内读到的都是缓存的旧值。当设置时间到了，下次请求来了会有进程去异步load一遍新的，新的结果返回之类get读到的都是旧值</li><li><code>expireAfterWrite</code>：设置缓存在指定时间内如果没有更新则会移除(一般与<code>refreshAfterWrite</code>搭配使用)</li></ul><p>3.注意点</p><ul><li>报错CacheLoader returned null for key怎么办？<ul><li><code>load()</code>方法不允许返回null，如需要需包一层<code>Optional</code></li><li>如原来的<code>String load(String key)</code>改为<code>Optional&lt;String&gt; load(String key)</code></li><li>返回的<code>Optional</code>对象通过调用<code>orElse(other)</code>方法(如果为null则返回other)获取到实际对象</li></ul></li></ul><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>1.具体代码<a href="https://github.com/GaryLeeeee/lee-code-repository/blob/master/lee-common-code/src/main/java/com/garylee/repository/lock/RedissonLockUtil.java">点击跳转</a><br>2.介绍</p><ul><li><code>redisson</code>实现了分布式和可扩展的java数据结构</li><li>需要配合<code>redis</code>使用，host为localhost时需启动<code>redis server</code></li></ul><p>3.使用步骤</p><ul><li>添加<code>redisson</code>依赖</li><li>先通过<code>RedissLockUtil.getRedissonLock()</code>拿到分布式锁<code>DistributedLocker</code></li><li>然后通过<code>tryLock()</code>尝试拿到锁</li><li>最后在<code>finally</code>代码块执行<code>unlock()</code>即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试指南</title>
      <link href="/2021/08/03/mian-shi-zhi-nan/"/>
      <url>/2021/08/03/mian-shi-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="面试指南"><a href="#面试指南" class="headerlink" title="面试指南"></a>面试指南</h1><h2 id="技术面可能会被问到的问题"><a href="#技术面可能会被问到的问题" class="headerlink" title="技术面可能会被问到的问题"></a>技术面可能会被问到的问题</h2><p><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/%E6%8A%80%E6%9C%AF%E9%9D%A2%E9%97%AE%E9%A2%98%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg" alt="技术面问题思维导图"></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题(Java)</title>
      <link href="/2021/08/03/mian-shi-ti-java/"/>
      <url>/2021/08/03/mian-shi-ti-java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="一、面向对象和面向过程的区别"><a href="#一、面向对象和面向过程的区别" class="headerlink" title="一、面向对象和面向过程的区别"></a>一、面向对象和面向过程的区别</h2><ul><li>面向过程<ul><li>性能比<code>面向对象</code>高</li><li>当性能最重要时，比如嵌入式开发、Linux/Unix等一般采用<code>面向过程</code>开发</li></ul></li><li>面向对象<ul><li>性能比<code>面向过程</code>低</li><li>易维护、易复用、易扩展</li><li>特性：<code>封装</code>、<code>继承</code>、<code>多态</code></li><li>可以设计低耦合系统，使系统更加灵活、更加易于维护</li></ul></li></ul><p>参见 issue :<a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程 ：面向过程性能比面向对象高？？</a></p><blockquote><p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语音，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械吗。<br>而面向过程大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也并不一定比Java好。</p></blockquote><h2 id="二、Java语言有哪些特点"><a href="#二、Java语言有哪些特点" class="headerlink" title="二、Java语言有哪些特点"></a>二、Java语言有哪些特点</h2><ul><li>简单易学</li><li>面向对象(封装、继承、多态)</li><li>平台无关性(Java虚拟机实现平台无关性)</li><li>可靠性</li><li>安全性</li><li>支持多线程(C++语言没有内置的多线程机制，因为必须调用操作系统的多线程功能来进行多线程程序设计)<br><code>C++11开始就引入了多线程库</code></li><li>支持网络编程并且很方便</li><li>编译与解释并存</li></ul><h2 id="三、JDK和JRE"><a href="#三、JDK和JRE" class="headerlink" title="三、JDK和JRE"></a>三、JDK和JRE</h2><h3 id="1-JDK"><a href="#1-JDK" class="headerlink" title="1.JDK"></a>1.JDK</h3><ul><li><code>JDK</code>是<code>Java Development Kit</code>的缩写，它是功能齐全的Java SDK。</li><li>拥有<code>JRE</code>所拥有的一切</li><li>有编译器<code>javac</code></li><li>允许创建和编译程序</li></ul><h3 id="2-JRE"><a href="#2-JRE" class="headerlink" title="2.JRE"></a>2.JRE</h3><ul><li><code>JDK</code>是<code>Java Runtime Environment</code>的缩写，也就是Java运行时环境</li><li>包含Java虚拟机(<code>JVM</code>)，Java类库，Java命令等</li><li>不允许创建新程序</li></ul><h3 id="3-用途"><a href="#3-用途" class="headerlink" title="3.用途"></a>3.用途</h3><ul><li>如果只是想运行<code>Java</code>程序，只需要安装<code>JRE</code></li><li>如果需要进行<code>Java</code>编程方面工作，就需要安装<code>JDK</code></li><li>…</li></ul><h2 id="四、Java和C-的区别？"><a href="#四、Java和C-的区别？" class="headerlink" title="四、Java和C++的区别？"></a>四、Java和C++的区别？</h2><ul><li><strong>特点</strong>：都是<code>面向对象</code>语言，都支持<code>封装</code>、<code>继承</code>和<code>多态</code></li><li><strong>安全</strong>：<code>Java</code>不提供<code>指针</code>来直接访问内存，程序内存更加安全</li><li><strong>继承</strong>：<code>Java</code>类是单继承的(接口可以多继承)，C++支持多重继承</li><li><strong>内存</strong>：<code>Java</code>有自动内存管理机制，不需要程序员手动释放无用内存</li><li><strong>结束符</strong>：C语言字符串或字符数组最后会有一个额外的字符’\0’表示结束，而Java语言没有结束符的概念。(具体<a href="https://blog.csdn.net/sszgg2006/article/details/49148189">参考这里</a>)</li></ul><h2 id="五、部分简单总结"><a href="#五、部分简单总结" class="headerlink" title="五、部分简单总结"></a>五、部分简单总结</h2><ul><li>构造器<code>Constructor</code>不能被重写(<code>Override</code>)，但是可以被重载(<code>Overload</code>)</li><li>重载(<code>Overload</code>)是方法名相同，参数类型不同的实现。重写(<code>Override</code>)是子类覆盖父类方法的实现。方法的重写要遵循“两同两小一大”<ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li><li></li></ul><p>。。。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高可用学习笔记(科普向)</title>
      <link href="/2021/08/01/gao-ke-yong-xue-xi-bi-ji-ke-pu-xiang/"/>
      <url>/2021/08/01/gao-ke-yong-xue-xi-bi-ji-ke-pu-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a>什么是高可用</h2><ul><li>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。</li><li>高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li><code>限流</code>是从用户访问压力的角度来考虑如何应对系统故障。</li><li><code>限流</code>是为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。比如某一个接口的请求限制为100个每秒，对超过限制的请求放弃处理或者放到队列中等待处理。</li><li><code>限流</code>可以有效应对突发请求过多。</li></ul><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><ul><li><code>降级</code>是从系统功能优先级的角度考虑如何应对系统故障。</li><li><code>服务降级</code>指的是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。</li></ul><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><ul><li><code>熔断</code>和<code>降级</code>是两个比较容易混淆的概念，两者的含义并不相同。</li><li><code>降级</code>的目的在于应对系统自身的故障，而<code>熔断</code>的目的在于应对当前系统依赖的外部系统或者第三方系统的故障。</li></ul><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><ul><li>另类的一种<code>限流</code>，类比于现实世界的排队。比如LOL一有大活动就需要排队(很久)才能进入游戏。</li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul><li>相同的服务部署多份，避免<code>单点</code>故障。</li></ul><h3 id="超时和重试机制"><a href="#超时和重试机制" class="headerlink" title="超时和重试机制"></a>超时和重试机制</h3><ul><li>一旦用户的请求超过某个时间得不到响应就结束此次请求并抛出异常。</li><li>如果不进行<code>超时设置</code>可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。</li><li><code>重试</code>次数一般设为3次，再多次<code>重试</code>并没有好处，反而会加重服务器压力(部分场景使用失败重试机制会不太合适)</li></ul><h2 id="现阶段总结"><a href="#现阶段总结" class="headerlink" title="现阶段总结"></a>现阶段总结</h2><ul><li>没有做过<code>限流</code></li><li>了解但没实际应用过<code>降级</code></li><li>了解但没实际应用过<code>熔断</code></li><li>目前项目在<code>集群</code>方面是做到多机房多实例</li><li>目前项目在<code>超时/重试</code>方面有对请求做重试(一般是3次)，大部分用到的dubbo接口都会指定超时时间(3~5s)</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://snailclimb.gitee.io/javaguide/#/?id=%e9%ab%98%e5%8f%af%e7%94%a8">Java Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用笔记</title>
      <link href="/2021/07/31/hexo-shi-yong-bi-ji/"/>
      <url>/2021/07/31/hexo-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前提工作"><a href="#1-前提工作" class="headerlink" title="1.前提工作"></a>1.前提工作</h2><ul><li>github(本文针对github，其他如gitee类似)</li><li>node.js、npm</li><li>git客户端</li><li>hexo(本文会介绍怎么安装)</li></ul><h2 id="2-搭建博客项目-h5"><a href="#2-搭建博客项目-h5" class="headerlink" title="2.搭建博客项目(h5)"></a>2.搭建博客项目(h5)</h2><ul><li>创建github仓库<br>新建一个名为 <strong>{用户名}.github.io</strong>的仓库</li><li>在settings-pages可以看到博客部署的地址<br><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/github%20page.png"></li></ul><h2 id="3-如何使用hexo"><a href="#3-如何使用hexo" class="headerlink" title="3.如何使用hexo"></a>3.如何使用hexo</h2><h3 id="3-1-install-安装"><a href="#3-1-install-安装" class="headerlink" title="3.1 install(安装)"></a>3.1 install(安装)</h3><p><code>npm install -g hexo</code></p><h3 id="3-2-hexo-init-初始化"><a href="#3-2-hexo-init-初始化" class="headerlink" title="3.2 hexo init(初始化)"></a>3.2 hexo init(初始化)</h3><p>随便找一个目录放代码(后面发博客内容等需要修改) 如d:/hexo<br>并初始化为hexo项目<br><code>cd d:/hexo</code><br><code>hexo init</code><br>这时候会自动生成一些文件<br>  <img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/hexo-init.png" alt="hexo init"></p><h3 id="3-3-hexo-g-生成"><a href="#3-3-hexo-g-生成" class="headerlink" title="3.3 hexo g(生成)"></a>3.3 hexo g(生成)</h3><p>hexo g是hexo generate的缩写，用于在public文件夹生成最终的文件(.md文件会被生成.html文件)<br><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/hexo-g.png" alt="hexo g"></p><h3 id="3-4-hexo-s-启动服务"><a href="#3-4-hexo-s-启动服务" class="headerlink" title="3.4 hexo s(启动服务)"></a>3.4 hexo s(启动服务)</h3><p>hexo s是hexo server的缩写，用于本地启动服务，可以通过<a href="http://localhost:4000访问">http://localhost:4000访问</a><br><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/hexo-s.png" alt="hexo s"></p><h3 id="3-5-重要目录-文件的作用"><a href="#3-5-重要目录-文件的作用" class="headerlink" title="3.5 重要目录/文件的作用"></a>3.5 重要目录/文件的作用</h3><table><thead><tr><th>文件夹</th><th>作用</th></tr></thead><tbody><tr><td>source</td><td>存放静态文件的文件夹(包括md、图片等)</td></tr><tr><td>themes</td><td>模板库(可以网上下载到这里)</td></tr><tr><td>_config.yml</td><td>全局配置(如username等)</td></tr></tbody></table><h2 id="4-使用主题并写博客"><a href="#4-使用主题并写博客" class="headerlink" title="4.使用主题并写博客"></a>4.使用主题并写博客</h2><p>一般我们下载网上的主题，就可以直接修改配置文件(_config.yml)来自定义页面内容</p><ul><li>找一个主题并下载到<code>/themes</code>目录下<br>比如我的主题是<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></li><li>修改<code>_config.yml</code>的<code>theme: landscape</code>为<code>theme: matery</code></li></ul><h2 id="5-如何部署到远程-username-github-io"><a href="#5-如何部署到远程-username-github-io" class="headerlink" title="5.如何部署到远程{username.github.io}"></a>5.如何部署到远程{username.github.io}</h2><h3 id="5-1-配置git账户信息"><a href="#5-1-配置git账户信息" class="headerlink" title="5.1 配置git账户信息"></a>5.1 配置git账户信息</h3><p>deploy:<br>  type: git<br>  repository: <a href="mailto:git@github.com">git@github.com</a>:GaryLeeeee/garyleeeee.github.io.git<br>  branch: master</p><h3 id="5-2-安装deployer插件"><a href="#5-2-安装deployer插件" class="headerlink" title="5.2 安装deployer插件"></a>5.2 安装deployer插件</h3><p><code>npm install hexo-deployer-git --save</code><br>如果没安装的话<code>hexo d</code>一般会报错”Deployer not found: github”或者”Deployer not found: git”</p><h3 id="5-3-hexo-d-部署"><a href="#5-3-hexo-d-部署" class="headerlink" title="5.3 hexo d(部署)"></a>5.3 hexo d(部署)</h3><p>hexo d是hexo doploy的缩写，用来部署服务到远程</p><h2 id="6-如何写博客"><a href="#6-如何写博客" class="headerlink" title="6.如何写博客"></a>6.如何写博客</h2><h3 id="6-1-hexo-new-xxx-新建博客"><a href="#6-1-hexo-new-xxx-新建博客" class="headerlink" title="6.1 hexo new xxx(新建博客)"></a>6.1 hexo new xxx(新建博客)</h3><p>通过hexo new ‘my-first-blog’即可创建一个名字为my-first-blog的微博文件<br><img src="http://image.liuxianan.com/201608/20160823_183325_470_9306.png"></p><h3 id="6-2-hexo-new-page-xxx-新建页面"><a href="#6-2-hexo-new-page-xxx-新建页面" class="headerlink" title="6.2 hexo new page xxx(新建页面)"></a>6.2 hexo new page xxx(新建页面)</h3><p>与new不同的是他是生成一个页面，并不会以一个博客显示在目录中</p><h3 id="6-3-博客配置"><a href="#6-3-博客配置" class="headerlink" title="6.3 博客配置"></a>6.3 博客配置</h3><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>title</td><td>博客名</td></tr><tr><td>date</td><td>创建日期</td></tr><tr><td>tags</td><td>标签名(后面有讲)</td></tr><tr><td>categories</td><td>分类名(后面有讲)</td></tr></tbody></table><h2 id="7-常见问题"><a href="#7-常见问题" class="headerlink" title="7.常见问题"></a>7.常见问题</h2><h3 id="matery主题如果没有tags-categories-about页面？"><a href="#matery主题如果没有tags-categories-about页面？" class="headerlink" title="matery主题如果没有tags/categories/about页面？"></a>matery主题如果没有tags/categories/about页面？</h3><p>新增标签tags页面(categories/about类似)<br><code>tags</code>页是用来展示所有标签的页面，如果在你的博客<code>source</code>目录下还没有<code>tags/index.md</code>文件，那么你就需要新建一个，命令如下：</p><blockquote><p>hexo new page “tags”</p></blockquote><p>并且在生成的md文件中加上type和layout，如下</p><blockquote><p>title: tags<br>date: 2021-07-31 16:40:30<br>type: “tags”<br>layout: “tags”</p></blockquote><h3 id="部署远程后没更新"><a href="#部署远程后没更新" class="headerlink" title="部署远程后没更新"></a>部署远程后没更新</h3><p>删除本地.deploy_git目录，重新执行<code>hexo d -g</code></p><h3 id="如何上传本地图片"><a href="#如何上传本地图片" class="headerlink" title="如何上传本地图片"></a>如何上传本地图片</h3><p>在source目录新建一个图片目录(如images)，然后在博客里引用(参考<a href="https://zhuanlan.zhihu.com/p/104996801">https://zhuanlan.zhihu.com/p/104996801</a>)<br><code>![img.png](/images/img.png)</code></p><h3 id="如何代码格式化"><a href="#如何代码格式化" class="headerlink" title="如何代码格式化"></a>如何代码格式化</h3><p><img src="source/images/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%BC%98%E5%8C%96%E5%89%8D.png" alt="img.png"><br><img src="/images/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E4%BC%98%E5%8C%96%E5%90%8E.png" alt="代码高亮优化后"></p><h3 id="部署异常（鉴权失败）"><a href="#部署异常（鉴权失败）" class="headerlink" title="部署异常（鉴权失败）"></a>部署异常（鉴权失败）</h3><p>执行指令<code>hexo d -g</code>报错</p><pre class="line-numbers language-none"><code class="language-none">On branch masternothing to commit, working tree clean@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host isSHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s.Please contact your system administrator.Add correct host key in /c/Users/Administrator/.ssh/known_hosts to get rid of this message.Offending RSA key in /c/Users/Administrator/.ssh/known_hosts:1RSA host key for github.com has changed and you have requested strict checking.Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL {  err: Error: Spawn failed      at ChildProcess.&lt;anonymous&gt; (E:\workplace\lee-blog\node_modules\hexo-util\lib\spawn.js:51:21)      at ChildProcess.emit (node:events:513:28)      at cp.emit (E:\workplace\lee-blog\node_modules\cross-spawn\lib\enoent.js:34:29)      at ChildProcess._handle.onexit (node:internal/child_process:291:12) {    code: 128  }} Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查了本地ssh和远程github的ssh匹配，排除不匹配的可能性<br>执行<code>ssh -T git@github.com</code>，验证主机是否与github网站之间的ssh通信是否连接成功</p><pre class="line-numbers language-none"><code class="language-none">Administrator@243Z59L59Q55VQT MINGW64 /e/workplace/lee-blog (master)$ ssh -T git@github.com@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host isSHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s.Please contact your system administrator.Add correct host key in /c/Users/Administrator/.ssh/known_hosts to get rid of this message.Offending RSA key in /c/Users/Administrator/.ssh/known_hosts:1RSA host key for github.com has changed and you have requested strict checking.Host key verification failed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现<code>known_hosts</code>文件异常，尝试删除文件，并重新生成</p><pre class="line-numbers language-none"><code class="language-none">Administrator@243Z59L59Q55VQT MINGW64 /e/workplace/lee-blog (master)$ ssh -T git@github.comThe authenticity of host 'github.com (20.205.243.166)' can't be established.ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM.Are you sure you want to continue connecting (yes/no)? yPlease type 'yes' or 'no': yesWarning: Permanently added 'github.com,20.205.243.166' (ECDSA) to the list of known hosts.Hi GaryLeeeee! You've successfully authenticated, but GitHub does not provide shell access.Administrator@243Z59L59Q55VQT MINGW64 /e/workplace/lee-blog (master)$ ssh -T git@github.comHi GaryLeeeee! You've successfully authenticated, but GitHub does not provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到校验成功了，重新执行<code>hexo d -g</code></p><pre class="line-numbers language-none"><code class="language-none">Administrator@243Z59L59Q55VQT MINGW64 /e/workplace/lee-blog (master)$ hexo d -gINFO  Validating configINFO  Start processingINFO  Files loaded in 640 ms...On branch masternothing to commit, working tree cleanCounting objects: 1167, done.Delta compression using up to 4 threads.Compressing objects: 100% (738/738), done.Writing objects: 100% (1167/1167), 7.87 MiB | 254.00 KiB/s, done.Total 1167 (delta 397), reused 0 (delta 0)remote: Resolving deltas: 100% (397/397), done.To github.com:GaryLeeeee/garyleeeee.github.io.git + 06ab1b8...af6b499 HEAD -&gt; master (forced update)Branch master set up to track remote branch master from git@github.com:GaryLeeeee/garyleeeee.github.io.git.INFO  Deploy done: git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>搞定！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池学习笔记</title>
      <link href="/2021/07/28/xian-cheng-chi-xue-xi-bi-ji/"/>
      <url>/2021/07/28/xian-cheng-chi-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一-使用线程池的好处"><a href="#一-使用线程池的好处" class="headerlink" title="一.使用线程池的好处"></a>一.使用线程池的好处</h2><ul><li><strong>降低资源消耗</strong><br><code>通过重复利用已创建的线程降低线程创建和销毁造成的消耗</code></li><li><strong>提高响应速度</strong><br><code>当任务到达时，任务可以不需要等到线程创建就能立即执行</code></li><li><strong>提高线程的可管理性</strong><br><code>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控</code></li></ul><h2 id="二-线程池使用场景"><a href="#二-线程池使用场景" class="headerlink" title="二.线程池使用场景"></a>二.线程池使用场景</h2><h3 id="1-用和不用有什么区别"><a href="#1-用和不用有什么区别" class="headerlink" title="1.用和不用有什么区别"></a>1.用和不用有什么区别</h3><ul><li>不使用线程池的情况下，任务顺序执行</li><li>使用线程池的情况下，任务同时执行</li></ul><h3 id="2-什么时候适合用"><a href="#2-什么时候适合用" class="headerlink" title="2.什么时候适合用"></a>2.什么时候适合用</h3><ul><li>对于多个耗时且互不依赖的任务，可选择使用线程池<blockquote><p>eg. 我们可以做家务的时候可以同时拖地和洗衣服(洗衣机)</p></blockquote></li><li>对于多个耗时且依赖结果的任务，可选择使用线程池+CountDownLatch<br><code>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行(阻塞)</code><blockquote><p>eg. 比如做一个项目需求，后端和前端同时开发(却不一定同时结束)，这时候快的一方必须等到慢的一方完成还可上线</p></blockquote></li></ul><h2 id="三-如何使用线程池"><a href="#三-如何使用线程池" class="headerlink" title="三.如何使用线程池"></a>三.如何使用线程池</h2><p>一般是通过ThreadPoolExecutor的构造函数来创建线程池，然后提交任务给线程池执行即可。<br><img src="https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/ThreadPoolExecutor.png" alt="ThreadPoolExecutor构造函数"></p><h3 id="1-构造函数参数作用"><a href="#1-构造函数参数作用" class="headerlink" title="1.构造函数参数作用"></a>1.构造函数参数作用</h3><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>int corePoolSize</td><td>线程池核心线程数</td></tr><tr><td>int maximumPoolSize</td><td>线程池最大线程数</td></tr><tr><td>long keepAliveTime</td><td>线程数大于核心线程数时，多余的空闲线程存活的最长时间</td></tr><tr><td>TimeUnit unit</td><td>时间单位</td></tr><tr><td>ThreadFactory threadFactory</td><td>线程工厂，用来创建线程，一般默认即可</td></tr><tr><td>RejectedExecutionHandler handler</td><td>拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</td></tr><tr><td>BlockingQueue<runnable> workQueue</runnable></td><td>阻塞队列，可指定大小</td></tr></tbody></table><h3 id="2-参数之间的关系"><a href="#2-参数之间的关系" class="headerlink" title="2.参数之间的关系"></a>2.参数之间的关系</h3><p>提交任务时：</p><ul><li>如果<code>poolSize</code>&lt;<code>corePoolSize</code>，会新创建一条线程并执行该任务</li><li>如果<code>poolSize</code>=<code>corePoolSize</code>，该任务会被放到阻塞队列(<code>workQueue</code>)等待</li><li>如果<code>workQueue</code>满了，且<code>poolSize</code>&lt;<code>maxmumPoolSize</code>，会新创建一条线程来执行该任务</li><li>如果<code>workQueue</code>满了，且<code>poolSize</code>=<code>maxmumPoolSize</code>，会根据拒绝策略<code>handler</code>拒绝该任务</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h3><p>new ThreadPoolExecutor().execute(()-&gt;{do sth.});<br><a href="https://github.com/GaryLeeeee/lee-code-repository">点击跳转</a></p><h3 id="4-execute、submit区别"><a href="#4-execute、submit区别" class="headerlink" title="4.execute、submit区别"></a>4.execute、submit区别</h3><ul><li>传参<ul><li>execute只能接受Runnable类型的任务</li><li>submit能接受Runnable和Callable类型的任务</li></ul></li><li>返回值<ul><li>execute没有返回值</li><li>submit有返回值(通过Future.get()获取)</li></ul></li><li>异常<ul><li>execute跟普通线程处理方式一致，通过try-catch捕获异常</li><li>submit会在call()抛出异常，所以需要Future.get()才能抛出异常</li></ul></li></ul><h3 id="5-建议不同类别的业务用不同的线程池"><a href="#5-建议不同类别的业务用不同的线程池" class="headerlink" title="5.建议不同类别的业务用不同的线程池"></a>5.建议不同类别的业务用不同的线程池</h3><h4 id="5-1-为什么呢？"><a href="#5-1-为什么呢？" class="headerlink" title="5.1 为什么呢？"></a>5.1 为什么呢？</h4><p>一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务</p><h4 id="5-2-错误案例"><a href="#5-2-错误案例" class="headerlink" title="5.2 错误案例"></a>5.2 错误案例</h4><p><a href="https://www.heapdump.cn/article/646639">《线程池运用不当的一次线上事故》</a></p><p>简单来说，就是线程池被父任务占满了，导致所有的子任务没有线程去执行(导致队列堆积)，而且父任务会阻塞住，造成死锁<br><img src="https://a.perfma.net/img/646605" alt="共用线程池死锁图示"></p><h2 id="四-正确配置线程池参数"><a href="#四-正确配置线程池参数" class="headerlink" title="四.正确配置线程池参数"></a>四.正确配置线程池参数</h2><ul><li>如果我们设置的线程池数量太小，如果同一时间有大量任务需要处理，那么就可能会导致大量任务要在任务队列等待，导致OOM。这样的CPU并没有得到充分利用。</li><li>如果我们设置的线程池数量太大，大量线程可能会同时争取CPU资源，导致有大量的上下文切换，从而增加线程的执行时间，影响整体的执行效率</li></ul><p>所以我们在设置线程池大小时有个公式（N为CPU核心数）</p><ul><li><strong>CPU密集型任务(N+1)</strong> 这种任务消耗的主要是CPU资源，可以将线程数设置为N(CPU核心数)+1，比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。</li><li><strong>I/O密集型任务(2N+1)</strong> 这种任务引用起来，系统会用大部分的事件来处理I/O交互，而线程在处理I/O的时间段内不会占用CPU来处理，这时就可以将CPU交出给其它线程使用。因此在I/O密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是2N+1。<pre class="line-numbers language-java" data-language="java"><code class="language-java">executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> executor<span class="token punctuation">.</span><span class="token function">setKeepAliveSeconds</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> executor<span class="token punctuation">.</span><span class="token function">setWaitForTasksToCompleteOnShutdown</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> executor<span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>CallerRunsPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五.总结"></a>五.总结</h2><ul><li>建议不同场景使用不同的线程池，防止死锁</li><li>空间换时间</li><li>不允许使用Executors创建线程池，应该通过ThreadPoolExecutor去创建</li><li>不同线程池命不同的名(如pool-1-thread-n)，有利于定位问题<ul><li><a href="https://github.com/GaryLeeeee/lee-code-repository">示例</a></li></ul></li></ul><h2 id="六-拒绝策略"><a href="#六-拒绝策略" class="headerlink" title="六.拒绝策略"></a>六.拒绝策略</h2><h3 id="1-什么时候会触发拒绝策略？"><a href="#1-什么时候会触发拒绝策略？" class="headerlink" title="1.什么时候会触发拒绝策略？"></a>1.什么时候会触发拒绝策略？</h3><p>当线程池的任务缓存队列<code>workQueue</code>已满且线程大小<code>poolSize</code>已达到<code>maximumPoolSize</code>，如果这时候还有新任务到来就会采取任务拒绝策略，通常有以下四种策略</p><ul><li>AbortPolicy(默认)：丢弃任务并抛出<code>RejectedExecutionException</code>异常</li><li>DiscardPolicy：丢弃任务(不抛出异常)</li><li>DiscardOldestPolicy：丢弃阻塞队列<code>workQueue</code>最前面的任务，然后执行新任务</li><li>CallerRunPolicy：由调用线程执行该任务</li></ul><h3 id="2-AbortPolicy"><a href="#2-AbortPolicy" class="headerlink" title="2.AbortPolicy"></a>2.AbortPolicy</h3><p>创建一个corePoolSize和maximumPoolSize都为1，阻塞队列大小为1的线程池。for循环起10个任务，每个任务sleep一秒。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbortPolicyDemo</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> THREAD_SIZE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 创建线程池：指定corePoolSize和maximumPoolSize都为1，阻塞队列大小为1</span>    <span class="token class-name">ThreadPoolExecutor</span> pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>THREAD_SIZE<span class="token punctuation">,</span> THREAD_SIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>CAPACITY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pool<span class="token punctuation">.</span><span class="token function">setRejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      pool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token string">"task-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" is running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//ignore</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试结果：</p><pre class="line-numbers language-none"><code class="language-none">Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.garylee.config.server.controller.admin.AdminLeeObjectConfigController$MyRunnable@3f8f9dd6 rejected from java.util.concurrent.ThreadPoolExecutor@aec6354[Running, pool size = 1, active threads = 1, queued tasks = 1, completed tasks = 0]at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)at com.garylee.config.server.controller.admin.AdminLeeObjectConfigController.main(AdminLeeObjectConfigController.java:150)task-1 is runningtask-2 is running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果分析：</p><ul><li><code>task-1</code>任务来了，起了一个线程，此时<code>poolSize</code>=<code>corePoolSize</code>=<code>maxmumPoolSize</code></li><li><code>task-2</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，就把<code>task-2</code>塞入阻塞队列<code>workQueue</code>中</li><li><code>task-3</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>AbortPolicy</code>拒绝策略，直接抛出<code>RejectExecutionException</code>异常</li><li><code>task-1</code>执行完毕</li><li><code>task-2</code>执行完毕</li><li>end</li></ul><h3 id="3-DiscardPolicy"><a href="#3-DiscardPolicy" class="headerlink" title="3.DiscardPolicy"></a>3.DiscardPolicy</h3><p>创建一个corePoolSize和maximumPoolSize都为1，阻塞队列大小为1的线程池。for循环起10个任务，每个任务sleep一秒。</p><pre class="line-numbers language-none"><code class="language-none">/** 其他代码省略，具体见6.2 /**pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试结果：</p><pre class="line-numbers language-none"><code class="language-none">task-1 is runningtask-2 is running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果分析：</p><ul><li><code>task-1</code>任务来了，起了一个线程，此时<code>poolSize</code>=<code>corePoolSize</code>=<code>maxmumPoolSize</code></li><li><code>task-2</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，就把<code>task-2</code>塞入阻塞队列<code>workQueue</code>中</li><li><code>task-3</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>DiscardPolicy</code>拒绝策略，直接丢弃任务</li><li><code>task-4</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>DiscardPolicy</code>拒绝策略，直接丢弃任务</li><li>…</li><li><code>task-10</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>DiscardPolicy</code>拒绝策略，直接丢弃任务</li><li><code>task-1</code>执行完毕</li><li><code>task-2</code>执行完毕</li><li>end</li></ul><h3 id="4-DiscardOldestPolicy"><a href="#4-DiscardOldestPolicy" class="headerlink" title="4.DiscardOldestPolicy"></a>4.DiscardOldestPolicy</h3><p>创建一个corePoolSize和maximumPoolSize都为1，阻塞队列大小为1的线程池。for循环起10个任务，每个任务sleep一秒。</p><pre class="line-numbers language-none"><code class="language-none">/** 其他代码省略，具体见6.2 /**pool.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardOldestPolicy());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试结果：</p><pre class="line-numbers language-none"><code class="language-none">task-1 is runningtask-10 is running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果分析：</p><ul><li><code>task-1</code>任务来了，起了一个线程，此时<code>poolSize</code>=<code>corePoolSize</code>=<code>maxmumPoolSize</code></li><li><code>task-2</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，就把<code>task-2</code>塞入阻塞队列<code>workQueue</code>中</li><li><code>task-3</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>DiscardOldestPolicy</code>拒绝策略，丢弃阻塞队列<code>workQueue</code>最前面的任务<code>task-2</code></li><li><code>task-4</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>DiscardOldestPolicy</code>拒绝策略，丢弃阻塞队列<code>workQueue</code>最前面的任务<code>task-3</code></li><li>…</li><li><code>task-10</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>DiscardOldestPolicy</code>拒绝策略，丢弃阻塞队列<code>workQueue</code>最前面的任务<code>task-9</code></li><li><code>task-1</code>执行完毕</li><li><code>task-10</code>执行完毕</li><li>end</li></ul><h3 id="5-CallerRunsPolicy"><a href="#5-CallerRunsPolicy" class="headerlink" title="5.CallerRunsPolicy"></a>5.CallerRunsPolicy</h3><p>创建一个corePoolSize和maximumPoolSize都为1，阻塞队列大小为1的线程池。for循环起10个任务，每个任务sleep一秒。</p><pre class="line-numbers language-none"><code class="language-none">/** 其他代码省略，具体见6.2 /**pool.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试结果：</p><pre class="line-numbers language-none"><code class="language-none">task-1 is runningtask-3 is runningtask-2 is runningtask-5 is runningtask-4 is runningtask-7 is runningtask-6 is runningtask-9 is runningtask-8 is runningtask-10 is running<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果分析：</p><ul><li><code>task-1</code>任务来了，起了一个线程，此时<code>poolSize</code>=<code>corePoolSize</code>=<code>maxmumPoolSize</code></li><li><code>task-2</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，就把<code>task-2</code>塞入阻塞队列<code>workQueue</code>中</li><li><code>task-3</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>CallerRunsPolicy</code>拒绝策略，加入<code>task-1</code>所在线程执行</li><li><code>task-1</code>和<code>task-3</code>执行完毕，<code>task-2</code>占用线程</li><li><code>task-4</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，就把<code>task-4</code>塞入阻塞队列<code>workQueue</code>中</li><li><code>task-5</code>任务来了，发现<code>poolSize</code>=<code>corePoolSize</code>，且阻塞队列<code>workQueue</code>满了，触发<code>CallerRunsPolicy</code>拒绝策略，加入<code>task-2</code>所在线程执行</li><li><code>task-2</code>和<code>task-5</code>执行完毕，<code>task-4</code>占用线程</li><li>…</li><li>end</li></ul><h2 id="七、线程、线程池状态"><a href="#七、线程、线程池状态" class="headerlink" title="七、线程、线程池状态"></a>七、线程、线程池状态</h2><h3 id="1、线程状态"><a href="#1、线程状态" class="headerlink" title="1、线程状态"></a>1、线程状态</h3><p><strong>线程</strong>有五种状态，分别为：</p><ul><li><strong>新建状态（New）</strong>：表示新创建了一个线程对象</li><li><strong>就绪状态（Runnable）</strong>：线程对象创建后，如果其他线程调用该对象的start方法，该线程就会放在可运行线程池中，变得可运行，等待获取CPU的使用权</li><li><strong>运行状态（Running）</strong>：<code>Running</code>的线程获取了CPU，执行程序代码</li><li><strong>阻塞状态（Blocked）</strong>：线程由于某些原因放弃了CPU使用权，暂时停止运行，直到线程进入<code>Runnable</code>，才有机会转到<code>Running</code></li><li><strong>死亡状态（Dead）</strong>：线程由于执行完毕或异常退出run方法，结束了生命周期</li></ul><h3 id="2、线程池状态"><a href="#2、线程池状态" class="headerlink" title="2、线程池状态"></a>2、线程池状态</h3><ul><li><strong>运行状态（RUNNING）</strong>：表示线程池正常运行，能接受新任务，也能正常处理队列中的任务</li><li><strong>关闭状态（SHUTDOWN）</strong>：表示线程池处于关闭状态，不能接受新任务，<font color="red">能正常处理队列中任务</font><ul><li><strong>状态切换</strong>：调用shutdown()方法，线程池状态由<code>RUNNING</code> -&gt; <code>SHUTDOWN</code></li></ul></li><li><strong>停止状态（STOP）</strong>：表示线程池处于停止状态，不能接受新任务，<font color="red">不能正常处理队列中任务，正在运行的线程也会停止</font><ul><li><strong>状态切换</strong>：调用shutdownnow()方法，线程池状态由(<code>RUNNING</code> or <code>SHUTDOWN</code>) -&gt; <code>STOP</code></li></ul></li><li><strong>整理状态（TIDYING）</strong>：线程池没线程在运行时，状态会自动变为<code>TIDYING</code>，并且会调用terminated()方法（该方法是空实现，留给调用方扩展）<ul><li><strong>状态切换</strong>：当线程池在<code>SHUTDOWN</code>状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由<code>SHUTDOWN</code> -&gt; <code>TIDYING</code>。 当线程池在<code>STOP</code>状态下，线程池中执行的任务为空时，就会由<code>STOP</code> -&gt; <code>TIDYING</code></li></ul></li><li><strong>销毁状态（TERMINATED）</strong>：表示线程池已彻底终止<ul><li><strong>状态切换</strong>：调用terminated()方法，线程池状态由<code>TIDYING</code> -&gt; <code>TERMINATED</code></li></ul></li></ul><h2 id="八、一些问题"><a href="#八、一些问题" class="headerlink" title="八、一些问题"></a>八、一些问题</h2><ul><li>核心线程数可以设置为0吗？</li><li>非核心线程什么时候会销毁？销毁的判断依据是什么？：空闲的时候</li><li>shutdown和shutdownnow的区别？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/25/hello-world/"/>
      <url>/2021/07/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
